<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_f64_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_f64_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over 64-bit double-precision floating point elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__common__ppc_8h_source.html">pveclib/vec_common_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__int128__ppc_8h_source.html">pveclib/vec_int128_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__f64__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab56ccacba6a3b48a7a920c7d5b0fe30e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ab56ccacba6a3b48a7a920c7d5b0fe30e">vec_absf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64x)</td></tr>
<tr class="memdesc:ab56ccacba6a3b48a7a920c7d5b0fe30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector double absolute value.  <a href="vec__f64__ppc_8h.html#ab56ccacba6a3b48a7a920c7d5b0fe30e">More...</a><br /></td></tr>
<tr class="separator:ab56ccacba6a3b48a7a920c7d5b0fe30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdfdf013a97ccd6dc20b1447f81d498"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a6bdfdf013a97ccd6dc20b1447f81d498">vec_all_isfinitef64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a6bdfdf013a97ccd6dc20b1447f81d498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 2x64-bit vector double values are Finite (Not NaN nor Inf).  <a href="vec__f64__ppc_8h.html#a6bdfdf013a97ccd6dc20b1447f81d498">More...</a><br /></td></tr>
<tr class="separator:a6bdfdf013a97ccd6dc20b1447f81d498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f2bf6308d932b9604dbd8c5f8e90da"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ac8f2bf6308d932b9604dbd8c5f8e90da">vec_all_isinff64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:ac8f2bf6308d932b9604dbd8c5f8e90da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 2x64-bit vector double values are infinity.  <a href="vec__f64__ppc_8h.html#ac8f2bf6308d932b9604dbd8c5f8e90da">More...</a><br /></td></tr>
<tr class="separator:ac8f2bf6308d932b9604dbd8c5f8e90da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b54640bbaa0ad0921680fe69a66246b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a3b54640bbaa0ad0921680fe69a66246b">vec_all_isnanf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a3b54640bbaa0ad0921680fe69a66246b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 2x64-bit vector double values are NaN.  <a href="vec__f64__ppc_8h.html#a3b54640bbaa0ad0921680fe69a66246b">More...</a><br /></td></tr>
<tr class="separator:a3b54640bbaa0ad0921680fe69a66246b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63ac21e968bf199eadd72f94b653905"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ab63ac21e968bf199eadd72f94b653905">vec_all_isnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:ab63ac21e968bf199eadd72f94b653905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 2x64-bit vector double values are normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f64__ppc_8h.html#ab63ac21e968bf199eadd72f94b653905">More...</a><br /></td></tr>
<tr class="separator:ab63ac21e968bf199eadd72f94b653905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b6b22fcc171729b47878782f823ab4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ad0b6b22fcc171729b47878782f823ab4">vec_all_issubnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:ad0b6b22fcc171729b47878782f823ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 2x64-bit vector double values are subnormal (denormal).  <a href="vec__f64__ppc_8h.html#ad0b6b22fcc171729b47878782f823ab4">More...</a><br /></td></tr>
<tr class="separator:ad0b6b22fcc171729b47878782f823ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27becc842e7270c96c54a00d4a292d54"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a27becc842e7270c96c54a00d4a292d54">vec_all_iszerof64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a27becc842e7270c96c54a00d4a292d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 2x64-bit vector double values are +-0.0.  <a href="vec__f64__ppc_8h.html#a27becc842e7270c96c54a00d4a292d54">More...</a><br /></td></tr>
<tr class="separator:a27becc842e7270c96c54a00d4a292d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5108dc5fc533329fdd794f306a6ec3d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#aa5108dc5fc533329fdd794f306a6ec3d">vec_any_isfinitef64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:aa5108dc5fc533329fdd794f306a6ec3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 2x64-bit vector double values are Finite (Not NaN nor Inf).  <a href="vec__f64__ppc_8h.html#aa5108dc5fc533329fdd794f306a6ec3d">More...</a><br /></td></tr>
<tr class="separator:aa5108dc5fc533329fdd794f306a6ec3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71abdbd1fd938daa250682ef9bbc5e84"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a71abdbd1fd938daa250682ef9bbc5e84">vec_any_isinff64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a71abdbd1fd938daa250682ef9bbc5e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 2x64-bit vector double values are infinity.  <a href="vec__f64__ppc_8h.html#a71abdbd1fd938daa250682ef9bbc5e84">More...</a><br /></td></tr>
<tr class="separator:a71abdbd1fd938daa250682ef9bbc5e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78d13a9a604d48250a0aecba84ce8f2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ad78d13a9a604d48250a0aecba84ce8f2">vec_any_isnanf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:ad78d13a9a604d48250a0aecba84ce8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 2x64-bit vector double values are NaN.  <a href="vec__f64__ppc_8h.html#ad78d13a9a604d48250a0aecba84ce8f2">More...</a><br /></td></tr>
<tr class="separator:ad78d13a9a604d48250a0aecba84ce8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c198001c1db455c8a70478fe7c76c8c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a9c198001c1db455c8a70478fe7c76c8c">vec_any_isnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a9c198001c1db455c8a70478fe7c76c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 2x64-bit vector double values are normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f64__ppc_8h.html#a9c198001c1db455c8a70478fe7c76c8c">More...</a><br /></td></tr>
<tr class="separator:a9c198001c1db455c8a70478fe7c76c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96007b688d4c2c6aed732ec1b04a78de"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a96007b688d4c2c6aed732ec1b04a78de">vec_any_issubnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a96007b688d4c2c6aed732ec1b04a78de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 2x64-bit vector double values is subnormal (denormal).  <a href="vec__f64__ppc_8h.html#a96007b688d4c2c6aed732ec1b04a78de">More...</a><br /></td></tr>
<tr class="separator:a96007b688d4c2c6aed732ec1b04a78de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c593b367639924729e7d8fbb044f0e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a47c593b367639924729e7d8fbb044f0e">vec_any_iszerof64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a47c593b367639924729e7d8fbb044f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 2x64-bit vector double values are +-0.0.  <a href="vec__f64__ppc_8h.html#a47c593b367639924729e7d8fbb044f0e">More...</a><br /></td></tr>
<tr class="separator:a47c593b367639924729e7d8fbb044f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d567f31837de74d7fa722b59e73928"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a59d567f31837de74d7fa722b59e73928">vec_copysignf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64x, <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64y)</td></tr>
<tr class="memdesc:a59d567f31837de74d7fa722b59e73928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign bit from vf64x merged with magnitude from vf64y and return the resulting vector double values.  <a href="vec__f64__ppc_8h.html#a59d567f31837de74d7fa722b59e73928">More...</a><br /></td></tr>
<tr class="separator:a59d567f31837de74d7fa722b59e73928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0220385a453649170124948f9085f1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#aae0220385a453649170124948f9085f1">vec_isfinitef64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:aae0220385a453649170124948f9085f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2x64-bit vector boolean true values for each double element that is Finite (Not NaN nor Inf).  <a href="vec__f64__ppc_8h.html#aae0220385a453649170124948f9085f1">More...</a><br /></td></tr>
<tr class="separator:aae0220385a453649170124948f9085f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5508cb768d48ffec6e833076fc10b497"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a5508cb768d48ffec6e833076fc10b497">vec_isinff64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a5508cb768d48ffec6e833076fc10b497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2x64-bit vector boolean true values for each double, if infinity.  <a href="vec__f64__ppc_8h.html#a5508cb768d48ffec6e833076fc10b497">More...</a><br /></td></tr>
<tr class="separator:a5508cb768d48ffec6e833076fc10b497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131162bc90efca47ad3e5513d73c3350"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a131162bc90efca47ad3e5513d73c3350">vec_isnanf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a131162bc90efca47ad3e5513d73c3350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2x64-bit vector boolean true values, for each double NaN value.  <a href="vec__f64__ppc_8h.html#a131162bc90efca47ad3e5513d73c3350">More...</a><br /></td></tr>
<tr class="separator:a131162bc90efca47ad3e5513d73c3350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f764b415ce41cbbc504554f779bcbe6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a8f764b415ce41cbbc504554f779bcbe6">vec_isnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a8f764b415ce41cbbc504554f779bcbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2x64-bit vector boolean true values, for each double value, if normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f64__ppc_8h.html#a8f764b415ce41cbbc504554f779bcbe6">More...</a><br /></td></tr>
<tr class="separator:a8f764b415ce41cbbc504554f779bcbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec48e60f9252ceb1d82ecb76cbce08a8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#aec48e60f9252ceb1d82ecb76cbce08a8">vec_issubnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:aec48e60f9252ceb1d82ecb76cbce08a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2x64-bit vector boolean true values, for each double value that is subnormal (denormal).  <a href="vec__f64__ppc_8h.html#aec48e60f9252ceb1d82ecb76cbce08a8">More...</a><br /></td></tr>
<tr class="separator:aec48e60f9252ceb1d82ecb76cbce08a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0391d8549f3070e515c0f20ed6bea9ac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a0391d8549f3070e515c0f20ed6bea9ac">vec_iszerof64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a0391d8549f3070e515c0f20ed6bea9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2x64-bit vector boolean true values, for each double value that is +-0.0.  <a href="vec__f64__ppc_8h.html#a0391d8549f3070e515c0f20ed6bea9ac">More...</a><br /></td></tr>
<tr class="separator:a0391d8549f3070e515c0f20ed6bea9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd670e9d3dd600198336708bb71fe77"><td class="memItemLeft" align="right" valign="top">static long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#aabd670e9d3dd600198336708bb71fe77">vec_pack_longdouble</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> lval)</td></tr>
<tr class="memdesc:aabd670e9d3dd600198336708bb71fe77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the pair of doubles from a vector to IBM long double.  <a href="vec__f64__ppc_8h.html#aabd670e9d3dd600198336708bb71fe77">More...</a><br /></td></tr>
<tr class="separator:aabd670e9d3dd600198336708bb71fe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b3262fcab4c94f1cfb263eed118ed1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#aa0b3262fcab4c94f1cfb263eed118ed1">vec_setb_dp</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vra)</td></tr>
<tr class="memdesc:aa0b3262fcab4c94f1cfb263eed118ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Set Bool from Sign, Double Precision.  <a href="vec__f64__ppc_8h.html#aa0b3262fcab4c94f1cfb263eed118ed1">More...</a><br /></td></tr>
<tr class="separator:aa0b3262fcab4c94f1cfb263eed118ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac396fe321d73f75b57ebab8c365e20f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ac396fe321d73f75b57ebab8c365e20f3">vec_unpack_longdouble</a> (long double lval)</td></tr>
<tr class="memdesc:ac396fe321d73f75b57ebab8c365e20f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the pair of doubles from a IBM long double to a vector double.  <a href="vec__f64__ppc_8h.html#ac396fe321d73f75b57ebab8c365e20f3">More...</a><br /></td></tr>
<tr class="separator:ac396fe321d73f75b57ebab8c365e20f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb96abe1cd1f78c4eee978add6268c80"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#aeb96abe1cd1f78c4eee978add6268c80">vec_vglfdso</a> (double *array, const long long offset0, const long long offset1)</td></tr>
<tr class="memdesc:aeb96abe1cd1f78c4eee978add6268c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Float Double from scalar Offsets.  <a href="vec__f64__ppc_8h.html#aeb96abe1cd1f78c4eee978add6268c80">More...</a><br /></td></tr>
<tr class="separator:aeb96abe1cd1f78c4eee978add6268c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9874d40fa1cfec22033d06fc2dcac8eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a9874d40fa1cfec22033d06fc2dcac8eb">vec_vglfddo</a> (double *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:a9874d40fa1cfec22033d06fc2dcac8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Float Double from Doubleword Offsets.  <a href="vec__f64__ppc_8h.html#a9874d40fa1cfec22033d06fc2dcac8eb">More...</a><br /></td></tr>
<tr class="separator:a9874d40fa1cfec22033d06fc2dcac8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28486b82d19b6d19f4bf2790ea7912d2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a28486b82d19b6d19f4bf2790ea7912d2">vec_vglfddsx</a> (double *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, const unsigned char scale)</td></tr>
<tr class="memdesc:a28486b82d19b6d19f4bf2790ea7912d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Float Double from Doubleword Scaled Indexes.  <a href="vec__f64__ppc_8h.html#a28486b82d19b6d19f4bf2790ea7912d2">More...</a><br /></td></tr>
<tr class="separator:a28486b82d19b6d19f4bf2790ea7912d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0db2a52dab536b7f9e181f58049050b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ab0db2a52dab536b7f9e181f58049050b">vec_vglfddx</a> (double *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:ab0db2a52dab536b7f9e181f58049050b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Float Double from Doubleword indexes.  <a href="vec__f64__ppc_8h.html#ab0db2a52dab536b7f9e181f58049050b">More...</a><br /></td></tr>
<tr class="separator:ab0db2a52dab536b7f9e181f58049050b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18796558bb5e508164d565daec3a6d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ac18796558bb5e508164d565daec3a6d5">vec_vsstfdso</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> xs, double *array, const long long offset0, const long long offset1)</td></tr>
<tr class="memdesc:ac18796558bb5e508164d565daec3a6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Float Double to Scalar Offsets.  <a href="vec__f64__ppc_8h.html#ac18796558bb5e508164d565daec3a6d5">More...</a><br /></td></tr>
<tr class="separator:ac18796558bb5e508164d565daec3a6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8eb9e570786d34728fa025d609f589"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#afd8eb9e570786d34728fa025d609f589">vec_vsstfddo</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> xs, double *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:afd8eb9e570786d34728fa025d609f589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Float Double to Doubleword Offsets.  <a href="vec__f64__ppc_8h.html#afd8eb9e570786d34728fa025d609f589">More...</a><br /></td></tr>
<tr class="separator:afd8eb9e570786d34728fa025d609f589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098478cc68594e80cf3c0cec354a8d53"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a098478cc68594e80cf3c0cec354a8d53">vec_vsstfddsx</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> xs, double *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, const unsigned char scale)</td></tr>
<tr class="memdesc:a098478cc68594e80cf3c0cec354a8d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Float Double to Doubleword Scaled Index.  <a href="vec__f64__ppc_8h.html#a098478cc68594e80cf3c0cec354a8d53">More...</a><br /></td></tr>
<tr class="separator:a098478cc68594e80cf3c0cec354a8d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20d0c1794f3a3e26423f74b60963783"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#af20d0c1794f3a3e26423f74b60963783">vec_vsstfddx</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> xs, double *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:af20d0c1794f3a3e26423f74b60963783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Float Double to Doubleword Indexes.  <a href="vec__f64__ppc_8h.html#af20d0c1794f3a3e26423f74b60963783">More...</a><br /></td></tr>
<tr class="separator:af20d0c1794f3a3e26423f74b60963783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1544662cecef47cd56225869a5d2e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#aca1544662cecef47cd56225869a5d2e8">vec_vlxsfdx</a> (const signed long long ra, const double *rb)</td></tr>
<tr class="memdesc:aca1544662cecef47cd56225869a5d2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Load Scalar Float Double Indexed.  <a href="vec__f64__ppc_8h.html#aca1544662cecef47cd56225869a5d2e8">More...</a><br /></td></tr>
<tr class="separator:aca1544662cecef47cd56225869a5d2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd382753ae41ea181e88bb2672430e2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a7dd382753ae41ea181e88bb2672430e2">vec_vstxsfdx</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> xs, const signed long long ra, double *rb)</td></tr>
<tr class="memdesc:a7dd382753ae41ea181e88bb2672430e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Store Scalar Float Double Indexed.  <a href="vec__f64__ppc_8h.html#a7dd382753ae41ea181e88bb2672430e2">More...</a><br /></td></tr>
<tr class="separator:a7dd382753ae41ea181e88bb2672430e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4774a0cb9ea619f1d6cee6bb119088b5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a4774a0cb9ea619f1d6cee6bb119088b5">vec_xviexpdp</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> sig, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp)</td></tr>
<tr class="memdesc:a4774a0cb9ea619f1d6cee6bb119088b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Insert Exponent Double-Precision.  <a href="vec__f64__ppc_8h.html#a4774a0cb9ea619f1d6cee6bb119088b5">More...</a><br /></td></tr>
<tr class="separator:a4774a0cb9ea619f1d6cee6bb119088b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb534c11a544d9e0b61acdecbb62adaa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#acb534c11a544d9e0b61acdecbb62adaa">vec_xvxexpdp</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vrb)</td></tr>
<tr class="memdesc:acb534c11a544d9e0b61acdecbb62adaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Extract Exponent Double-Precision.  <a href="vec__f64__ppc_8h.html#acb534c11a544d9e0b61acdecbb62adaa">More...</a><br /></td></tr>
<tr class="separator:acb534c11a544d9e0b61acdecbb62adaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b42004c11b01c7606d8d6e299e8107"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#af8b42004c11b01c7606d8d6e299e8107">vec_xvxsigdp</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vrb)</td></tr>
<tr class="memdesc:af8b42004c11b01c7606d8d6e299e8107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Extract Significand Double-Precision.  <a href="vec__f64__ppc_8h.html#af8b42004c11b01c7606d8d6e299e8107">More...</a><br /></td></tr>
<tr class="separator:af8b42004c11b01c7606d8d6e299e8107"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over 64-bit double-precision floating point elements. </p>
<p>Many vector double-precision (64-bit float) operations are implemented with PowerISA-2.06 Vector Scalar Extended (VSX) (POWER7 and later) instructions. Most VSX instructions provide access to 64 combined scalar/vector registers. PowerISA-3.0 (POWER9) provides additional vector double operations: convert with round, convert to/from integer, insert/extract exponent and significand, and test data class. Most of these operations (compiler built-ins, or intrinsics) are defined in &lt;altivec.h&gt; and described in the <a href="https://gcc.gnu.org/onlinedocs/">compiler documentation</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power8</b>, the double-precision vector converts, insert/extract and test data class built-ins are are not defined. This header provides the appropriate substitutions, will generate the minimum code, appropriate for the target, and produce correct results.</dd>
<dd>
Most ppc64le compilers will default to -mcpu=power8 if not specified.</dd>
<dd>
GCC 7.3 defines vector forms of the test data class, extract significand, and extract/insert_exp for float and double. These built-ins are not defined in GCC 6.4. See <a href="https://gcc.gnu.org/onlinedocs/">compiler documentation</a>. These are useful operations and can be implemented in a few vector logical instructions for earlier machines.</dd></dl>
<p>So it is reasonable for this header to provide vector forms of the double-precision floating point classification functions (isnormal/subnormal/finite/inf/nan/zero, etc.). These functions can be implemented directly using (one or more) POWER9 instructions, or a few vector logical and integer compare instructions for POWER7/8. Each is comfortably small enough to be in-lined and inherently faster than the equivalent POSIX or compiler built-in runtime scalar functions.</p>
<p>Most of these operations are implemented in a few instructions on newer (POWER7/POWER8/POWER9) processors. This header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides an inline assembler implementation for older compilers that do not provide the built-ins.</p>
<p>This header covers operations that are any of the following:</p>
<ul>
<li>Implemented in hardware instructions in newer processors, but useful to programmers on slightly older processors (even if the equivalent function requires more instructions).</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.h&gt; provided by available compilers in common use. Examples include vector double even/odd conversions.</li>
<li>Providing special vector double tests for special conditions without generating extraneous floating-point exceptions. This is important for implementing vectorized forms of ISO C99 Math functions. Examples include vector double isnan, isinf, etc.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious. For example, converts that change element size and imply converting two vectors into one vector of smaller elements, or one vector into two vectors of larger elements. Another example is the special case of packing/unpacking an IBM long double between a pair of floating-point registers (FPRs) and a single vector register (VR).</li>
</ul>
<h1><a class="anchor" id="f64_examples_0_0"></a>
Examples</h1>
<p>For example: using the the classification functions for implementing the math library function sine and cosine. The POSIX specification requires that special input values are processed without raising extraneous floating point exceptions and return specific floating point values in response. For example, the sin() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>value</em>.</li>
<li>If the input <em>value</em> is subnormal then return <em>value</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a quiet-NaN.</li>
<li>Otherwise compute and return sin(value).</li>
</ul>
<p>The following code example uses functions from this header to address the POSIX requirements for special values input to for a vectorized sinf(): </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a></div>
<div class="line">test_vec_sinf64 (<a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> value)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_f0 = { 0.0, 0.0 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_f64_qnan =</div>
<div class="line">    { 0x7ff8000000000000, 0x7ff8000000000000 };</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> result;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> normmask, infmask;</div>
<div class="line"> </div>
<div class="line">  normmask = <a class="code" href="vec__f64__ppc_8h.html#a8f764b415ce41cbbc504554f779bcbe6">vec_isnormalf64</a> (value);</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#a9c198001c1db455c8a70478fe7c76c8c">vec_any_isnormalf64</a> (value))</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// replace non-normal input values with safe values.</span></div>
<div class="line">      <a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> safeval = vec_sel (vec_f0, value, normmask);</div>
<div class="line">      <span class="comment">// body of vec_sin(safeval) computation elided for this example.</span></div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    result = value;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// merge non-normal input values back into result</span></div>
<div class="line">  result = vec_sel (value, result, normmask);</div>
<div class="line">  <span class="comment">// Inf input value elements return quiet-nan.</span></div>
<div class="line">  infmask = <a class="code" href="vec__f64__ppc_8h.html#a5508cb768d48ffec6e833076fc10b497">vec_isinff64</a> (value);</div>
<div class="line">  result = vec_sel (result, (<a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>) vec_f64_qnan, infmask);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The code generated for this fragment runs between 24 (-mcpu=power9) and 40 (-mcpu=power8) instructions. The normal execution path is 14 to 25 instructions respectively.</p>
<p>Another example the cos() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>1.0</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a quiet-NaN.</li>
<li>Otherwise compute and return cos(value).</li>
</ul>
<p>The following code example uses functions from this header to address the POSIX requirements for special values input to vectorized cosf(): </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a></div>
<div class="line">test_vec_cosf64 (<a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> value)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> result;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_f0 = { 0.0, 0.0 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_f1 = { 1.0, 1.0 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_f64_qnan =</div>
<div class="line">    { 0x7ff8000000000000, 0x7ff8000000000000 };</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> finitemask, infmask, zeromask;</div>
<div class="line"> </div>
<div class="line">  finitemask = <a class="code" href="vec__f64__ppc_8h.html#aae0220385a453649170124948f9085f1">vec_isfinitef64</a> (value);</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#aa5108dc5fc533329fdd794f306a6ec3d">vec_any_isfinitef64</a> (value))</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// replace non-finite input values with safe values.</span></div>
<div class="line">      <a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> safeval = vec_sel (vec_f0, value, finitemask);</div>
<div class="line">      <span class="comment">// body of vec_sin(safeval) computation elided for this example.</span></div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    result = value;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// merge non-finite input values back into result</span></div>
<div class="line">  result = vec_sel (value, result, finitemask);</div>
<div class="line">  <span class="comment">// Set +-0.0 input elements to exactly 1.0 in result.</span></div>
<div class="line">  zeromask = <a class="code" href="vec__f64__ppc_8h.html#a0391d8549f3070e515c0f20ed6bea9ac">vec_iszerof64</a> (value);</div>
<div class="line">  result = vec_sel (result, vec_f1, zeromask);</div>
<div class="line">  <span class="comment">// Set Inf input elements to quiet-nan in result.</span></div>
<div class="line">  infmask = <a class="code" href="vec__f64__ppc_8h.html#a5508cb768d48ffec6e833076fc10b497">vec_isinff64</a> (value);</div>
<div class="line">  result = vec_sel (result, (<a class="code" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>) vec_f64_qnan, infmask);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Neither example raises floating point exceptions or sets <b>errno</b>, as appropriate for a vector math library.</p>
<h1><a class="anchor" id="f64_perf_0_0"></a>
Performance data.</h1>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab56ccacba6a3b48a7a920c7d5b0fe30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56ccacba6a3b48a7a920c7d5b0fe30e">&#9670;&nbsp;</a></span>vec_absf64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_absf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector double absolute value. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64x</td><td>vector double values containing the magnitudes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector double absolute values of vf64x. </dd></dl>

</div>
</div>
<a id="a6bdfdf013a97ccd6dc20b1447f81d498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdfdf013a97ccd6dc20b1447f81d498">&#9670;&nbsp;</a></span>vec_all_isfinitef64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isfinitef64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 2x64-bit vector double values are Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary64 finite value has an exponent between 0x000 and 0x7fe (a 0x7ff indicates NaN or Inf). The significand can be any value. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __binary64 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="ac8f2bf6308d932b9604dbd8c5f8e90da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f2bf6308d932b9604dbd8c5f8e90da">&#9670;&nbsp;</a></span>vec_all_isinff64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isinff64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 2x64-bit vector double values are infinity. </p>
<p>A IEEE Binary64 infinity has a exponent of 0x7ff and significand of all zeros. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int, true if all 2 double values are infinity </dd></dl>

</div>
</div>
<a id="a3b54640bbaa0ad0921680fe69a66246b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b54640bbaa0ad0921680fe69a66246b">&#9670;&nbsp;</a></span>vec_all_isnanf64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnanf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 2x64-bit vector double values are NaN. </p>
<p>A IEEE Binary64 NaN value has an exponent between 0x7ff and the significand is nonzero. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all 2 vector double values are NaN. </dd></dl>

</div>
</div>
<a id="ab63ac21e968bf199eadd72f94b653905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63ac21e968bf199eadd72f94b653905">&#9670;&nbsp;</a></span>vec_all_isnormalf64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 2x64-bit vector double values are normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary64 normal value has an exponent between 0x001 and 0x7fe (a 0x7ff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-28 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all 2 vector double values are normal. </dd></dl>

</div>
</div>
<a id="ad0b6b22fcc171729b47878782f823ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b6b22fcc171729b47878782f823ab4">&#9670;&nbsp;</a></span>vec_all_issubnormalf64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_issubnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 2x64-bit vector double values are subnormal (denormal). </p>
<p>A IEEE Binary64 subnormal has an exponent of 0x000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-30 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all of 2 vector double values are subnormal. </dd></dl>

</div>
</div>
<a id="a27becc842e7270c96c54a00d4a292d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27becc842e7270c96c54a00d4a292d54">&#9670;&nbsp;</a></span>vec_all_iszerof64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_iszerof64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 2x64-bit vector double values are +-0.0. </p>
<p>A IEEE Binary64 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all 2 vector double values are +/- zero. </dd></dl>

</div>
</div>
<a id="aa5108dc5fc533329fdd794f306a6ec3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5108dc5fc533329fdd794f306a6ec3d">&#9670;&nbsp;</a></span>vec_any_isfinitef64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_isfinitef64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 2x64-bit vector double values are Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary64 finite value has an exponent between 0x000 and 0x7fe (a 0x7ff indicates NaN or Inf). The significand can be any value. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="a71abdbd1fd938daa250682ef9bbc5e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71abdbd1fd938daa250682ef9bbc5e84">&#9670;&nbsp;</a></span>vec_any_isinff64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_isinff64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 2x64-bit vector double values are infinity. </p>
<p>A IEEE Binary64 infinity has a exponent of 0x7ff and significand of all zeros.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int, true if any of 2 double values are infinity </dd></dl>

</div>
</div>
<a id="ad78d13a9a604d48250a0aecba84ce8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78d13a9a604d48250a0aecba84ce8f2">&#9670;&nbsp;</a></span>vec_any_isnanf64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_isnanf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 2x64-bit vector double values are NaN. </p>
<p>A IEEE Binary64 NaN value has an exponent between 0x7ff and the significand is nonzero. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if any of 2 vector double values are NaN. </dd></dl>

</div>
</div>
<a id="a9c198001c1db455c8a70478fe7c76c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c198001c1db455c8a70478fe7c76c8c">&#9670;&nbsp;</a></span>vec_any_isnormalf64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_isnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 2x64-bit vector double values are normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary64 normal value has an exponent between 0x001 and 0x7fe (a 0x7ff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if any of 2 vector double values are normal. </dd></dl>

</div>
</div>
<a id="a96007b688d4c2c6aed732ec1b04a78de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96007b688d4c2c6aed732ec1b04a78de">&#9670;&nbsp;</a></span>vec_any_issubnormalf64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_issubnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 2x64-bit vector double values is subnormal (denormal). </p>
<p>A IEEE Binary64 subnormal has an exponent of 0x000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-18 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any of 2 vector double values are subnormal. </dd></dl>

</div>
</div>
<a id="a47c593b367639924729e7d8fbb044f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c593b367639924729e7d8fbb044f0e">&#9670;&nbsp;</a></span>vec_any_iszerof64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_iszerof64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 2x64-bit vector double values are +-0.0. </p>
<p>A IEEE Binary64 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if any of 2 vector double values are +/- zero. </dd></dl>

</div>
</div>
<a id="a59d567f31837de74d7fa722b59e73928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d567f31837de74d7fa722b59e73928">&#9670;&nbsp;</a></span>vec_copysignf64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_copysignf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the sign bit from vf64x merged with magnitude from vf64y and return the resulting vector double values. </p>
<dl class="section note"><dt>Note</dt><dd>This operation was patterned after the intrinsic vec_cpsgn (altivec.h) introduced for POWER7 and VSX. It turns out the original (GCC 4.9) compiler implementation reversed the operands and does not match the PowerISA or the Vector Intrinsic Programming Reference manuals. Subsequent compilers and PVECLIB implementations replicated this (operand order) error. This has now been reported as bug against the compilers, which are in the process of applying fixes and distributing updates. This version of PVECLIB is updated to match the Vector Intrinsic Programming Reference. This implementation is independent of the compilers update status.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64x</td><td>vector double values containing the sign bits. </td></tr>
    <tr><td class="paramname">vf64y</td><td>vector double values containing the magnitudes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector double values with magnitude from vf64y and the sign of vf64x. </dd></dl>

</div>
</div>
<a id="aae0220385a453649170124948f9085f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0220385a453649170124948f9085f1">&#9670;&nbsp;</a></span>vec_isfinitef64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_isfinitef64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2x64-bit vector boolean true values for each double element that is Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary64 finite value has an exponent between 0x000 and 0x7fe (a 0x7ff indicates NaN or Inf). The significand can be any value.</p>
<p>Using the vec_cmpeq conditional to generate the predicate mask for NaN / Inf and then invert this for the finite condition. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-15 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a5508cb768d48ffec6e833076fc10b497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5508cb768d48ffec6e833076fc10b497">&#9670;&nbsp;</a></span>vec_isinff64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_isinff64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2x64-bit vector boolean true values for each double, if infinity. </p>
<p>A IEEE Binary64 infinity has a exponent of 0x7ff and significand of all zeros.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-13 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a131162bc90efca47ad3e5513d73c3350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131162bc90efca47ad3e5513d73c3350">&#9670;&nbsp;</a></span>vec_isnanf64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_isnanf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2x64-bit vector boolean true values, for each double NaN value. </p>
<p>A IEEE Binary64 NaN value has an exponent between 0x7ff and the significand is nonzero. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-13 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a8f764b415ce41cbbc504554f779bcbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f764b415ce41cbbc504554f779bcbe6">&#9670;&nbsp;</a></span>vec_isnormalf64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_isnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2x64-bit vector boolean true values, for each double value, if normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary64 normal value has an exponent between 0x001 and 0x7ffe (a 0x7ff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero).</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-15 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="aec48e60f9252ceb1d82ecb76cbce08a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec48e60f9252ceb1d82ecb76cbce08a8">&#9670;&nbsp;</a></span>vec_issubnormalf64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_issubnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2x64-bit vector boolean true values, for each double value that is subnormal (denormal). </p>
<p>A IEEE Binary64 subnormal has an exponent of 0x000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-16 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a0391d8549f3070e515c0f20ed6bea9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0391d8549f3070e515c0f20ed6bea9ac">&#9670;&nbsp;</a></span>vec_iszerof64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_iszerof64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2x64-bit vector boolean true values, for each double value that is +-0.0. </p>
<p>A IEEE Binary64 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-13 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="aabd670e9d3dd600198336708bb71fe77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd670e9d3dd600198336708bb71fe77">&#9670;&nbsp;</a></span>vec_pack_longdouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long double vec_pack_longdouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>lval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the pair of doubles from a vector to IBM long double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lval</td><td>vector double values containing the IBM long double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IBM long double as FPR pair. </dd></dl>

</div>
</div>
<a id="aa0b3262fcab4c94f1cfb263eed118ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b3262fcab4c94f1cfb263eed118ed1">&#9670;&nbsp;</a></span>vec_setb_dp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_setb_dp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Set Bool from Sign, Double Precision. </p>
<p>For each double, propagate the sign bit to all 64-bits of that doubleword. The result is vector bool long long reflecting the sign bit of each 64-bit double.</p>
<p>The resulting mask can be used in vector masking and select operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation will set the sign mask regardless of data class, while the Vector Test Data Class instructions will not distinguish between +/- NaN.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-4 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2-5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>Vector double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector bool long long reflecting the sign bits of each double value. </dd></dl>

</div>
</div>
<a id="ac396fe321d73f75b57ebab8c365e20f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac396fe321d73f75b57ebab8c365e20f3">&#9670;&nbsp;</a></span>vec_unpack_longdouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_unpack_longdouble </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>lval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the pair of doubles from a IBM long double to a vector double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lval</td><td>IBM long double as FPR pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector double values containing the IBM long double. </dd></dl>

</div>
</div>
<a id="a9874d40fa1cfec22033d06fc2dcac8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9874d40fa1cfec22033d06fc2dcac8eb">&#9670;&nbsp;</a></span>vec_vglfddo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_vglfddo </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Float Double from Doubleword Offsets. </p>
<p>For each doubleword element [i] of vra, load the float double element at *(char*)array+vra[i]. Merge those float double elements and return the resulting vector.</p>
<dl class="section note"><dt>Note</dt><dd>As effective address calculation is modulo 64-bits, signed or unsigned doubleword offsets are equivalent.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">11 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of doubles. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword (64-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector double containing elements loaded from *(char*)array+vra[0] and *(char*)array+vra[1]. </dd></dl>

</div>
</div>
<a id="a28486b82d19b6d19f4bf2790ea7912d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28486b82d19b6d19f4bf2790ea7912d2">&#9670;&nbsp;</a></span>vec_vglfddsx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_vglfddsx </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Float Double from Doubleword Scaled Indexes. </p>
<p>For each doubleword element [i] of vra, load the float double element *array[vra[i] * (1 &lt;&lt; scale)]. Merge those float double elements and return the resulting vector. Indexes are converted to offsets from *array by shifting each doubleword left (3+scale) bits.</p>
<dl class="section note"><dt>Note</dt><dd>As effective address calculation is modulo 64-bits, signed or unsigned doubleword indexes are equivalent.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">13-22 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of doubles. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword indexes. </td></tr>
    <tr><td class="paramname">scale</td><td>8-bit integer. Indexes are multiplied by 2<sup>scale</sup>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector double containing array[vra[0]*(1&lt;&lt;scale)] and array[vra[1]*(1&lt;&lt;scale)]. </dd></dl>

</div>
</div>
<a id="ab0db2a52dab536b7f9e181f58049050b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0db2a52dab536b7f9e181f58049050b">&#9670;&nbsp;</a></span>vec_vglfddx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_vglfddx </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Float Double from Doubleword indexes. </p>
<p>For each doubleword element [i] of vra, load the double element array[vra[i]]. Merge those float double elements and return the resulting vector. The indexes are converted to offsets from *array by shifting each doubleword index left 3-bits (*8).</p>
<dl class="section note"><dt>Note</dt><dd>As effective address calculation is modulo 64-bits, signed or unsigned doubleword indexes are equivalent.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">13-22 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of doubles. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword indexes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector double containing {array[vra[0]], array[vra[1]]}. </dd></dl>

</div>
</div>
<a id="aeb96abe1cd1f78c4eee978add6268c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb96abe1cd1f78c4eee978add6268c80">&#9670;&nbsp;</a></span>vec_vglfdso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_vglfdso </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Float Double from scalar Offsets. </p>
<p>For each scalar offset[0|1], load the float double element at *(char*)array+offset[0|1]. Merge those float double elements and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">11 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of doubles. </td></tr>
    <tr><td class="paramname">offset0</td><td>Scalar (64-bit) byte offsets from &amp;array. </td></tr>
    <tr><td class="paramname">offset1</td><td>Scalar (64-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector double containing elements loaded from *(char*)array+offset0 and *(char*)array+offset1. </dd></dl>

</div>
</div>
<a id="aca1544662cecef47cd56225869a5d2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1544662cecef47cd56225869a5d2e8">&#9670;&nbsp;</a></span>vec_vlxsfdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_vlxsfdx </td>
          <td>(</td>
          <td class="paramtype">const signed long long&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Load Scalar Float Double Indexed. </p>
<p>Load the left most doubleword of vector <b>xt</b> as a scalar double from the effective address formed by <b>rb+ra</b>. The operand <b>rb</b> is a pointer to an array of doubles. The operand <b>ra</b> is a doubleword integer byte offset from <b>rb</b>. The result <b>xt</b> is returned as a vf64_t vector. For best performance <b>rb</b> and <b>ra</b> should be doubleword aligned (integer multiple of 8).</p>
<dl class="section note"><dt>Note</dt><dd>the right most doubleword of vector <b>xt</b> is left <em>undefined</em> by this operation.</dd></dl>
<p>This operation is an alternate form of Vector Load Element (vec_lde), with the added simplification that data is always left justified in the vector. This simplifies merging elements for gather operations.</p>
<dl class="section note"><dt>Note</dt><dd>This is instruction was introduced in PowerISA 2.06 (POWER7). For POWER8/9 there are additional optimizations by effectively converting small constant index values into displacements. For POWER8 a specific pattern of addi/lsxdx instruction is <em>fused</em> into a single load displacement internal operation. For POWER9 we can use the lxsd (DS-form) instruction directly.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ra</td><td>const doubleword index (offset/displacement). </td></tr>
    <tr><td class="paramname">rb</td><td>const doubleword pointer to an array of doubles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data stored at (ra + rb) is loaded into vector doubleword element 0. Element 1 is undefined. </dd></dl>

</div>
</div>
<a id="afd8eb9e570786d34728fa025d609f589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8eb9e570786d34728fa025d609f589">&#9670;&nbsp;</a></span>vec_vsstfddo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstfddo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Float Double to Doubleword Offsets. </p>
<p>For each doubleword element [i] of vra, Store the double element xs[i] at *(char*)array+vra[i].</p>
<dl class="section note"><dt>Note</dt><dd>As effective address calculation is modulo 64-bits, signed or unsigned doubleword offsets are equivalent.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">8 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector double elements to scatter store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of doubles. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword (64-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a098478cc68594e80cf3c0cec354a8d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098478cc68594e80cf3c0cec354a8d53">&#9670;&nbsp;</a></span>vec_vsstfddsx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstfddsx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Float Double to Doubleword Scaled Index. </p>
<p>For each doubleword element [i] of vra, store the double element xs[i] at array[vra[i] * (1 &lt;&lt; scale)]. Indexes are converted to offsets from *array by shifting each doubleword of vra left (3+scale) bits.</p>
<dl class="section note"><dt>Note</dt><dd>As effective address calculation is modulo 64-bits, signed or unsigned doubleword indexes are equivalent.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector double elements to store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of doubles. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword indexes. </td></tr>
    <tr><td class="paramname">scale</td><td>Factor effectually multiplying the indexes by 2<sup>scale</sup>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af20d0c1794f3a3e26423f74b60963783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20d0c1794f3a3e26423f74b60963783">&#9670;&nbsp;</a></span>vec_vsstfddx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstfddx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Float Double to Doubleword Indexes. </p>
<p>For each doubleword element [i] of vra, store the double element xs[i] at array[vra[i]]. Indexes are converted to offsets from *array by shifting each doubleword of vra left 3 bits.</p>
<dl class="section note"><dt>Note</dt><dd>As effective address calculation is modulo 64-bits, signed or unsigned doubleword indexes are equivalent.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector double elements to store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of doubles. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword indexes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac18796558bb5e508164d565daec3a6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18796558bb5e508164d565daec3a6d5">&#9670;&nbsp;</a></span>vec_vsstfdso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstfdso </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Float Double to Scalar Offsets. </p>
<p>For each doubleword element [i] of vra, Store the double element xs[i] at *(char*)array+offset[0|1].</p>
<dl class="section note"><dt>Note</dt><dd>As effective address calculation is modulo 64-bits, signed or unsigned doubleword offsets are equivalent.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">8 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector double elements to scatter store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of doubles. </td></tr>
    <tr><td class="paramname">offset0</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset1</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dd382753ae41ea181e88bb2672430e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd382753ae41ea181e88bb2672430e2">&#9670;&nbsp;</a></span>vec_vstxsfdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vstxsfdx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const signed long long&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Store Scalar Float Double Indexed. </p>
<p>Stores the left most doubleword of vector <b>xs</b> as a scalar double float at the effective address formed by <b>rb+ra</b>. The operand <b>rb</b> is a pointer to an array of doubles. The operand <b>ra</b> is a doubleword integer byte offset from <b>rb</b>. For best performance <b>rb</b> and <b>ra</b> should be doubleword aligned (integer multiple of 8).</p>
<p>This operation is an alternate form of vector store element, with the added simplification that data is always left justified in the vector. This simplifies scatter operations.</p>
<dl class="section note"><dt>Note</dt><dd>This is instruction was introduced in PowerISA 2.06 (POWER7). For POWER9 there are additional optimizations by effectively converting small constant index values into displacements. For POWER9 we can use the stxsd (DS-form) instruction directly.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">0 - 2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">0 - 2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>vector doubleword element 0 to be stored. </td></tr>
    <tr><td class="paramname">ra</td><td>const doubleword index (offset/displacement). </td></tr>
    <tr><td class="paramname">rb</td><td>const doubleword pointer to an array of doubles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4774a0cb9ea619f1d6cee6bb119088b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4774a0cb9ea619f1d6cee6bb119088b5">&#9670;&nbsp;</a></span>vec_xviexpdp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_xviexpdp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Insert Exponent Double-Precision. </p>
<p>For each doubleword of <b>sig</b> and <b>exp</b>, merge the sign (bit 0) and significand (bits 12:63) from <b>sig</b> with the 11-bit exponent from <b>exp</b> (bits 53:63). The exponent is merged into bits 1:11 of the final result. The result is returned as a Vector Double-Precision floating point value.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xviexpdp instruction and the built-in vec_insert_exp. These require a POWER9-enabled compiler targeting -mcpu=power9 and are not available for older compilers nor POWER8 and earlier. This function provides this operation for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-15 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Vector unsigned long long containing the Sign Bit and 52-bit significand. </td></tr>
    <tr><td class="paramname">exp</td><td>Vector unsigned long long containing the 11-bit exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vf64_t value where the exponent bits (1:11) of sig are replaced from bits 53:63 of exp. </dd></dl>

</div>
</div>
<a id="acb534c11a544d9e0b61acdecbb62adaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb534c11a544d9e0b61acdecbb62adaa">&#9670;&nbsp;</a></span>vec_xvxexpdp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xvxexpdp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Extract Exponent Double-Precision. </p>
<p>For each doubleword of <b>vrb</b>, Extract the double-precision exponent (bits 1:11) and right justify it to (bits 53:63 of) of the result vector doubleword. The result is returned as vector long long integer value.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xvxexpdp instruction and the built-in vec_extract_exp. These require a POWER9-enabled compiler targeting -mcpu=power9 and are not available for older compilers nor POWER8 and earlier. This function provides this operation for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-15 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vrb</td><td>vector double value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long long containing 11-bit exponent right justified in each doubleword </dd></dl>

</div>
</div>
<a id="af8b42004c11b01c7606d8d6e299e8107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b42004c11b01c7606d8d6e299e8107">&#9670;&nbsp;</a></span>vec_xvxsigdp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xvxsigdp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Extract Significand Double-Precision. </p>
<p>For each doubleword of <b>vrb</b>, Extract the double-precision significand (bits 12:63) and restore the implied (hidden) bit (bit 11) if the double-precision value is normal (not zero, subnormal, Infinity or NaN). The result is return as vector long long integer value with up to 53 bits of significance.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xvxsigdp instruction and the built-in vec_extract_sig. These require a POWER9-enabled compiler targeting -mcpu=power9 and are not available for older compilers nor POWER8 and earlier. This function provides this operation for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vrb</td><td>vector double value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long long containing the significand. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="avec__f64__ppc_8h_html_a9c198001c1db455c8a70478fe7c76c8c"><div class="ttname"><a href="vec__f64__ppc_8h.html#a9c198001c1db455c8a70478fe7c76c8c">vec_any_isnormalf64</a></div><div class="ttdeci">static int vec_any_isnormalf64(vf64_t vf64)</div><div class="ttdoc">Return true if any of 2x64-bit vector double values are normal (Not NaN, Inf, denormal,...</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:660</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_a0391d8549f3070e515c0f20ed6bea9ac"><div class="ttname"><a href="vec__f64__ppc_8h.html#a0391d8549f3070e515c0f20ed6bea9ac">vec_iszerof64</a></div><div class="ttdeci">static vb64_t vec_iszerof64(vf64_t vf64)</div><div class="ttdoc">Return 2x64-bit vector boolean true values, for each double value that is +-0.0.</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:1084</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a52a773b6353c69a546bdc2e8686a50ec"><div class="ttname"><a href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div><div class="ttdeci">__vector unsigned long long vui64_t</div><div class="ttdoc">vector of 64-bit unsigned long long elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:208</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_a5508cb768d48ffec6e833076fc10b497"><div class="ttname"><a href="vec__f64__ppc_8h.html#a5508cb768d48ffec6e833076fc10b497">vec_isinff64</a></div><div class="ttdeci">static vb64_t vec_isinff64(vf64_t vf64)</div><div class="ttdoc">Return 2x64-bit vector boolean true values for each double, if infinity.</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:901</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_aa5108dc5fc533329fdd794f306a6ec3d"><div class="ttname"><a href="vec__f64__ppc_8h.html#aa5108dc5fc533329fdd794f306a6ec3d">vec_any_isfinitef64</a></div><div class="ttdeci">static int vec_any_isfinitef64(vf64_t vf64)</div><div class="ttdoc">Return true if any of 2x64-bit vector double values are Finite (Not NaN nor Inf).</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:526</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_aee93592cb008b78c17e85d1eaa3419e1"><div class="ttname"><a href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a></div><div class="ttdeci">__vector __bool long long vb64_t</div><div class="ttdoc">vector of 64-bit bool long long elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:230</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_ae5cccc22e004bddbb80a51117c448675"><div class="ttname"><a href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a></div><div class="ttdeci">__vector double vf64_t</div><div class="ttdoc">vector of 64-bit double elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:221</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_aae0220385a453649170124948f9085f1"><div class="ttname"><a href="vec__f64__ppc_8h.html#aae0220385a453649170124948f9085f1">vec_isfinitef64</a></div><div class="ttdeci">static vb64_t vec_isfinitef64(vf64_t vf64)</div><div class="ttdoc">Return 2x64-bit vector boolean true values for each double element that is Finite (Not NaN nor Inf).</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:857</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_a8f764b415ce41cbbc504554f779bcbe6"><div class="ttname"><a href="vec__f64__ppc_8h.html#a8f764b415ce41cbbc504554f779bcbe6">vec_isnormalf64</a></div><div class="ttdeci">static vb64_t vec_isnormalf64(vf64_t vf64)</div><div class="ttdoc">Return 2x64-bit vector boolean true values, for each double value, if normal (Not NaN,...</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:990</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 10 2022 14:57:44 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
