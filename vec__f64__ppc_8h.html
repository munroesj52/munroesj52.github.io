<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>POWER Vector Library Manual: src/vec_f64_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_f64_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over 64-bit double floating point elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__common__ppc_8h_source.html">vec_common_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__int64__ppc_8h_source.html">vec_int64_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__f64__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8b03cddf29e839c554da86dd95d270ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b03cddf29e839c554da86dd95d270ad"></a>
typedef __vector double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a8b03cddf29e839c554da86dd95d270ad">__vbinary64</a></td></tr>
<tr class="memdesc:a8b03cddf29e839c554da86dd95d270ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 64-bit binary64 elements. Same as vector double for PPC. <br /></td></tr>
<tr class="separator:a8b03cddf29e839c554da86dd95d270ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac396fe321d73f75b57ebab8c365e20f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ac396fe321d73f75b57ebab8c365e20f3">vec_unpack_longdouble</a> (long double lval)</td></tr>
<tr class="memdesc:ac396fe321d73f75b57ebab8c365e20f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the pair of doubles from a IBM long double to a vector double.  <a href="#ac396fe321d73f75b57ebab8c365e20f3">More...</a><br /></td></tr>
<tr class="separator:ac396fe321d73f75b57ebab8c365e20f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd670e9d3dd600198336708bb71fe77"><td class="memItemLeft" align="right" valign="top">static long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#aabd670e9d3dd600198336708bb71fe77">vec_pack_longdouble</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> lval)</td></tr>
<tr class="memdesc:aabd670e9d3dd600198336708bb71fe77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the pair of doubles from a vector to IBM long double.  <a href="#aabd670e9d3dd600198336708bb71fe77">More...</a><br /></td></tr>
<tr class="separator:aabd670e9d3dd600198336708bb71fe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56ccacba6a3b48a7a920c7d5b0fe30e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ab56ccacba6a3b48a7a920c7d5b0fe30e">vec_absf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64x)</td></tr>
<tr class="memdesc:ab56ccacba6a3b48a7a920c7d5b0fe30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector double absolute value.  <a href="#ab56ccacba6a3b48a7a920c7d5b0fe30e">More...</a><br /></td></tr>
<tr class="separator:ab56ccacba6a3b48a7a920c7d5b0fe30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f2bf6308d932b9604dbd8c5f8e90da"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ac8f2bf6308d932b9604dbd8c5f8e90da">vec_all_isinff64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:ac8f2bf6308d932b9604dbd8c5f8e90da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 2x64-bit vector double values are infinity.  <a href="#ac8f2bf6308d932b9604dbd8c5f8e90da">More...</a><br /></td></tr>
<tr class="separator:ac8f2bf6308d932b9604dbd8c5f8e90da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b54640bbaa0ad0921680fe69a66246b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a3b54640bbaa0ad0921680fe69a66246b">vec_all_isnanf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a3b54640bbaa0ad0921680fe69a66246b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 2x64-bit vector double values are NaN.  <a href="#a3b54640bbaa0ad0921680fe69a66246b">More...</a><br /></td></tr>
<tr class="separator:a3b54640bbaa0ad0921680fe69a66246b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63ac21e968bf199eadd72f94b653905"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ab63ac21e968bf199eadd72f94b653905">vec_all_isnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:ab63ac21e968bf199eadd72f94b653905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 2x64-bit vector double values are normal (Not NaN, Inf, denormal, or zero).  <a href="#ab63ac21e968bf199eadd72f94b653905">More...</a><br /></td></tr>
<tr class="separator:ab63ac21e968bf199eadd72f94b653905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b6b22fcc171729b47878782f823ab4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ad0b6b22fcc171729b47878782f823ab4">vec_all_issubnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:ad0b6b22fcc171729b47878782f823ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 2x64-bit vector double values are subnormal (denormal).  <a href="#ad0b6b22fcc171729b47878782f823ab4">More...</a><br /></td></tr>
<tr class="separator:ad0b6b22fcc171729b47878782f823ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27becc842e7270c96c54a00d4a292d54"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a27becc842e7270c96c54a00d4a292d54">vec_all_iszerof64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a27becc842e7270c96c54a00d4a292d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 2x64-bit vector double values are +-0.0.  <a href="#a27becc842e7270c96c54a00d4a292d54">More...</a><br /></td></tr>
<tr class="separator:a27becc842e7270c96c54a00d4a292d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71abdbd1fd938daa250682ef9bbc5e84"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a71abdbd1fd938daa250682ef9bbc5e84">vec_any_isinff64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a71abdbd1fd938daa250682ef9bbc5e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 2x64-bit vector double values are infinity.  <a href="#a71abdbd1fd938daa250682ef9bbc5e84">More...</a><br /></td></tr>
<tr class="separator:a71abdbd1fd938daa250682ef9bbc5e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78d13a9a604d48250a0aecba84ce8f2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#ad78d13a9a604d48250a0aecba84ce8f2">vec_any_isnanf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:ad78d13a9a604d48250a0aecba84ce8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 2x64-bit vector double values are NaN.  <a href="#ad78d13a9a604d48250a0aecba84ce8f2">More...</a><br /></td></tr>
<tr class="separator:ad78d13a9a604d48250a0aecba84ce8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c198001c1db455c8a70478fe7c76c8c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a9c198001c1db455c8a70478fe7c76c8c">vec_any_isnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a9c198001c1db455c8a70478fe7c76c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 2x64-bit vector double values are normal (Not NaN, Inf, denormal, or zero).  <a href="#a9c198001c1db455c8a70478fe7c76c8c">More...</a><br /></td></tr>
<tr class="separator:a9c198001c1db455c8a70478fe7c76c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96007b688d4c2c6aed732ec1b04a78de"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a96007b688d4c2c6aed732ec1b04a78de">vec_any_issubnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a96007b688d4c2c6aed732ec1b04a78de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 2x64-bit vector double values is subnormal (denormal).  <a href="#a96007b688d4c2c6aed732ec1b04a78de">More...</a><br /></td></tr>
<tr class="separator:a96007b688d4c2c6aed732ec1b04a78de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c593b367639924729e7d8fbb044f0e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a47c593b367639924729e7d8fbb044f0e">vec_any_iszerof64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a47c593b367639924729e7d8fbb044f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 2x64-bit vector double values are +-0.0.  <a href="#a47c593b367639924729e7d8fbb044f0e">More...</a><br /></td></tr>
<tr class="separator:a47c593b367639924729e7d8fbb044f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d567f31837de74d7fa722b59e73928"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a59d567f31837de74d7fa722b59e73928">vec_copysignf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64x, <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64y)</td></tr>
<tr class="memdesc:a59d567f31837de74d7fa722b59e73928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign bit from vf64y merged with magnitude from vf64x and return the resulting vector double values.  <a href="#a59d567f31837de74d7fa722b59e73928">More...</a><br /></td></tr>
<tr class="separator:a59d567f31837de74d7fa722b59e73928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5508cb768d48ffec6e833076fc10b497"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a5508cb768d48ffec6e833076fc10b497">vec_isinff64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a5508cb768d48ffec6e833076fc10b497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2x64-bit vector boolean true values for each double, if infinity.  <a href="#a5508cb768d48ffec6e833076fc10b497">More...</a><br /></td></tr>
<tr class="separator:a5508cb768d48ffec6e833076fc10b497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131162bc90efca47ad3e5513d73c3350"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a131162bc90efca47ad3e5513d73c3350">vec_isnanf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a131162bc90efca47ad3e5513d73c3350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2x64-bit vector boolean true values, for each double NaN value.  <a href="#a131162bc90efca47ad3e5513d73c3350">More...</a><br /></td></tr>
<tr class="separator:a131162bc90efca47ad3e5513d73c3350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f764b415ce41cbbc504554f779bcbe6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a8f764b415ce41cbbc504554f779bcbe6">vec_isnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a8f764b415ce41cbbc504554f779bcbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2x64-bit vector boolean true values, for each double value, if normal (Not NaN, Inf, denormal, or zero).  <a href="#a8f764b415ce41cbbc504554f779bcbe6">More...</a><br /></td></tr>
<tr class="separator:a8f764b415ce41cbbc504554f779bcbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec48e60f9252ceb1d82ecb76cbce08a8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#aec48e60f9252ceb1d82ecb76cbce08a8">vec_issubnormalf64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:aec48e60f9252ceb1d82ecb76cbce08a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2x64-bit vector boolean true values, for each double value that is subnormal (denormal).  <a href="#aec48e60f9252ceb1d82ecb76cbce08a8">More...</a><br /></td></tr>
<tr class="separator:aec48e60f9252ceb1d82ecb76cbce08a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0391d8549f3070e515c0f20ed6bea9ac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f64__ppc_8h.html#a0391d8549f3070e515c0f20ed6bea9ac">vec_iszerof64</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vf64)</td></tr>
<tr class="memdesc:a0391d8549f3070e515c0f20ed6bea9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2x64-bit vector boolean true values, for each double value that is +-0.0.  <a href="#a0391d8549f3070e515c0f20ed6bea9ac">More...</a><br /></td></tr>
<tr class="separator:a0391d8549f3070e515c0f20ed6bea9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over 64-bit double floating point elements. </p>
<p>Most vector double (64-bit float) operations are implemented with PowerISA-2.06 (POWER7 and later) VSX instructions. Most of these operations (compiler built-ins, or intrinsics) are defined in &lt;altivec.h&gt; and described in the <a href="https://gcc.gnu.org/onlinedocs/">compiler documentation</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power7</b>, most of the doubleword integer add, subtract, and compare operations useful for floating point classification are not defined. This header provides the appropriate substitutions, will generate the minimum code, appropriate for the target, and produce correct results.</dd>
<dd>
Most ppc64le compilers will default to -mcpu=power8 if not specified.</dd></dl>
<p>Most of these operations are implemented in a few instructions on newer (POWER8/POWER9) processors. This header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides an inline assembler implementation for older compilers that do not provide the built-ins.</p>
<p>This header covers operations that are any of the following:</p>
<ul>
<li>Implemented in hardware instructions in newer processors, but useful to programmers on slightly older processors (even if the equivalent function requires more instructions).</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.h&gt; provided by available compilers in common use. Examples include vector double even/odd.</li>
<li>Providing special vector float tests for special conditions without generating extraneous floating-point exceptions. This is important for implementing vectorized forms of ISO C99 Math functions. Examples include vector isnan, isinf, etc.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious. See example ISO C99 functions above.</li>
</ul>
<h1><a class="anchor" id="f64_perf_0_0"></a>
Performance data.</h1>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab56ccacba6a3b48a7a920c7d5b0fe30e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_absf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector double absolute value. </p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64x</td><td>vector double values containing the magnitudes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector double absolute values of vf64x. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8f2bf6308d932b9604dbd8c5f8e90da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isinff64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 2x64-bit vector double values are infinity. </p>
<p>A IEEE Binary64 infinity has a exponent of 0x7ff and significand of all zeros. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-20 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int, true if all 2 double values are infinity </dd></dl>

</div>
</div>
<a class="anchor" id="a3b54640bbaa0ad0921680fe69a66246b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnanf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 2x64-bit vector double values are NaN. </p>
<p>A IEEE Binary64 NaN value has an exponent between 0x7ff and the significand is nonzero. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-20 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all 2 vector double values are NaN. </dd></dl>

</div>
</div>
<a class="anchor" id="ab63ac21e968bf199eadd72f94b653905"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 2x64-bit vector double values are normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary64 normal value has an exponent between 0x001 and 0x7fe (a 0x7ff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-28 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8-16 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all 2 vector double values are normal. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0b6b22fcc171729b47878782f823ab4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_issubnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 2x64-bit vector double values are subnormal (denormal). </p>
<p>A IEEE Binary64 subnormal has an exponent of 0x000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-30 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-19 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all of 2 vector double values are subnormal. </dd></dl>

</div>
</div>
<a class="anchor" id="a27becc842e7270c96c54a00d4a292d54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_iszerof64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 2x64-bit vector double values are +-0.0. </p>
<p>A IEEE Binary64 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-20 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all 2 vector double values are +/- zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a71abdbd1fd938daa250682ef9bbc5e84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_isinff64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 2x64-bit vector double values are infinity. </p>
<p>A IEEE Binary64 infinity has a exponent of 0x7ff and significand of all zeros.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-20 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int, true if any of 2 double values are infinity </dd></dl>

</div>
</div>
<a class="anchor" id="ad78d13a9a604d48250a0aecba84ce8f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_isnanf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 2x64-bit vector double values are NaN. </p>
<p>A IEEE Binary64 NaN value has an exponent between 0x7ff and the significand is nonzero. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-20 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if any of 2 vector double values are NaN. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c198001c1db455c8a70478fe7c76c8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_isnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 2x64-bit vector double values are normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary64 normal value has an exponent between 0x001 and 0x7fe (a 0x7ff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-25 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-19 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if any of 2 vector double values are normal. </dd></dl>

</div>
</div>
<a class="anchor" id="a96007b688d4c2c6aed732ec1b04a78de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_issubnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 2x64-bit vector double values is subnormal (denormal). </p>
<p>A IEEE Binary64 subnormal has an exponent of 0x000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-18 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any of 2 vector double values are subnormal. </dd></dl>

</div>
</div>
<a class="anchor" id="a47c593b367639924729e7d8fbb044f0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_iszerof64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 2x64-bit vector double values are +-0.0. </p>
<p>A IEEE Binary64 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-20 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if any of 2 vector double values are +/- zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a59d567f31837de74d7fa722b59e73928"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_copysignf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the sign bit from vf64y merged with magnitude from vf64x and return the resulting vector double values. </p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64x</td><td>vector double values containing the magnitudes. </td></tr>
    <tr><td class="paramname">vf64y</td><td>vector double values containing the sign bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector double values with magnitude from vf64x and the sign of vf64y. </dd></dl>

</div>
</div>
<a class="anchor" id="a5508cb768d48ffec6e833076fc10b497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_isinff64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2x64-bit vector boolean true values for each double, if infinity. </p>
<p>A IEEE Binary64 infinity has a exponent of 0x7ff and significand of all zeros.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a class="anchor" id="a131162bc90efca47ad3e5513d73c3350"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_isnanf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2x64-bit vector boolean true values, for each double NaN value. </p>
<p>A IEEE Binary64 NaN value has an exponent between 0x7ff and the significand is nonzero. The sign bit is ignored.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a class="anchor" id="a8f764b415ce41cbbc504554f779bcbe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_isnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2x64-bit vector boolean true values, for each double value, if normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary64 normal value has an exponent between 0x001 and 0x7ffe (a 0x7ff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero).</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-16 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7-16 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a class="anchor" id="aec48e60f9252ceb1d82ecb76cbce08a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_issubnormalf64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2x64-bit vector boolean true values, for each double value that is subnormal (denormal). </p>
<p>A IEEE Binary64 subnormal has an exponent of 0x000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-16 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7-16 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a class="anchor" id="a0391d8549f3070e515c0f20ed6bea9ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_iszerof64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>vf64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2x64-bit vector boolean true values, for each double value that is +-0.0. </p>
<p>A IEEE Binary64 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal double compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf64</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a class="anchor" id="aabd670e9d3dd600198336708bb71fe77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long double vec_pack_longdouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>lval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the pair of doubles from a vector to IBM long double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lval</td><td>vector double values containing the IBM long double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IBM long double as FPR pair. </dd></dl>

</div>
</div>
<a class="anchor" id="ac396fe321d73f75b57ebab8c365e20f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_unpack_longdouble </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>lval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the pair of doubles from a IBM long double to a vector double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lval</td><td>IBM long double as FPR pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector double values containing the IBM long double. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 24 2018 16:23:30 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
