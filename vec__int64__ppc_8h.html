<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>POWER Vector Library Manual: src/vec_int64_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_int64_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over 64-bit integer elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__int32__ppc_8h_source.html">vec_int32_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__int64__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a28052c1907d1f733c9dda8a48039e546"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a28052c1907d1f733c9dda8a48039e546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Add Unsigned Doubleword Modulo.  <a href="#a28052c1907d1f733c9dda8a48039e546">More...</a><br /></td></tr>
<tr class="separator:a28052c1907d1f733c9dda8a48039e546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cdec54548bd95e04d4835d96b1bea4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra)</td></tr>
<tr class="memdesc:a03cdec54548bd95e04d4835d96b1bea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count leading zeros for a vector unsigned long int.  <a href="#a03cdec54548bd95e04d4835d96b1bea4">More...</a><br /></td></tr>
<tr class="separator:a03cdec54548bd95e04d4835d96b1bea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1747cf67ba84f834ec822c2a9dd39f63"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a1747cf67ba84f834ec822c2a9dd39f63">vec_cmpequd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a1747cf67ba84f834ec822c2a9dd39f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal Unsigned Doubleword.  <a href="#a1747cf67ba84f834ec822c2a9dd39f63">More...</a><br /></td></tr>
<tr class="separator:a1747cf67ba84f834ec822c2a9dd39f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7660b170e71ec58ee95a79cd1c47d5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a8a7660b170e71ec58ee95a79cd1c47d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Equal Unsigned Doubleword.  <a href="#a8a7660b170e71ec58ee95a79cd1c47d5">More...</a><br /></td></tr>
<tr class="separator:a8a7660b170e71ec58ee95a79cd1c47d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f0c61aabb7f325f3ce287d833d56be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#ae6f0c61aabb7f325f3ce287d833d56be">vec_cmpgtud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:ae6f0c61aabb7f325f3ce287d833d56be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than Unsigned Doubleword.  <a href="#ae6f0c61aabb7f325f3ce287d833d56be">More...</a><br /></td></tr>
<tr class="separator:ae6f0c61aabb7f325f3ce287d833d56be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f43c88ffe8c0cad11b901fa6fc2598"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a77f43c88ffe8c0cad11b901fa6fc2598">vec_cmpud_any_gt</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a77f43c88ffe8c0cad11b901fa6fc2598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than Unsigned Doubleword.  <a href="#a77f43c88ffe8c0cad11b901fa6fc2598">More...</a><br /></td></tr>
<tr class="separator:a77f43c88ffe8c0cad11b901fa6fc2598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13f19199e5872ecaf88742043f26642"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#af13f19199e5872ecaf88742043f26642">vec_cmpud_all_gt</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:af13f19199e5872ecaf88742043f26642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than Unsigned Doubleword.  <a href="#af13f19199e5872ecaf88742043f26642">More...</a><br /></td></tr>
<tr class="separator:af13f19199e5872ecaf88742043f26642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8443f766b5cf219e2f5be05cfd6bb52"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#ae8443f766b5cf219e2f5be05cfd6bb52">vec_cmpleud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:ae8443f766b5cf219e2f5be05cfd6bb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than Equal Unsigned Doubleword.  <a href="#ae8443f766b5cf219e2f5be05cfd6bb52">More...</a><br /></td></tr>
<tr class="separator:ae8443f766b5cf219e2f5be05cfd6bb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871f91423e5154739ae225c82620d6b4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a871f91423e5154739ae225c82620d6b4">vec_cmpud_all_le</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a871f91423e5154739ae225c82620d6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less than equal Unsigned Doubleword.  <a href="#a871f91423e5154739ae225c82620d6b4">More...</a><br /></td></tr>
<tr class="separator:a871f91423e5154739ae225c82620d6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8238ba590103ac80fb146a6a2b1aed1c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a8238ba590103ac80fb146a6a2b1aed1c">vec_permdi</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb, const int ctl)</td></tr>
<tr class="memdesc:a8238ba590103ac80fb146a6a2b1aed1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Permute Doubleword Immediate. Combine a doubleword selected from the 1st (vra) vector with a doubleword selected from the 2nd (vrb) vector. The 2-bit control operand (ctl) selects which doubleword from the 1st and 2nd vector operands are transfered to the result vector.  <a href="#a8238ba590103ac80fb146a6a2b1aed1c">More...</a><br /></td></tr>
<tr class="separator:a8238ba590103ac80fb146a6a2b1aed1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cebc174283a4069f1f8bca5ddc5b518"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a4cebc174283a4069f1f8bca5ddc5b518">vec_mrghd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VA, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VB)</td></tr>
<tr class="memdesc:a4cebc174283a4069f1f8bca5ddc5b518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge High Doubleword. Merge the high doubleword elements from two vectors into the high and low doubleword elements of the result.  <a href="#a4cebc174283a4069f1f8bca5ddc5b518">More...</a><br /></td></tr>
<tr class="separator:a4cebc174283a4069f1f8bca5ddc5b518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100acbe58743381f32d5c068959668b7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a100acbe58743381f32d5c068959668b7">vec_mrgld</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VA, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VB)</td></tr>
<tr class="memdesc:a100acbe58743381f32d5c068959668b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Low Doubleword. Merge the low doubleword elements from two vectors into the high and low doubleword elements of the result.  <a href="#a100acbe58743381f32d5c068959668b7">More...</a><br /></td></tr>
<tr class="separator:a100acbe58743381f32d5c068959668b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53159a600aba803503ae6ddcb539a123"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a53159a600aba803503ae6ddcb539a123">vec_pasted</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VH, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VL)</td></tr>
<tr class="memdesc:a53159a600aba803503ae6ddcb539a123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector doubleword paste. Concatenate the high doubleword of the 1st vector with the low double word of the 2nd vector.  <a href="#a53159a600aba803503ae6ddcb539a123">More...</a><br /></td></tr>
<tr class="separator:a53159a600aba803503ae6ddcb539a123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db4e91aa49c03fbb4a8da5a174c7b07"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a0db4e91aa49c03fbb4a8da5a174c7b07">vec_popcntd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra)</td></tr>
<tr class="memdesc:a0db4e91aa49c03fbb4a8da5a174c7b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Population Count doubleword.  <a href="#a0db4e91aa49c03fbb4a8da5a174c7b07">More...</a><br /></td></tr>
<tr class="separator:a0db4e91aa49c03fbb4a8da5a174c7b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4af62c6235b7b47daea6f00cd8ea33a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#ae4af62c6235b7b47daea6f00cd8ea33a">vec_revbd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra)</td></tr>
<tr class="memdesc:ae4af62c6235b7b47daea6f00cd8ea33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte reverse each doubleword for a vector unsigned long int.  <a href="#ae4af62c6235b7b47daea6f00cd8ea33a">More...</a><br /></td></tr>
<tr class="separator:ae4af62c6235b7b47daea6f00cd8ea33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb3ddc8b334ae25119a02e749884290"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a0fb3ddc8b334ae25119a02e749884290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Left Doubleword.  <a href="#a0fb3ddc8b334ae25119a02e749884290">More...</a><br /></td></tr>
<tr class="separator:a0fb3ddc8b334ae25119a02e749884290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e352b9d7cc7cdb597a14ddb0933387"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a89e352b9d7cc7cdb597a14ddb0933387">vec_vsrd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a89e352b9d7cc7cdb597a14ddb0933387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Doubleword.  <a href="#a89e352b9d7cc7cdb597a14ddb0933387">More...</a><br /></td></tr>
<tr class="separator:a89e352b9d7cc7cdb597a14ddb0933387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517f21d7f771077a51f26718311ca64e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a517f21d7f771077a51f26718311ca64e">vec_vsrad</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a517f21d7f771077a51f26718311ca64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Algebraic Doubleword.  <a href="#a517f21d7f771077a51f26718311ca64e">More...</a><br /></td></tr>
<tr class="separator:a517f21d7f771077a51f26718311ca64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aee7d73450e9b7008af0428030f1028"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a6aee7d73450e9b7008af0428030f1028">vec_sldi</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a6aee7d73450e9b7008af0428030f1028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift left Doubleword Immediate.  <a href="#a6aee7d73450e9b7008af0428030f1028">More...</a><br /></td></tr>
<tr class="separator:a6aee7d73450e9b7008af0428030f1028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd0665fb16981d85c7f948c0578f928"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a9cd0665fb16981d85c7f948c0578f928">vec_spltd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, const int ctl)</td></tr>
<tr class="memdesc:a9cd0665fb16981d85c7f948c0578f928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of the result.  <a href="#a9cd0665fb16981d85c7f948c0578f928">More...</a><br /></td></tr>
<tr class="separator:a9cd0665fb16981d85c7f948c0578f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be336316770fa12d116c7e82427d2fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a1be336316770fa12d116c7e82427d2fd">vec_srdi</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a1be336316770fa12d116c7e82427d2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Doubleword Immediate.  <a href="#a1be336316770fa12d116c7e82427d2fd">More...</a><br /></td></tr>
<tr class="separator:a1be336316770fa12d116c7e82427d2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6058f691cf57976e30f0294a183d2715"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a6058f691cf57976e30f0294a183d2715">vec_sradi</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a6058f691cf57976e30f0294a183d2715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Algebraic Doubleword Immediate.  <a href="#a6058f691cf57976e30f0294a183d2715">More...</a><br /></td></tr>
<tr class="separator:a6058f691cf57976e30f0294a183d2715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7aee3c81538f5537680b610d934500"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a0b7aee3c81538f5537680b610d934500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Subtract Unsigned Doubleword Modulo.  <a href="#a0b7aee3c81538f5537680b610d934500">More...</a><br /></td></tr>
<tr class="separator:a0b7aee3c81538f5537680b610d934500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d2b39711c06106097ef869a20420b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a42d2b39711c06106097ef869a20420b6">vec_swapd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra)</td></tr>
<tr class="memdesc:a42d2b39711c06106097ef869a20420b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector doubleword swap. Exchange the high and low doubleword elements of a vector.  <a href="#a42d2b39711c06106097ef869a20420b6">More...</a><br /></td></tr>
<tr class="separator:a42d2b39711c06106097ef869a20420b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over 64-bit integer elements. </p>
<p>The original VMX (AKA Altivec) did not define any doubleword element (long long integer or double float) operations. The VSX facility (introduced with POWER7) added vector double float but did not add any integer doubleword (64-bit) operations. However it did add a useful doubleword permute immediate and word wise; merge, shift, and splat immediate operations. Otherwise vector long int (64-bit elements) operations have to be implemented using VMX word and halfword element integer operations for POWER7.</p>
<p>POWER8 (PowerISA 2.07B) adds important doubleword integer (add, subtract, compare, shift, rotate, ...) VMX operations. POWER8 also added multiply word operations that produce the full doubleword product and full quadword add / subtract (with carry extend).</p>
<p>POWER9 (PowerISA 3.0B) adds the <b>Vector Multiply-Sum Unsigned Doubleword Modulo</b> instruction. This is not the expected multiply even/odd/modulo doubleword nor a full multiply modulo quadword. But with a few extra (permutes and splat zero) instructions you can get equivalent function.</p>
<p>Most of these intrinsic (compiler built-in) operations are defined in &lt;altivec.h&gt; and described in the compiler documentation.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power7</b>, vec_vclz and vec_vclzd will not be defined. But vec_clzd is always defined in this header, will generate the minimum code, appropriate for the target, and produce correct results.</dd></dl>
<p>Most of these operations are implemented in a single instruction on newer (POWER8/POWER9) processors. So this header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides a in-line assembler implementation for older compilers that do not provide the build-ins.</p>
<p>This header covers operations that are either:</p>
<ul>
<li>Implemented in hardware instructions for later processors and useful to programmers, on slightly older processors, even if the equivalent function requires more instructions. Examples include the multiply even/odd/modulo word operations.</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.n&gt; provided by available compilers in common use. Examples include Count Leading Zeros, Population Count and Byte Reverse.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious. Examples include the shift immediate operations.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The Multiply even/odd doubleword operations are currently implemented in &lt;<a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>&gt; which resolves a dependency on Add Quadword. These functions (vec_msumudm, vec_muleud, vec_muloud) all produce a quadword results and need vec_adduqm to sum partial products on earlier Power platforms. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm</a>, <a class="el" href="vec__int128__ppc_8h.html#a26f95e02f7b0551e3f2bb7e4b4da040d" title="Vector multiply even unsigned doublewords. ">vec_muleud</a>, <a class="el" href="vec__int128__ppc_8h.html#aa989582cbfaa7984f78a937225e92f4a" title="Vector multiply odd unsigned doublewords. ">vec_muloud</a>, and <a class="el" href="vec__int128__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm</a> </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a28052c1907d1f733c9dda8a48039e546"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_addudm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Add Unsigned Doubleword Modulo. </p>
<p>Add two vector long int values and return modulo 64-bits result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector long int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector long int sums of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="a03cdec54548bd95e04d4835d96b1bea4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_clzd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count leading zeros for a vector unsigned long int. </p>
<p>Count leading zeros for a vector __int128 and return the count in a vector suitable for use with vector shift (left|right) and vector shift (left|right) by octet instructions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated a __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector with bits 121:127 containing the count of leading zeros. </dd></dl>

</div>
</div>
<a class="anchor" id="a1747cf67ba84f834ec822c2a9dd39f63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_cmpequd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return all '1's, if a[i] == b[i], otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Population Count DoubleWord (<b>vcmpequd</b>) instruction. Otherwise use boolean logic using word compares.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare equal result for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6f0c61aabb7f325f3ce287d833d56be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_cmpgtud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return all '1's, if a[i] &gt; b[i], otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Population Count DoubleWord (<b>vcmpgtud</b>) instruction. Otherwise use boolean logic using word compares.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare greater result for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8443f766b5cf219e2f5be05cfd6bb52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_cmpleud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return all '1's, if a[i] &gt; b[i], otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Population Count DoubleWord (<b>vcmpgtud</b>) instruction. Otherwise use boolean logic using word compares.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare greater result for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a7660b170e71ec58ee95a79cd1c47d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_all_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if all elements of a and b are equal.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the vec_all_eq built-in predicate directly. Otherwise cast to unsigned word and use the same predicate generating (<b>vcmpequw</b>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af13f19199e5872ecaf88742043f26642"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_all_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if all elements of a &gt; b.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the vec_all_eq built-in predicate directly. Otherwise cast to unsigned word and use the same predicate generating (<b>vcmpequw</b>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a871f91423e5154739ae225c82620d6b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_all_le </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less than equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if all elements of a &gt; b.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the vec_all_eq built-in predicate directly. Otherwise cast to unsigned word and use the same predicate generating (<b>vcmpequw</b>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a77f43c88ffe8c0cad11b901fa6fc2598"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_any_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if all elements of a &gt; b.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the vec_all_eq built-in predicate directly. Otherwise case to unsigned word and use the same predicate generating (<b>vcmpequw</b>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4cebc174283a4069f1f8bca5ddc5b518"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mrghd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge High Doubleword. Merge the high doubleword elements from two vectors into the high and low doubleword elements of the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__VA</td><td>a 128-bit vector as the source of the high order doubleword. </td></tr>
    <tr><td class="paramname">__VB</td><td>a 128-bit vector as the source of the low order doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original vector with the doubleword elements swapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a100acbe58743381f32d5c068959668b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mrgld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Low Doubleword. Merge the low doubleword elements from two vectors into the high and low doubleword elements of the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__VA</td><td>a 128-bit vector as the source of the high order doubleword. </td></tr>
    <tr><td class="paramname">__VB</td><td>a 128-bit vector as the source of the low order doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original vector with the doubleword elements swapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a53159a600aba803503ae6ddcb539a123"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_pasted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector doubleword paste. Concatenate the high doubleword of the 1st vector with the low double word of the 2nd vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__VH</td><td>a 128-bit vector as the source of the high order doubleword. </td></tr>
    <tr><td class="paramname">__VL</td><td>a 128-bit vector as the source of the low order doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined 128-bit vector composed of the high order doubleword of __VH and the low order doubleword of __VL. </dd></dl>

</div>
</div>
<a class="anchor" id="a8238ba590103ac80fb146a6a2b1aed1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_permdi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ctl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Permute Doubleword Immediate. Combine a doubleword selected from the 1st (vra) vector with a doubleword selected from the 2nd (vrb) vector. The 2-bit control operand (ctl) selects which doubleword from the 1st and 2nd vector operands are transfered to the result vector. </p>
<table class="doxtable">
<tr>
<th align="center">ctl </th><th align="center">vrt[0:63] </th><th align="center">vrt[64:127]  </th></tr>
<tr>
<td align="center">0 </td><td align="center">vra[0:63] </td><td align="center">vrb[0:63] </td></tr>
<tr>
<td align="center">1 </td><td align="center">vra[0:63] </td><td align="center">vrb[64:127] </td></tr>
<tr>
<td align="center">2 </td><td align="center">vra[64:127] </td><td align="center">vrb[0:63] </td></tr>
<tr>
<td align="center">3 </td><td align="center">vra[64:127] </td><td align="center">vrb[64:127] </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector as the source of the high order doubleword of the result. </td></tr>
    <tr><td class="paramname">vrb</td><td>a 128-bit vector as the source of the low order doubleword of the result. </td></tr>
    <tr><td class="paramname">ctl</td><td>const integer where the low order 2 bits control the selection of doublewords from input vector vra and vrb. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined 128-bit vector composed of the high order doubleword of vra and the low order doubleword of vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="a0db4e91aa49c03fbb4a8da5a174c7b07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_popcntd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Population Count doubleword. </p>
<p>Count the number of '1' bits (0-64) within each doubleword element of a 128-bit vector.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Population Count DoubleWord (<b>vpopcntd</b>) instruction. Otherwise use the pveclib vec_popcntw to count each word then sum across with Vector Sum across Half Signed Word Saturate (<b>vsum2sws</b>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 2 x 64-bit integer (dwords) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the population count for each dword element. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4af62c6235b7b47daea6f00cd8ea33a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_revbd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>byte reverse each doubleword for a vector unsigned long int. </p>
<p>For each doubleword of the input vector, reverse the order of bytes / octets within the doubleword.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector unsigned long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector with the bytes of each doubleword reversed. </dd></dl>

</div>
</div>
<a class="anchor" id="a6aee7d73450e9b7008af0428030f1028"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_sldi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift left Doubleword Immediate. </p>
<p>Shift left each doubleword element [0-1], 0-63 bits, as specified by an immediate value. The shift amount is a const unsigned long int in the range 0-63. A shift count of 0 returns the original value of vra. Shift counts greater then 63 bits return zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned long int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-63. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned long int, shifted left shb bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cd0665fb16981d85c7f948c0578f928"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_spltd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ctl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of the result. </p>
<table class="doxtable">
<tr>
<th align="center">ctl </th><th align="center">vrt[0:63] </th><th align="center">vrt[64:127]  </th></tr>
<tr>
<td align="center">0 </td><td align="center">vra[0:63] </td><td align="center">vra[0:63] </td></tr>
<tr>
<td align="center">1 </td><td align="center">vra[64:127] </td><td align="center">vra[64:127] </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector. </td></tr>
    <tr><td class="paramname">ctl</td><td>a const integer encoding the source doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original vector with the doubleword elements swapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a6058f691cf57976e30f0294a183d2715"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_sradi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Algebraic Doubleword Immediate. </p>
<p>Shift Right Algebraic each doubleword element [0-1], 0-63 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-63. A shift count of 0 returns the original value of vra. Shift counts greater then 63 bits return the sign bit propagated to each bit of each element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector signed long int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-63. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector signed long int, shifted right shb bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a1be336316770fa12d116c7e82427d2fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_srdi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Doubleword Immediate. </p>
<p>Shift Right each doubleword element [0-1], 0-63 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-63. A shift count of 0 returns the original value of vra. Shift counts greater then 63 bits return zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned long int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-63. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned long int, shifted right shb bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b7aee3c81538f5537680b610d934500"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_subudm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Subtract Unsigned Doubleword Modulo. </p>
<p>For each unsigned long (64-bit) integer element c[i] = a[i] + NOT(b[i]) + 1.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Subtract Unsigned Doubleword Modulo (<b>vsubudm</b>) instruction. Otherwise use vector add word modulo forms and propagate the carry bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 X unsigned long int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 X unsigned long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long int sum of a[0] + NOT(b[0]) + 1 and a[1] + NOT(b[1]) + 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a42d2b39711c06106097ef869a20420b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_swapd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector doubleword swap. Exchange the high and low doubleword elements of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original vector with the doubleword elements swapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a0fb3ddc8b334ae25119a02e749884290"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vsld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Left Doubleword. </p>
<p>Vector Shift Left Doubleword 0-63 bits. The shift amount is from bits 58-63 and 122-127 of vrb.</p>
<dl class="section note"><dt>Note</dt><dd>Can not use vec_sld naming here as that would conflict with the generic Shift Left Double Vector. Use vec_vsld but only if the compiler does not define it in &lt;altivec.h&gt;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 2 x unsigned long integers. </td></tr>
    <tr><td class="paramname">vrb</td><td>shift amount in bits 58:63 and 122:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Left shifted vector unsigned long. </dd></dl>

</div>
</div>
<a class="anchor" id="a517f21d7f771077a51f26718311ca64e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_vsrad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Algebraic Doubleword. </p>
<p>Vector Shift Right Algebraic Doubleword 0-63 bits. The shift amount is from bits 58-63 and 122-127 of vrb.</p>
<dl class="section note"><dt>Note</dt><dd>Use the vec_vsrad for consistency with vec_vsld above. Define vec_vsrad only if the compiler does not define it in &lt;altivec.h&gt;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 2 x unsigned long integers. </td></tr>
    <tr><td class="paramname">vrb</td><td>shift amount in bits 58:63 and 122:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Right shifted vector unsigned long. </dd></dl>

</div>
</div>
<a class="anchor" id="a89e352b9d7cc7cdb597a14ddb0933387"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vsrd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Doubleword. </p>
<p>Vector Shift Right Doubleword 0-63 bits. The shift amount is from bits 58-63 and 122-127 of vrb.</p>
<dl class="section note"><dt>Note</dt><dd>Use the vec_vsrd for consistency with vec_vsld above. Define vec_vsrd only if the compiler does not define it in &lt;altivec.h&gt;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 2 x unsigned long integers. </td></tr>
    <tr><td class="paramname">vrb</td><td>shift amount in bits 58:63 and 122:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Right shifted vector unsigned long. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 7 2018 09:55:13 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
