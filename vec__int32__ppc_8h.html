<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>POWER Vector Library Manual: src/vec_int32_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_int32_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over 32-bit integer elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__int16__ppc_8h_source.html">vec_int16_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__int32__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afbe65a777f2b75022ae584f76d0a2777"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#afbe65a777f2b75022ae584f76d0a2777">vec_clzw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:afbe65a777f2b75022ae584f76d0a2777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Count Leading Zeros word.  <a href="#afbe65a777f2b75022ae584f76d0a2777">More...</a><br /></td></tr>
<tr class="separator:afbe65a777f2b75022ae584f76d0a2777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d39dc4278a5e0711e9109746b23f2c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a0d39dc4278a5e0711e9109746b23f2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Algebraic High Words.  <a href="#a0d39dc4278a5e0711e9109746b23f2c7">More...</a><br /></td></tr>
<tr class="separator:a0d39dc4278a5e0711e9109746b23f2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4107474cdf1907051de84ea063417911"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a4107474cdf1907051de84ea063417911">vec_mrgalw</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a4107474cdf1907051de84ea063417911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector merge Algebraic low words.  <a href="#a4107474cdf1907051de84ea063417911">More...</a><br /></td></tr>
<tr class="separator:a4107474cdf1907051de84ea063417911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67359d6f4003fcb7cca8ed1b64b7cf4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ab67359d6f4003fcb7cca8ed1b64b7cf4">vec_mrgew</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:ab67359d6f4003fcb7cca8ed1b64b7cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Even Words.  <a href="#ab67359d6f4003fcb7cca8ed1b64b7cf4">More...</a><br /></td></tr>
<tr class="separator:ab67359d6f4003fcb7cca8ed1b64b7cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10a13aa644282aa60dcbfbd8b02f0bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#af10a13aa644282aa60dcbfbd8b02f0bc">vec_mrgow</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:af10a13aa644282aa60dcbfbd8b02f0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Odd Words.  <a href="#af10a13aa644282aa60dcbfbd8b02f0bc">More...</a><br /></td></tr>
<tr class="separator:af10a13aa644282aa60dcbfbd8b02f0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7b91bf6138d029d9d8cc57b0905f1f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#add7b91bf6138d029d9d8cc57b0905f1f">vec_mulesw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> b)</td></tr>
<tr class="memdesc:add7b91bf6138d029d9d8cc57b0905f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply even signed words.  <a href="#add7b91bf6138d029d9d8cc57b0905f1f">More...</a><br /></td></tr>
<tr class="separator:add7b91bf6138d029d9d8cc57b0905f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415942bd7b8183634e44e56b6a40101b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a415942bd7b8183634e44e56b6a40101b">vec_mulosw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> b)</td></tr>
<tr class="memdesc:a415942bd7b8183634e44e56b6a40101b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply odd signed words.  <a href="#a415942bd7b8183634e44e56b6a40101b">More...</a><br /></td></tr>
<tr class="separator:a415942bd7b8183634e44e56b6a40101b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93f07d5ad73243db2771da83b50d6d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b)</td></tr>
<tr class="memdesc:ac93f07d5ad73243db2771da83b50d6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply even unsigned words.  <a href="#ac93f07d5ad73243db2771da83b50d6d8">More...</a><br /></td></tr>
<tr class="separator:ac93f07d5ad73243db2771da83b50d6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca45c65b9627abfc493d4ad500a961d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b)</td></tr>
<tr class="memdesc:a3ca45c65b9627abfc493d4ad500a961d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply odd unsigned words.  <a href="#a3ca45c65b9627abfc493d4ad500a961d">More...</a><br /></td></tr>
<tr class="separator:a3ca45c65b9627abfc493d4ad500a961d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316e9909abc24eb4f9b5d6d29fe64185"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a316e9909abc24eb4f9b5d6d29fe64185">vec_mulhsw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vrb)</td></tr>
<tr class="memdesc:a316e9909abc24eb4f9b5d6d29fe64185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Signed Word.  <a href="#a316e9909abc24eb4f9b5d6d29fe64185">More...</a><br /></td></tr>
<tr class="separator:a316e9909abc24eb4f9b5d6d29fe64185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094c6adb04c1515361426ad58b0fdbb3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">vec_mulhuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:a094c6adb04c1515361426ad58b0fdbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Unsigned Word.  <a href="#a094c6adb04c1515361426ad58b0fdbb3">More...</a><br /></td></tr>
<tr class="separator:a094c6adb04c1515361426ad58b0fdbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ea7653d4e60454b91d669e2b1bcfdf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ab3ea7653d4e60454b91d669e2b1bcfdf">vec_muluwm</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b)</td></tr>
<tr class="memdesc:ab3ea7653d4e60454b91d669e2b1bcfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Unsigned Word Modulo.  <a href="#ab3ea7653d4e60454b91d669e2b1bcfdf">More...</a><br /></td></tr>
<tr class="separator:ab3ea7653d4e60454b91d669e2b1bcfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5b81dc628ca80e079a86515e391023"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#acb5b81dc628ca80e079a86515e391023">vec_popcntw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:acb5b81dc628ca80e079a86515e391023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Population Count word.  <a href="#acb5b81dc628ca80e079a86515e391023">More...</a><br /></td></tr>
<tr class="separator:acb5b81dc628ca80e079a86515e391023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d2c7192202e70f52997ab743418a77"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ae4d2c7192202e70f52997ab743418a77">vec_revbw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:ae4d2c7192202e70f52997ab743418a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte reverse each word of a vector unsigned int.  <a href="#ae4d2c7192202e70f52997ab743418a77">More...</a><br /></td></tr>
<tr class="separator:ae4d2c7192202e70f52997ab743418a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500924c8925b336d49b6a5d4307fe14c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a500924c8925b336d49b6a5d4307fe14c">vec_slwi</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a500924c8925b336d49b6a5d4307fe14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift left Word Immediate.  <a href="#a500924c8925b336d49b6a5d4307fe14c">More...</a><br /></td></tr>
<tr class="separator:a500924c8925b336d49b6a5d4307fe14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb4872afdd52b5ba965856c7e1a58ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#aefb4872afdd52b5ba965856c7e1a58ad">vec_srawi</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:aefb4872afdd52b5ba965856c7e1a58ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Algebraic Word Immediate.  <a href="#aefb4872afdd52b5ba965856c7e1a58ad">More...</a><br /></td></tr>
<tr class="separator:aefb4872afdd52b5ba965856c7e1a58ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73a97260ce07b46031e2c8560a5320b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:af73a97260ce07b46031e2c8560a5320b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Word Immediate.  <a href="#af73a97260ce07b46031e2c8560a5320b">More...</a><br /></td></tr>
<tr class="separator:af73a97260ce07b46031e2c8560a5320b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over 32-bit integer elements. </p>
<p>Most vector int (32-bit integer word) operations are implemented with PowerISA VMX instructions either defined by the original VMX (AKA Altivec) or added to later versions of the PowerISA. Vector word wise merge, shift, and splat operations were added with VSX in PowerISA 2.06B (POWER7). PowerISA 2.07B (POWER8) added several useful word wise (multiply, merge, count leading zeros, population count) operations not included in the original VMX. PowerISA 3.0B (POWER9) adds several more (compare not equal, count trailing zeros, extend sign, extract/insert, and parity). Most of these intrinsic (compiler built-ins) operations are defined in &lt;altivec.h&gt; and described in the compiler documentation.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power7</b>, vec_vclz and vec_vclzw will not be defined. Another example if you compile with <b>-mcpu=power8</b>, vec_revb will not be defined. This header provides the appropriate substitutions, will generate the minimum code, appropriate for the target, and produce correct results.</dd>
<dd>
Most ppc64le compilers will default to -mcpu=power8 if not specified.</dd></dl>
<p>Most of these operations are implemented in a single instruction on newer (POWER8/POWER9) processors. This header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides a in-line assembler implementation for older compilers that do not provide the build-ins.</p>
<p>The newly introduced vector operations imply some useful composite operations. For example, we can make the vector multiply even/odd/modulo word operations available for older compilers. And provide implementations for older (POWER7 and earlier) processors using the original VMX operations.</p>
<p>This header covers operations that are either:</p>
<ul>
<li>Implemented in hardware instructions for later processors and useful to programmers, on slightly older processors, even if the equivalent function requires more instructions. Examples include the multiply even/odd/modulo word operations.</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.n&gt; provided by available compilers in common use. Examples include Count Leading Zeros, Population Count and Byte Reverse.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious. Examples include the shift immediate and multiple high operations.</li>
</ul>
<h1><a class="anchor" id="i32_endian_issues_0_0"></a>
Problems with Endian</h1>
<p>It would be useful to provide a vector multiple high word (return the high order 32-bits of the 64-bit product) operation. This is useful for multiplicative inverse (effectively integer divide) operations. Neither Vector integer multiply high nor divide are available as instructions. However the multiply high word operation can be composed from the existing multiply even/odd word operations followed by the vector merge even word instruction.</p>
<p>As a prerequisite we need to provide the merge even/odd word operations for older compilers and an implementation for older (POWER7) processors. Fortunately vector merger operations are just a special case of vector permute. So the POWER7 (and earlier) implementation can use vec_perm and appropriate selection vectors to provide these operations.</p>
<p>But this is complicated by <em>Little Endian</em> (LE) support as specified in the OpenPOWER ABI and as implemented in the compilers. Little Endian changes the effective vector element numbering and the location of even and odd elements. This means that the vector built-ins provided by altivec.h may not generate the instructions you would expect.</p>
<p>The OpenPOWER ABI provides a helpful table of "Endian Sensitive Operations". For vec_mergee (vmrgew) it specifies: </p><blockquote class="doxtable">
<p>Swap inputs and use vmrgow, for LE.</p>
</blockquote>
<p>Also for vec_mule (vmuleuw, vmulesw): </p><blockquote class="doxtable">
<p>Replace with vmulouw and so on, for LE.</p>
</blockquote>
<p>Also for vec_perm (vperm) it specifies: </p><blockquote class="doxtable">
<p>For LE, Swap input arguments and complement the selection vector.</p>
</blockquote>
<p>So the obvious coding for Vector Multiply High Word: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div><div class="line">test_mulhw (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> vec_mergee ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vec_mule (vra, vrb),</div><div class="line">                     (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vec_mulo (vra, vrb));</div><div class="line">}</div></div><!-- fragment --><p> Would produce the expected code and correct results when compiled for BE: </p><div class="fragment"><div class="line">&lt;test_mulhw&gt;:</div><div class="line">        vmuleuw v0,v2,v3</div><div class="line">        vmuluuw v2,v2,v3</div><div class="line">        vmrgew  v2,v0,v2</div><div class="line">        blr</div></div><!-- fragment --><p> But the following and wrong code for LE: </p><div class="fragment"><div class="line">&lt;test_mulhw&gt;:</div><div class="line">        vmulouw v0,v2,v3</div><div class="line">        vmuleuw v2,v2,v3</div><div class="line">        vmrgow  v2,v2,v0</div><div class="line">        blr</div></div><!-- fragment --><p> The compiler swapped the multiplies even for odd and odd of even. Which is some what mitigated by swapping the input arguments in the merge. But changing the merge from even to odd actually returns the low order 32-bits of the product, which is not the correct result for multiply high. This is a general problem for using vectors to implement extended precision arithmetic.</p>
<p>So what can the Power Vector Library do to help?</p><ul>
<li>Be aware of these mandated LE transforms and if required provide compliant inline assembler implementations for LE.</li>
<li>Where required for correctness provide LE specific implementations that have the effect of nullifying the unwanted transforms.</li>
<li>Provide higher level operations that help pveclib and applications coding.</li>
</ul>
<p>This header provides implementations of vector merge even/odd word (<a class="el" href="vec__int32__ppc_8h.html#ab67359d6f4003fcb7cca8ed1b64b7cf4" title="Vector Merge Even Words. ">vec_mrgew()</a> and <a class="el" href="vec__int32__ppc_8h.html#af10a13aa644282aa60dcbfbd8b02f0bc" title="Vector Merge Odd Words. ">vec_mrgow()</a>) that support older compilers and older (POWER7) processor. Similarly for the multiply Even/odd unsigned/signed word instructions (<a class="el" href="vec__int32__ppc_8h.html#add7b91bf6138d029d9d8cc57b0905f1f" title="Vector multiply even signed words. ">vec_mulesw()</a>, <a class="el" href="vec__int32__ppc_8h.html#a415942bd7b8183634e44e56b6a40101b" title="Vector multiply odd signed words. ">vec_mulosw()</a>, <a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8" title="Vector multiply even unsigned words. ">vec_muleuw()</a> and <a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d" title="Vector multiply odd unsigned words. ">vec_mulouw()</a>). These implementations include the mandated LE transforms.</p>
<p>This header also provides the higher level operations Vector Merge Algebraic High/low Word (<a class="el" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7" title="Vector Merge Algebraic High Words. ">vec_mrgahw()</a> and <a class="el" href="vec__int32__ppc_8h.html#a4107474cdf1907051de84ea063417911" title="Vector merge Algebraic low words. ">vec_mrgalw()</a>). These implementations generate the correct merge even/odd word instruction for the operation independent of Endian. </p><dl class="section note"><dt>Note</dt><dd>The parameters are vector unsigned long (vui64_t) to match results from <a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8" title="Vector multiply even unsigned words. ">vec_muleuw()</a> and <a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d" title="Vector multiply odd unsigned words. ">vec_mulouw()</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div><div class="line"><a class="code" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> res;</div><div class="line"><span class="preprocessor">#ifdef _ARCH_PWR8</span></div><div class="line"><span class="preprocessor">#ifdef vec_vmrgew // Use altivec.h builtins</span></div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="comment">// really want vmrgew here! So do the opposite.</span></div><div class="line">  res = vec_vmrgow ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vra);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  res = vec_vmrgew ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vra, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrb);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#else // Generate vmrgew directly in assembler</span></div><div class="line">  __asm__(</div><div class="line">      <span class="stringliteral">&quot;vmrgew %0,%1,%2;\n&quot;</span></div><div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (res)</div><div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (vra),</div><div class="line">      <span class="stringliteral">&quot;v&quot;</span> (vrb)</div><div class="line">      : );</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#else // POWER7 and earlier, Assume BE only</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vconstp =</div><div class="line">      <a class="code" href="vec__common__ppc_8h.html#a7e03d3eaeafea2c6613233fd58f98ec1">CONST_VINT32_W</a>(0x00010203,  0x10111213, 0x08090a0b,  0x18191a1b);</div><div class="line">  res = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vec_perm ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vra, (<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vrb, (<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vconstp);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  <span class="keywordflow">return</span> (res);</div><div class="line">}</div></div><!-- fragment --><p> The implementation is a bit complicated so that is can nullify the unwanted transformation of vec_vmrgew(), in addition to handling older and compilers and processors.</p>
<p>Now we can implement Vector Multiply High Unsigned Word (<a class="el" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3" title="Vector Multiply High Unsigned Word. ">vec_mulhuw()</a>): </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div><div class="line"><a class="code" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">vec_mulhuw</a> (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</div><div class="line">{</div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="code" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (vra, vrb), <a class="code" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (vra, vrb));</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="code" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (vra, vrb), <a class="code" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (vra, vrb));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --><p> Again the implementation is more complicated than expected as we still have to nullify the Endian transformation associated with multiply even/odd.</p>
<p>The good news is all this complexity is contained within pveclib and the generated code is still just 3 instructions. </p><div class="fragment"><div class="line">vmulouw v0,v2,v3</div><div class="line">vmuleuw v2,v2,v3</div><div class="line">vmrgew  v2,v2,v0</div></div><!-- fragment --> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afbe65a777f2b75022ae584f76d0a2777"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_clzw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Count Leading Zeros word. </p>
<p>Count the number of leading '0' bits (0-32) within each word element of a 128-bit vector.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Count Leading Zeros Word instruction <b>vclzw</b>. Otherwise use sequence of pre 2.07 VMX instructions. SIMDized count leading zeros inspired by:</p>
<p>Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 5 Counting Bits, Figure 5-12.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 4 x 32-bit integer (words) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the Leading Zeros count for each word element. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d39dc4278a5e0711e9109746b23f2c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgahw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Algebraic High Words. </p>
<p>Merge only the high words from 4 x Algebraic doublewords across vectors vra and vrb. This effectively the Vector Merge Even Word operation that is not modified for Endian.</p>
<p>For example merge the high 32-bits from 4 x 64-bit products as generated by vec_muleuw/vec_mulouw. This result is effectively a vector multiply high unsigned word.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned long. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the high words of the 4 x Algebraic doublewords across vra and vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="a4107474cdf1907051de84ea063417911"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgalw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector merge Algebraic low words. </p>
<p>Merge the arithmetic low words 4 x Algebraic doublewords across vectors vra and vrb. This is effectively the Vector Merge Odd Word operation that is not modified for Endian.</p>
<p>For example merge the low 32-bits from 4 x 64-bit products as generated by vec_muleuw/vec_mulouw. This result is effectively a vector multiply low unsigned word (multiply unsigned word modulo).</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned long. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the low words of the 4 x Algebraic doublewords across vra and vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="ab67359d6f4003fcb7cca8ed1b64b7cf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Even Words. </p>
<p>Merge the even word elements from the concatenation of 2 x vectors (vra and vrb).</p><ul>
<li>res[0] = vra[0];</li>
<li>res[1] = vrb[0];</li>
<li>res[2] = vra[2];</li>
<li>res[3] = vrb[2];</li>
</ul>
<p>The element numbering changes between Big and Little Endian. So the compiler and this implementation adjusts the generated code to reflect this.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the even words of vra and vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="af10a13aa644282aa60dcbfbd8b02f0bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Odd Words. </p>
<p>Merge the odd word elements from the concatenation of 2 x vectors (vra and vrb).</p><ul>
<li>res[0] = vra[1];</li>
<li>res[1] = vrb[1];</li>
<li>res[2] = vra[3];</li>
<li>res[3] = vrb[3];</li>
</ul>
<p>The element numbering changes between Big and Little Endian. So the compiler and this implementation adjusts the generated code to reflect this.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the even words of vra and vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="add7b91bf6138d029d9d8cc57b0905f1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_mulesw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply even signed words. </p>
<p>Multiple the even words of two vector signed int values and return the signed long product of the even words.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector signed long product of the even words of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="ac93f07d5ad73243db2771da83b50d6d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_muleuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply even unsigned words. </p>
<p>Multiple the even words of two vector unsigned int values and return the unsigned long product of the even words.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long product of the even words of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="a316e9909abc24eb4f9b5d6d29fe64185"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vec_mulhsw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Signed Word. </p>
<p>Multiple the corresponding word elements of two vector signed int values and return the high order 32-bits, for each 64-bit product element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the high order 32-bits of the product of the word elements from vra and vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="a094c6adb04c1515361426ad58b0fdbb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mulhuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Unsigned Word. </p>
<p>Multiple the corresponding word elements of two vector unsigned int values and return the high order 32-bits, for each 64-bit product element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This operation can be used to effectively perform a divide by multiplying by the scaled multiplicative inverse (reciprocal).</dd></dl>
<p>Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 10, Integer Division by Constants.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the high order 32-bits of the signed product of the word elements from vra and vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="a415942bd7b8183634e44e56b6a40101b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_mulosw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply odd signed words. </p>
<p>Multiple the odd words of two vector signed int values and return the signed long product of the odd words.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector signed long product of the odd words of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ca45c65b9627abfc493d4ad500a961d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mulouw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply odd unsigned words. </p>
<p>Multiple the odd words of two vector unsigned int values and return the unsigned long product of the odd words.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long product of the odd words of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3ea7653d4e60454b91d669e2b1bcfdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_muluwm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Unsigned Word Modulo. </p>
<p>Multiple the corresponding word elements of two vector unsigned int values and return the low order 32-bits of the 64-bit product for each element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the high order 32-bits of the unsigned product of the word elements from vra and vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="acb5b81dc628ca80e079a86515e391023"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_popcntw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Population Count word. </p>
<p>Count the number of '1' bits (0-32) within each word element of a 128-bit vector.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Population Count Word instruction. Otherwise use the pveclib vec_popcntb to count each byte then sum across with Vector Sum across Quarter Unsigned Byte Saturate.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 4 x 32-bit integer (words) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the population count for each word element. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4d2c7192202e70f52997ab743418a77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_revbw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>byte reverse each word of a vector unsigned int. </p>
<p>For each word of the input vector, reverse the order of bytes / octets within the word.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector with the bytes of each word reversed. </dd></dl>

</div>
</div>
<a class="anchor" id="a500924c8925b336d49b6a5d4307fe14c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_slwi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift left Word Immediate. </p>
<p>Shift left each word element [0-3], 0-31 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-31. A shift count of 0 returns the original value of vra. Shift counts greater then 31 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned int, shifted left shb bits. </dd></dl>

</div>
</div>
<a class="anchor" id="aefb4872afdd52b5ba965856c7e1a58ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vec_srawi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Algebraic Word Immediate. </p>
<p>Shift Right Algebraic each word element [0-3], 0-31 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-31. A shift count of 0 returns the original value of vra. Shift counts greater then 31 bits return the sign bit propagated to each bit of each element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector signed int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector signed int, shifted right shb bits. </dd></dl>

</div>
</div>
<a class="anchor" id="af73a97260ce07b46031e2c8560a5320b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_srwi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Word Immediate. </p>
<p>Shift right each word element [0-3], 0-31 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-31. A shift count of 0 returns the original value of vra. Shift counts greater then 31 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned char. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned int, shifted right shb bits. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 28 2018 18:50:57 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
