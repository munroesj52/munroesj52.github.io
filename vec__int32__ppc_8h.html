<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_int32_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_int32_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over 32-bit integer elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__int16__ppc_8h_source.html">pveclib/vec_int16_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__int32__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a85ec15f292163e0e40e6faa5f4797367"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a85ec15f292163e0e40e6faa5f4797367">vec_absduw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:a85ec15f292163e0e40e6faa5f4797367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Absolute Difference Unsigned Word.  <a href="vec__int32__ppc_8h.html#a85ec15f292163e0e40e6faa5f4797367">More...</a><br /></td></tr>
<tr class="separator:a85ec15f292163e0e40e6faa5f4797367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe65a777f2b75022ae584f76d0a2777"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#afbe65a777f2b75022ae584f76d0a2777">vec_clzw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:afbe65a777f2b75022ae584f76d0a2777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Count Leading Zeros word.  <a href="vec__int32__ppc_8h.html#afbe65a777f2b75022ae584f76d0a2777">More...</a><br /></td></tr>
<tr class="separator:afbe65a777f2b75022ae584f76d0a2777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d8feaed351dfc1747ed1f3692040c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a43d8feaed351dfc1747ed1f3692040c1">vec_ctzw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:a43d8feaed351dfc1747ed1f3692040c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Count Trailing Zeros word.  <a href="vec__int32__ppc_8h.html#a43d8feaed351dfc1747ed1f3692040c1">More...</a><br /></td></tr>
<tr class="separator:a43d8feaed351dfc1747ed1f3692040c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d39dc4278a5e0711e9109746b23f2c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a0d39dc4278a5e0711e9109746b23f2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Algebraic High Words.  <a href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">More...</a><br /></td></tr>
<tr class="separator:a0d39dc4278a5e0711e9109746b23f2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4107474cdf1907051de84ea063417911"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a4107474cdf1907051de84ea063417911">vec_mrgalw</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a4107474cdf1907051de84ea063417911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector merge Algebraic low words.  <a href="vec__int32__ppc_8h.html#a4107474cdf1907051de84ea063417911">More...</a><br /></td></tr>
<tr class="separator:a4107474cdf1907051de84ea063417911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67359d6f4003fcb7cca8ed1b64b7cf4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ab67359d6f4003fcb7cca8ed1b64b7cf4">vec_mrgew</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:ab67359d6f4003fcb7cca8ed1b64b7cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Even Words.  <a href="vec__int32__ppc_8h.html#ab67359d6f4003fcb7cca8ed1b64b7cf4">More...</a><br /></td></tr>
<tr class="separator:ab67359d6f4003fcb7cca8ed1b64b7cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10a13aa644282aa60dcbfbd8b02f0bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#af10a13aa644282aa60dcbfbd8b02f0bc">vec_mrgow</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:af10a13aa644282aa60dcbfbd8b02f0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Odd Words.  <a href="vec__int32__ppc_8h.html#af10a13aa644282aa60dcbfbd8b02f0bc">More...</a><br /></td></tr>
<tr class="separator:af10a13aa644282aa60dcbfbd8b02f0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7b91bf6138d029d9d8cc57b0905f1f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#add7b91bf6138d029d9d8cc57b0905f1f">vec_mulesw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> b)</td></tr>
<tr class="memdesc:add7b91bf6138d029d9d8cc57b0905f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply even signed words.  <a href="vec__int32__ppc_8h.html#add7b91bf6138d029d9d8cc57b0905f1f">More...</a><br /></td></tr>
<tr class="separator:add7b91bf6138d029d9d8cc57b0905f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415942bd7b8183634e44e56b6a40101b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a415942bd7b8183634e44e56b6a40101b">vec_mulosw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> b)</td></tr>
<tr class="memdesc:a415942bd7b8183634e44e56b6a40101b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply odd signed words.  <a href="vec__int32__ppc_8h.html#a415942bd7b8183634e44e56b6a40101b">More...</a><br /></td></tr>
<tr class="separator:a415942bd7b8183634e44e56b6a40101b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93f07d5ad73243db2771da83b50d6d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b)</td></tr>
<tr class="memdesc:ac93f07d5ad73243db2771da83b50d6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply even unsigned words.  <a href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">More...</a><br /></td></tr>
<tr class="separator:ac93f07d5ad73243db2771da83b50d6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca45c65b9627abfc493d4ad500a961d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b)</td></tr>
<tr class="memdesc:a3ca45c65b9627abfc493d4ad500a961d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply odd unsigned words.  <a href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">More...</a><br /></td></tr>
<tr class="separator:a3ca45c65b9627abfc493d4ad500a961d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316e9909abc24eb4f9b5d6d29fe64185"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a316e9909abc24eb4f9b5d6d29fe64185">vec_mulhsw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vrb)</td></tr>
<tr class="memdesc:a316e9909abc24eb4f9b5d6d29fe64185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Signed Word.  <a href="vec__int32__ppc_8h.html#a316e9909abc24eb4f9b5d6d29fe64185">More...</a><br /></td></tr>
<tr class="separator:a316e9909abc24eb4f9b5d6d29fe64185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094c6adb04c1515361426ad58b0fdbb3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">vec_mulhuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:a094c6adb04c1515361426ad58b0fdbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Unsigned Word.  <a href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">More...</a><br /></td></tr>
<tr class="separator:a094c6adb04c1515361426ad58b0fdbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ea7653d4e60454b91d669e2b1bcfdf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ab3ea7653d4e60454b91d669e2b1bcfdf">vec_muluwm</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b)</td></tr>
<tr class="memdesc:ab3ea7653d4e60454b91d669e2b1bcfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Unsigned Word Modulo.  <a href="vec__int32__ppc_8h.html#ab3ea7653d4e60454b91d669e2b1bcfdf">More...</a><br /></td></tr>
<tr class="separator:ab3ea7653d4e60454b91d669e2b1bcfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5b81dc628ca80e079a86515e391023"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#acb5b81dc628ca80e079a86515e391023">vec_popcntw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:acb5b81dc628ca80e079a86515e391023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Population Count word.  <a href="vec__int32__ppc_8h.html#acb5b81dc628ca80e079a86515e391023">More...</a><br /></td></tr>
<tr class="separator:acb5b81dc628ca80e079a86515e391023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d2c7192202e70f52997ab743418a77"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ae4d2c7192202e70f52997ab743418a77">vec_revbw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:ae4d2c7192202e70f52997ab743418a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte reverse each word of a vector unsigned int.  <a href="vec__int32__ppc_8h.html#ae4d2c7192202e70f52997ab743418a77">More...</a><br /></td></tr>
<tr class="separator:ae4d2c7192202e70f52997ab743418a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa713f51a760e1175a00d645dd4b43ebc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#aa713f51a760e1175a00d645dd4b43ebc">vec_setb_sw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra)</td></tr>
<tr class="memdesc:aa713f51a760e1175a00d645dd4b43ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Set Bool from Signed Word.  <a href="vec__int32__ppc_8h.html#aa713f51a760e1175a00d645dd4b43ebc">More...</a><br /></td></tr>
<tr class="separator:aa713f51a760e1175a00d645dd4b43ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500924c8925b336d49b6a5d4307fe14c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a500924c8925b336d49b6a5d4307fe14c">vec_slwi</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a500924c8925b336d49b6a5d4307fe14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift left Word Immediate.  <a href="vec__int32__ppc_8h.html#a500924c8925b336d49b6a5d4307fe14c">More...</a><br /></td></tr>
<tr class="separator:a500924c8925b336d49b6a5d4307fe14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb4872afdd52b5ba965856c7e1a58ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#aefb4872afdd52b5ba965856c7e1a58ad">vec_srawi</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:aefb4872afdd52b5ba965856c7e1a58ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Algebraic Word Immediate.  <a href="vec__int32__ppc_8h.html#aefb4872afdd52b5ba965856c7e1a58ad">More...</a><br /></td></tr>
<tr class="separator:aefb4872afdd52b5ba965856c7e1a58ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73a97260ce07b46031e2c8560a5320b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:af73a97260ce07b46031e2c8560a5320b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Word Immediate.  <a href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">More...</a><br /></td></tr>
<tr class="separator:af73a97260ce07b46031e2c8560a5320b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb1891a74721a4d3e997af85544cdf6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#aedb1891a74721a4d3e997af85544cdf6">vec_vgl4wso</a> (unsigned int *array, const long long offset0, const long long offset1, const long long offset2, const long long offset3)</td></tr>
<tr class="memdesc:aedb1891a74721a4d3e997af85544cdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load 4 Words from scalar Offsets.  <a href="vec__int32__ppc_8h.html#aedb1891a74721a4d3e997af85544cdf6">More...</a><br /></td></tr>
<tr class="separator:aedb1891a74721a4d3e997af85544cdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accce3d13dc8346f05a56c587e2a21432"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#accce3d13dc8346f05a56c587e2a21432">vec_vgl4wwo</a> (unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra)</td></tr>
<tr class="memdesc:accce3d13dc8346f05a56c587e2a21432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load 4 Words from Vector Word Offsets.  <a href="vec__int32__ppc_8h.html#accce3d13dc8346f05a56c587e2a21432">More...</a><br /></td></tr>
<tr class="separator:accce3d13dc8346f05a56c587e2a21432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba8cd6ad53df6d25c8d41a84f42c21d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#aaba8cd6ad53df6d25c8d41a84f42c21d">vec_vgl4wwsx</a> (unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, const unsigned char scale)</td></tr>
<tr class="memdesc:aaba8cd6ad53df6d25c8d41a84f42c21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load 4 Words from Vector Word Scaled Indexes.  <a href="vec__int32__ppc_8h.html#aaba8cd6ad53df6d25c8d41a84f42c21d">More...</a><br /></td></tr>
<tr class="separator:aaba8cd6ad53df6d25c8d41a84f42c21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18942f74154258bb0929be4597638f0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ab18942f74154258bb0929be4597638f0">vec_vgl4wwx</a> (unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra)</td></tr>
<tr class="memdesc:ab18942f74154258bb0929be4597638f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load 4 Words from Vector Word Indexes.  <a href="vec__int32__ppc_8h.html#ab18942f74154258bb0929be4597638f0">More...</a><br /></td></tr>
<tr class="separator:ab18942f74154258bb0929be4597638f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab36f02d6b29264e7f40a47b9ea7d9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#aeab36f02d6b29264e7f40a47b9ea7d9c">vec_vglswso</a> (signed int *array, const long long offset0, const long long offset1)</td></tr>
<tr class="memdesc:aeab36f02d6b29264e7f40a47b9ea7d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Signed Word from Scalar Offsets.  <a href="vec__int32__ppc_8h.html#aeab36f02d6b29264e7f40a47b9ea7d9c">More...</a><br /></td></tr>
<tr class="separator:aeab36f02d6b29264e7f40a47b9ea7d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f05ef2940a8a9ba515895f5dd72739e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a8f05ef2940a8a9ba515895f5dd72739e">vec_vglswdo</a> (signed int *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:a8f05ef2940a8a9ba515895f5dd72739e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Signed Words from Vector Doubleword Offsets.  <a href="vec__int32__ppc_8h.html#a8f05ef2940a8a9ba515895f5dd72739e">More...</a><br /></td></tr>
<tr class="separator:a8f05ef2940a8a9ba515895f5dd72739e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229fefaa88337ca7d376d37e83a44788"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a229fefaa88337ca7d376d37e83a44788">vec_vglswdsx</a> (signed int *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, const unsigned char scale)</td></tr>
<tr class="memdesc:a229fefaa88337ca7d376d37e83a44788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Signed Words from Vector Doubleword Scaled Indexes.  <a href="vec__int32__ppc_8h.html#a229fefaa88337ca7d376d37e83a44788">More...</a><br /></td></tr>
<tr class="separator:a229fefaa88337ca7d376d37e83a44788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d46e364500751fef08efbb16a128ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a19d46e364500751fef08efbb16a128ee">vec_vglswdx</a> (signed int *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:a19d46e364500751fef08efbb16a128ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Signed Words from Vector Doubleword Indexes.  <a href="vec__int32__ppc_8h.html#a19d46e364500751fef08efbb16a128ee">More...</a><br /></td></tr>
<tr class="separator:a19d46e364500751fef08efbb16a128ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ace130b253389747902768a5fa029d5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a2ace130b253389747902768a5fa029d5">vec_vgluwso</a> (unsigned int *array, const long long offset0, const long long offset1)</td></tr>
<tr class="memdesc:a2ace130b253389747902768a5fa029d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Unsigned Word from Scalar Offsets.  <a href="vec__int32__ppc_8h.html#a2ace130b253389747902768a5fa029d5">More...</a><br /></td></tr>
<tr class="separator:a2ace130b253389747902768a5fa029d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947ca10d28d0839d02bbc3c33c0f5ef6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a947ca10d28d0839d02bbc3c33c0f5ef6">vec_vgluwdo</a> (unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:a947ca10d28d0839d02bbc3c33c0f5ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Unsigned Words from Vector Doubleword Offsets.  <a href="vec__int32__ppc_8h.html#a947ca10d28d0839d02bbc3c33c0f5ef6">More...</a><br /></td></tr>
<tr class="separator:a947ca10d28d0839d02bbc3c33c0f5ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179b8f8813c3c0d21e0281c570c2d7cb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a179b8f8813c3c0d21e0281c570c2d7cb">vec_vgluwdsx</a> (unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, const unsigned char scale)</td></tr>
<tr class="memdesc:a179b8f8813c3c0d21e0281c570c2d7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Unsigned Words from Vector Doubleword Scaled Indexes.  <a href="vec__int32__ppc_8h.html#a179b8f8813c3c0d21e0281c570c2d7cb">More...</a><br /></td></tr>
<tr class="separator:a179b8f8813c3c0d21e0281c570c2d7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ba8ecf5b44a6f43edb9f1be9c6e5af"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a52ba8ecf5b44a6f43edb9f1be9c6e5af">vec_vgluwdx</a> (unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:a52ba8ecf5b44a6f43edb9f1be9c6e5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Unsigned Words from Vector Doubleword Indexes.  <a href="vec__int32__ppc_8h.html#a52ba8ecf5b44a6f43edb9f1be9c6e5af">More...</a><br /></td></tr>
<tr class="separator:a52ba8ecf5b44a6f43edb9f1be9c6e5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9890d6fcb05c52af03d2b6fc3f516aeb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a9890d6fcb05c52af03d2b6fc3f516aeb">vec_vlxsiwax</a> (const signed long long ra, const signed int *rb)</td></tr>
<tr class="memdesc:a9890d6fcb05c52af03d2b6fc3f516aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Load Scalar Integer Word Algebraic Indexed.  <a href="vec__int32__ppc_8h.html#a9890d6fcb05c52af03d2b6fc3f516aeb">More...</a><br /></td></tr>
<tr class="separator:a9890d6fcb05c52af03d2b6fc3f516aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629c4f5c26758f8eb6ca8f21d9def4f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a629c4f5c26758f8eb6ca8f21d9def4f8">vec_vlxsiwzx</a> (const signed long long ra, const unsigned int *rb)</td></tr>
<tr class="memdesc:a629c4f5c26758f8eb6ca8f21d9def4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Load Scalar Integer Word and Zero Indexed.  <a href="vec__int32__ppc_8h.html#a629c4f5c26758f8eb6ca8f21d9def4f8">More...</a><br /></td></tr>
<tr class="separator:a629c4f5c26758f8eb6ca8f21d9def4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b046a56d566ec2ea351042fd9dd11de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a1b046a56d566ec2ea351042fd9dd11de">vec_vmadd2euw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> d)</td></tr>
<tr class="memdesc:a1b046a56d566ec2ea351042fd9dd11de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add2 Even Unsigned Words.  <a href="vec__int32__ppc_8h.html#a1b046a56d566ec2ea351042fd9dd11de">More...</a><br /></td></tr>
<tr class="separator:a1b046a56d566ec2ea351042fd9dd11de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ab00ed413c1aa1a8148cd9981235bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a40ab00ed413c1aa1a8148cd9981235bf">vec_vmadd2ouw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> d)</td></tr>
<tr class="memdesc:a40ab00ed413c1aa1a8148cd9981235bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add2 Odd Unsigned Words.  <a href="vec__int32__ppc_8h.html#a40ab00ed413c1aa1a8148cd9981235bf">More...</a><br /></td></tr>
<tr class="separator:a40ab00ed413c1aa1a8148cd9981235bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e20bdd1df7e3e49dca06d5512ada84b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a1e20bdd1df7e3e49dca06d5512ada84b">vec_vmaddeuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c)</td></tr>
<tr class="memdesc:a1e20bdd1df7e3e49dca06d5512ada84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add Even Unsigned Words.  <a href="vec__int32__ppc_8h.html#a1e20bdd1df7e3e49dca06d5512ada84b">More...</a><br /></td></tr>
<tr class="separator:a1e20bdd1df7e3e49dca06d5512ada84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32acead723b7867ff4c9f8be9bb708ca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a32acead723b7867ff4c9f8be9bb708ca">vec_vmaddouw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c)</td></tr>
<tr class="memdesc:a32acead723b7867ff4c9f8be9bb708ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add Odd Unsigned Words.  <a href="vec__int32__ppc_8h.html#a32acead723b7867ff4c9f8be9bb708ca">More...</a><br /></td></tr>
<tr class="separator:a32acead723b7867ff4c9f8be9bb708ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb37f8c3bb75090db08ab0981249ae7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a0bb37f8c3bb75090db08ab0981249ae7">vec_vmsumuwm</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> c)</td></tr>
<tr class="memdesc:a0bb37f8c3bb75090db08ab0981249ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Sum Unsigned Word Modulo.  <a href="vec__int32__ppc_8h.html#a0bb37f8c3bb75090db08ab0981249ae7">More...</a><br /></td></tr>
<tr class="separator:a0bb37f8c3bb75090db08ab0981249ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30f226bd27241513f0611b50967a080"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ae30f226bd27241513f0611b50967a080">vec_vmuleuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:ae30f226bd27241513f0611b50967a080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Even Unsigned words.  <a href="vec__int32__ppc_8h.html#ae30f226bd27241513f0611b50967a080">More...</a><br /></td></tr>
<tr class="separator:ae30f226bd27241513f0611b50967a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52349ced57857d20fb5e06b1b09cc05"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ae52349ced57857d20fb5e06b1b09cc05">vec_vmulouw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:ae52349ced57857d20fb5e06b1b09cc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Odd Unsigned Words.  <a href="vec__int32__ppc_8h.html#ae52349ced57857d20fb5e06b1b09cc05">More...</a><br /></td></tr>
<tr class="separator:ae52349ced57857d20fb5e06b1b09cc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedabb123d258fd438bda778262d5b33f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#aedabb123d258fd438bda778262d5b33f">vec_vsst4wso</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> xs, unsigned int *array, const long long offset0, const long long offset1, const long long offset2, const long long offset3)</td></tr>
<tr class="memdesc:aedabb123d258fd438bda778262d5b33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store 4 words to Scalar Offsets.  <a href="vec__int32__ppc_8h.html#aedabb123d258fd438bda778262d5b33f">More...</a><br /></td></tr>
<tr class="separator:aedabb123d258fd438bda778262d5b33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8284f1aee85e266219c6bd02b428a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a8c8284f1aee85e266219c6bd02b428a4">vec_vsst4wwo</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> xs, unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra)</td></tr>
<tr class="memdesc:a8c8284f1aee85e266219c6bd02b428a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store 4 words to Vector Word Offsets.  <a href="vec__int32__ppc_8h.html#a8c8284f1aee85e266219c6bd02b428a4">More...</a><br /></td></tr>
<tr class="separator:a8c8284f1aee85e266219c6bd02b428a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b82ded6af003670f3e45b5fcd2029d4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a5b82ded6af003670f3e45b5fcd2029d4">vec_vsst4wwsx</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> xs, unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, const unsigned char scale)</td></tr>
<tr class="memdesc:a5b82ded6af003670f3e45b5fcd2029d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store 4 words to Vector Word Indexes.  <a href="vec__int32__ppc_8h.html#a5b82ded6af003670f3e45b5fcd2029d4">More...</a><br /></td></tr>
<tr class="separator:a5b82ded6af003670f3e45b5fcd2029d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602707a2b979bbb6964c8940b3efd7aa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a602707a2b979bbb6964c8940b3efd7aa">vec_vsst4wwx</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> xs, unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra)</td></tr>
<tr class="memdesc:a602707a2b979bbb6964c8940b3efd7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store 4 words to Vector Word Indexes.  <a href="vec__int32__ppc_8h.html#a602707a2b979bbb6964c8940b3efd7aa">More...</a><br /></td></tr>
<tr class="separator:a602707a2b979bbb6964c8940b3efd7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad8cd35dc45feabf51aec9ee6abc9f5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#adad8cd35dc45feabf51aec9ee6abc9f5">vec_vsstwdo</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> xs, unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:adad8cd35dc45feabf51aec9ee6abc9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Words to Vector Doubleword Offsets.  <a href="vec__int32__ppc_8h.html#adad8cd35dc45feabf51aec9ee6abc9f5">More...</a><br /></td></tr>
<tr class="separator:adad8cd35dc45feabf51aec9ee6abc9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4975a4d756f76a89fbb17c0f731c5e7b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a4975a4d756f76a89fbb17c0f731c5e7b">vec_vsstwdsx</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> xs, unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, const unsigned char scale)</td></tr>
<tr class="memdesc:a4975a4d756f76a89fbb17c0f731c5e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Words to Vector Doubleword Scaled Indexes.  <a href="vec__int32__ppc_8h.html#a4975a4d756f76a89fbb17c0f731c5e7b">More...</a><br /></td></tr>
<tr class="separator:a4975a4d756f76a89fbb17c0f731c5e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb70258df78db91bb28686f0fc6ed045"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#aeb70258df78db91bb28686f0fc6ed045">vec_vsstwdx</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> xs, unsigned int *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:aeb70258df78db91bb28686f0fc6ed045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Words to Vector Doubleword Indexes.  <a href="vec__int32__ppc_8h.html#aeb70258df78db91bb28686f0fc6ed045">More...</a><br /></td></tr>
<tr class="separator:aeb70258df78db91bb28686f0fc6ed045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0c9b011e0062ae7673443f9560961e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a7d0c9b011e0062ae7673443f9560961e">vec_vsstwso</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> xs, unsigned int *array, const long long offset0, const long long offset1)</td></tr>
<tr class="memdesc:a7d0c9b011e0062ae7673443f9560961e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Words to Scalar Offsets.  <a href="vec__int32__ppc_8h.html#a7d0c9b011e0062ae7673443f9560961e">More...</a><br /></td></tr>
<tr class="separator:a7d0c9b011e0062ae7673443f9560961e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd395b358951d46fa96abf19974dd15"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#aecd395b358951d46fa96abf19974dd15">vec_vstxsiwx</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> xs, const signed long long ra, unsigned int *rb)</td></tr>
<tr class="memdesc:aecd395b358951d46fa96abf19974dd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Store Scalar Integer Word Indexed.  <a href="vec__int32__ppc_8h.html#aecd395b358951d46fa96abf19974dd15">More...</a><br /></td></tr>
<tr class="separator:aecd395b358951d46fa96abf19974dd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c88cebf964ac77e5022f22a3651ba7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#af2c88cebf964ac77e5022f22a3651ba7">vec_vsum2sw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vrb)</td></tr>
<tr class="memdesc:af2c88cebf964ac77e5022f22a3651ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Sum-across Half Signed Word Saturate.  <a href="vec__int32__ppc_8h.html#af2c88cebf964ac77e5022f22a3651ba7">More...</a><br /></td></tr>
<tr class="separator:af2c88cebf964ac77e5022f22a3651ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3b69b0eec926af6a6625767f9f0bd5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a2a3b69b0eec926af6a6625767f9f0bd5">vec_vsumsw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vrb)</td></tr>
<tr class="memdesc:a2a3b69b0eec926af6a6625767f9f0bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Sum-across Signed Word Saturate.  <a href="vec__int32__ppc_8h.html#a2a3b69b0eec926af6a6625767f9f0bd5">More...</a><br /></td></tr>
<tr class="separator:a2a3b69b0eec926af6a6625767f9f0bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce8dca3fa26586bf511650af3e19a76"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a3ce8dca3fa26586bf511650af3e19a76">vec_vupkhsw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra)</td></tr>
<tr class="memdesc:a3ce8dca3fa26586bf511650af3e19a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Unpack High Signed Word.  <a href="vec__int32__ppc_8h.html#a3ce8dca3fa26586bf511650af3e19a76">More...</a><br /></td></tr>
<tr class="separator:a3ce8dca3fa26586bf511650af3e19a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804a352598f61e47b191df7cc769f80f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a804a352598f61e47b191df7cc769f80f">vec_vupkhuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:a804a352598f61e47b191df7cc769f80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Unpack High Unsigned Word.  <a href="vec__int32__ppc_8h.html#a804a352598f61e47b191df7cc769f80f">More...</a><br /></td></tr>
<tr class="separator:a804a352598f61e47b191df7cc769f80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab93fbc9683c31e32d93966f1a65d786"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#aab93fbc9683c31e32d93966f1a65d786">vec_vupklsw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra)</td></tr>
<tr class="memdesc:aab93fbc9683c31e32d93966f1a65d786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Unpack Low Signed Word.  <a href="vec__int32__ppc_8h.html#aab93fbc9683c31e32d93966f1a65d786">More...</a><br /></td></tr>
<tr class="separator:aab93fbc9683c31e32d93966f1a65d786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3791b0177b07e467d80a466d13671f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a9f3791b0177b07e467d80a466d13671f">vec_vupkluw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:a9f3791b0177b07e467d80a466d13671f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Unpack Low Unsigned Word.  <a href="vec__int32__ppc_8h.html#a9f3791b0177b07e467d80a466d13671f">More...</a><br /></td></tr>
<tr class="separator:a9f3791b0177b07e467d80a466d13671f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over 32-bit integer elements. </p>
<p>Most of these operations are implemented in a single instruction on newer (POWER8/POWER9) processors. This header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides a in-line assembler implementation for older compilers that do not provide the build-ins.</p>
<p>Most vector int (32-bit integer word) operations are implemented with PowerISA VMX instructions either defined by the original VMX (AKA Altivec) or added to later versions of the PowerISA. Vector word-wise merge, shift, and splat operations were added with VSX in PowerISA 2.06B (POWER7). PowerISA 2.07B (POWER8) added several useful word wise operations (multiply, merge even/odd, count leading zeros, population count) not included in the original VMX. PowerISA 3.0B (POWER9) adds several more (compare not equal, count trailing zeros, extend sign, extract/insert, and parity). Most of these intrinsic (compiler built-ins) operations are defined in &lt;altivec.h&gt; and described in the compiler documentation.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power7</b>, vec_vclz and vec_vclzw will not be defined. Another example if you compile with <b>-mcpu=power8</b>, vec_revb will not be defined. This header provides the appropriate substitutions, will generate the minimum code, appropriate for the target, and produce correct results.</dd>
<dd>
Most ppc64le compilers will default to -mcpu=power8 if not specified.</dd></dl>
<p>The newly introduced vector operations imply some useful composite operations. For example, we can make the vector multiply even/odd/modulo word operations available for older compilers. And provide implementations for older (POWER7 and earlier) processors using the original VMX operations.</p>
<p>This header covers operations that are either:</p>
<ul>
<li>Implemented in hardware instructions for later processors and useful to programmers, on slightly older processors, even if the equivalent function requires more instructions. Examples include the multiply even/odd/modulo word operations.</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.h&gt; provided by available compilers in common use. Examples include Count Leading Zeros, Population Count and Byte Reverse.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious. Examples include the shift immediate, merge algebraic high/low, and multiply high operations.</li>
</ul>
<h1><a class="anchor" id="i32_recent_additions"></a>
Recent Additions</h1>
<p>Added <a class="el" href="vec__int32__ppc_8h.html#a1e20bdd1df7e3e49dca06d5512ada84b" title="Vector Multiply-Add Even Unsigned Words.">vec_vmaddeuw()</a>, <a class="el" href="vec__int32__ppc_8h.html#a32acead723b7867ff4c9f8be9bb708ca" title="Vector Multiply-Add Odd Unsigned Words.">vec_vmaddouw()</a>, <a class="el" href="vec__int32__ppc_8h.html#a1b046a56d566ec2ea351042fd9dd11de" title="Vector Multiply-Add2 Even Unsigned Words.">vec_vmadd2euw()</a>, and <a class="el" href="vec__int32__ppc_8h.html#a40ab00ed413c1aa1a8148cd9981235bf" title="Vector Multiply-Add2 Odd Unsigned Words.">vec_vmadd2ouw()</a> as an optimization for the vector multiply quadword implementations on POWER8.</p>
<h1><a class="anchor" id="i32_endian_issues_0_0"></a>
Endian problems with word operations</h1>
<p>It would be useful to provide a vector multiply high word (return the high order 32-bits of the 64-bit product) operation. This can be used for multiplicative inverse (effectively integer divide) operations. Neither integer multiply high nor divide are available as vector instructions. However the multiply high word operation can be composed from the existing multiply even/odd word operations followed by the vector merge even word instruction.</p>
<p>As a prerequisite we need to provide the merge even/odd word operations for older compilers and an implementation for older (POWER7) processors. Fortunately vector merge operations are just a special case of vector permute. So the POWER7 (and earlier) implementation can use vec_perm and appropriate selection vectors to provide these merge operations.</p>
<p>But this is complicated by <em>little-endian</em> (LE) support as specified in the OpenPOWER ABI and as implemented in the compilers. Little-endian changes the effective vector element numbering and the location of even and odd elements. This means that the vector built-ins provided by altivec.h may not generate the instructions you would expect. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#mainpage_endian_issues_1_1">General Endian Issues</a></dd></dl>
<p>The OpenPOWER ABI provides a helpful table of <a href="http://openpowerfoundation.org/wp-content/uploads/resources/leabi/content/dbdoclet.50655244_90667.html">Endian Sensitive Operations</a>. For vec_mergee (vmrgew) it specifies: </p><blockquote class="doxtable">
<p>Swap inputs and use vmrgow, for LE.</p>
</blockquote>
<p>Also for vec_mule (vmuleuw, vmulesw): </p><blockquote class="doxtable">
<p>Replace with vmulouw and so on, for LE.</p>
</blockquote>
<p>Also for vec_perm (vperm) it specifies: </p><blockquote class="doxtable">
<p>For LE, Swap input arguments and complement the selection vector.</p>
</blockquote>
<p>The above is just a sampling of a larger list of Endian Sensitive Operations.</p>
<p>So the obvious coding for Vector Multiply High Word: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line">test_mulhw (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> vec_mergee ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vec_mule (vra, vrb),</div>
<div class="line">                     (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vec_mulo (vra, vrb));</div>
<div class="line">}</div>
</div><!-- fragment --><p> Would produce the expected code and correct results when compiled for BE: </p><div class="fragment"><div class="line">&lt;test_mulhw&gt;:</div>
<div class="line">        vmuleuw v0,v2,v3</div>
<div class="line">        vmuluuw v2,v2,v3</div>
<div class="line">        vmrgew  v2,v0,v2</div>
<div class="line">        blr</div>
</div><!-- fragment --><p> But the following and wrong code for LE: </p><div class="fragment"><div class="line">&lt;test_mulhw&gt;:</div>
<div class="line">        vmulouw v0,v2,v3</div>
<div class="line">        vmuleuw v2,v2,v3</div>
<div class="line">        vmrgow  v2,v2,v0</div>
<div class="line">        blr</div>
</div><!-- fragment --><p> The compiler swapped the multiplies even for odd and odd of even. That is somewhat mitigated by swapping the input arguments in the merge. But changing the merge from even to odd actually returns the low order 32-bits of the product. This is not the correct result for multiply high.</p>
<p>This header provides implementations of vector merge even/odd word (<a class="el" href="vec__int32__ppc_8h.html#ab67359d6f4003fcb7cca8ed1b64b7cf4" title="Vector Merge Even Words.">vec_mrgew()</a> and <a class="el" href="vec__int32__ppc_8h.html#af10a13aa644282aa60dcbfbd8b02f0bc" title="Vector Merge Odd Words.">vec_mrgow()</a>) that support older compilers and older (POWER7) processor. Similarly for the multiply Even/odd unsigned/signed word instructions (<a class="el" href="vec__int32__ppc_8h.html#add7b91bf6138d029d9d8cc57b0905f1f" title="Vector multiply even signed words.">vec_mulesw()</a>, <a class="el" href="vec__int32__ppc_8h.html#a415942bd7b8183634e44e56b6a40101b" title="Vector multiply odd signed words.">vec_mulosw()</a>, <a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8" title="Vector multiply even unsigned words.">vec_muleuw()</a> and <a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d" title="Vector multiply odd unsigned words.">vec_mulouw()</a>). These implementations include the mandated LE transforms.</p>
<h2><a class="anchor" id="i32_example_0_0_0"></a>
Vector Merge Algebraic High Word example</h2>
<p>This header also provides the higher level operations Vector Merge Algebraic High/low Word (<a class="el" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7" title="Vector Merge Algebraic High Words.">vec_mrgahw()</a> and <a class="el" href="vec__int32__ppc_8h.html#a4107474cdf1907051de84ea063417911" title="Vector merge Algebraic low words.">vec_mrgalw()</a>). These implementations generate the correct merge even/odd word instruction for the operation independent of endian. </p><dl class="section note"><dt>Note</dt><dd>The parameters are vector unsigned long (vui64_t) to match results from <a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8" title="Vector multiply even unsigned words.">vec_muleuw()</a> and <a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d" title="Vector multiply odd unsigned words.">vec_mulouw()</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line"><a class="code" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> res;</div>
<div class="line"><span class="preprocessor">#ifdef _ARCH_PWR8</span></div>
<div class="line"><span class="preprocessor">#ifdef vec_vmrgew // Use altivec.h builtins</span></div>
<div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div>
<div class="line">  <span class="comment">// really want vmrgew here! So do the opposite.</span></div>
<div class="line">  res = vec_vmrgow ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vra);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  res = vec_vmrgew ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vra, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrb);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#else // Generate vmrgew directly in assembler</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;vmrgew %0,%1,%2;\n&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (res)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (vra),</div>
<div class="line">      <span class="stringliteral">&quot;v&quot;</span> (vrb)</div>
<div class="line">      : );</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#else // POWER7 and earlier, Assume BE only</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vconstp =</div>
<div class="line">      <a class="code" href="vec__common__ppc_8h.html#a7e03d3eaeafea2c6613233fd58f98ec1">CONST_VINT32_W</a>(0x00010203,  0x10111213, 0x08090a0b,  0x18191a1b);</div>
<div class="line">  res = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vec_perm ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vra, (<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vrb, (<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vconstp);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">  <span class="keywordflow">return</span> (res);</div>
<div class="line">}</div>
</div><!-- fragment --><p> The implementation is a bit complicated so that is can nullify the unwanted LE transformation of vec_vmrgew(), in addition to handling older and compilers and processors.</p>
<h2><a class="anchor" id="i32_example_0_0_1"></a>
Vector Multiply High Unsigned Word example</h2>
<p>Now we can implement Vector Multiply High Unsigned Word (<a class="el" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3" title="Vector Multiply High Unsigned Word.">vec_mulhuw()</a>): </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line"><a class="code" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">vec_mulhuw</a> (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="code" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (vra, vrb), <a class="code" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (vra, vrb));</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="code" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (vra, vrb), <a class="code" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (vra, vrb));</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">}</span></div>
</div><!-- fragment --><p> Again the implementation is more complicated than expected as we still have to nullify the LE transformation associated with multiply even/odd.</p>
<p>The good news is all this complexity is contained within pveclib and the generated code is still just 3 instructions. </p><div class="fragment"><div class="line">vmulouw v0,v2,v3</div>
<div class="line">vmuleuw v2,v2,v3</div>
<div class="line">vmrgew  v2,v2,v0</div>
</div><!-- fragment --><h1><a class="anchor" id="int32_examples_0_1"></a>
Vector Word Examples</h1>
<p>Suppose we have a requirement to convert an array of 32-bit time-interval values that need to convert to timespec format. For simplicity we will also assume that the array is nicely (Quadword) aligned and an integer multiple of 4 words.</p>
<p>The PowerISA provides a 64-bit TimeBase register that clocks at a constant 512MHz. The TimeBase can be read directly as either the full 64-bit value or as 32-bit upper and lower halves. For this example we assume that the lower 32-bits of the TimeBase is sufficient to compute intervals (~8.38 seconds). TimeBase values of adjacent events are subtracted to generate the intervals stored in the array.</p>
<p>The timespec format it a struct of unsigned int fields for seconds and microseconds. So the task is to convert the 512MHz TimeBase intervals to microseconds and then split the integer seconds and microseconds for the timespec.</p>
<p>First the TimeBase to microseconds conversion is simply (1000000 / 512000000) which reduces to (1 / 512) or divide by 512. The vector unit does not provide integer divide but luckily, 512 is a power of 2 and we can shift right. If we don't care for the niceties of rounding we can simply shift right 9 bits: </p><div class="fragment"><div class="line">tb_usec = <a class="code" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (*tb++, 9);</div>
</div><!-- fragment --><p> But if we decide that rounding is important we can leverage the Vector Average Unsigned Word (vavguw) instruction. Here we need to add 256 (512 / 2 = 256) to the timeBase interval before we shift right.</p>
<p>But we need to reverse engineer the vavguw operation to get the results we want. For each word, vavguw computes the sum of A and B plus 1, then shifts the 33-bit sum right 1 bit. We can effectively round by passing the rounding factor as the B operand to the vec_avg() built-in. But we get a +1 and 1 bit right shift for free. So in this case the rounding constant is 256-1 = 255. And we only need to shift an additional 8 bits to complete the conversion: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> rnd_512 =</div>
<div class="line">  { (256-1), (256-1), (256-1), (256-1) };</div>
<div class="line"><span class="comment">// Convert 512MHz timebase to microseconds with rounding.</span></div>
<div class="line">tmp = vec_avg (*tb++, rnd_512);</div>
<div class="line">tb_usec = <a class="code" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (tmp, 8);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>vec_avg() is an existing altivec.h generic built-in.</dd></dl>
<p>Next we need to separate TimeBase microseconds into the integer seconds and microseconds. Normally scalar codes would use integer divide/modulo by 1000000. Did I mention that the PowerISA vector unit does not have a integer divide operation?</p>
<p>Instead we can use the multiplicative inverse which is a scaled fixed point fraction calculated from the original divisor. This works nicely if the fixed radix point is just before the 32-bit fraction and we have a multiply high (<a class="el" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3" title="Vector Multiply High Unsigned Word.">vec_mulhuw()</a>) operation. Multiplying a 32-bit unsigned integer by a 32-bit unsigned fraction generates a 64-bit product with 32-bits above (integer) and below (fraction) the radix point. The high 32-bits of the product is the integer quotient.</p>
<p>It turns out that generating the multiplicative inverse can be tricky. To produce correct results over the full analysis, possible pre-scaling and post-shifting, and sometimes a corrective addition is necessary. Fortunately the mathematics are well understood and are commonly used in optimizing compilers. Even better, Henry Warren's book has a whole chapter on this topic. </p><dl class="section see"><dt>See also</dt><dd>"Hacker's Delight, 2nd Edition," Henry S. Warren, Jr, Addison Wesley, 2013. Chapter 10, Integer Division by Constants.</dd></dl>
<p>In the chapter above; </p><blockquote class="doxtable">
<p>Figure 10-2 Computing the magic number for unsigned division.</p>
</blockquote>
<p>provides a sample C function for generating the magic number (actually a struct containing; the magic multiplicative inverse, "add" indicator, and the shift amount.). For the divisor 1000000 this is { 1125899907, 0 , 18 }:</p><ul>
<li>the multiplier is 1125899907.</li>
<li>no corrective add of the dividend is required.</li>
<li>the final shift is 18-bits right.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mul_invs_1m =</div>
<div class="line">  { 1125899907, 1125899907, 1125899907, 1125899907 };</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> shift_1m = 18;</div>
<div class="line"> </div>
<div class="line">tmp = <a class="code" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">vec_mulhuw</a> (tb_usec, mul_invs_1m);</div>
<div class="line">seconds = <a class="code" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (tmp, shift_1m);</div>
</div><!-- fragment --><p> Now we need to compute the remainder to get microseconds. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> usec_sec =</div>
<div class="line">  { 1000000, 1000000, 1000000, 1000000 };</div>
<div class="line"> </div>
<div class="line">tmp = <a class="code" href="vec__int32__ppc_8h.html#ab3ea7653d4e60454b91d669e2b1bcfdf">vec_muluwm</a> (seconds, usec_sec);</div>
<div class="line">useconds = vec_sub (tb_usec, tmp);</div>
</div><!-- fragment --><p>Finally we need to merge the vectors of seconds and useconds into vectors of timespec. </p><div class="fragment"><div class="line">timespec1 = vec_mergeh (seconds, useconds);</div>
<div class="line">timespec2 = vec_mergel (seconds, useconds);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>vec_sub(), vec_mergeh(), and vec_mergel() are an existing altivec.h generic built-ins.</dd></dl>
<h2><a class="anchor" id="i32_example_0_1_0"></a>
Vectorized TimeBase conversion example</h2>
<p>Here is the complete vectorized TimeBase to timespec conversion example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">example_convert_timebase (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> *tb, <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> *timespec, <span class="keywordtype">int</span> n)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> rnd_512 =</div>
<div class="line">    { (256-1), (256-1), (256-1), (256-1) };</div>
<div class="line">  <span class="comment">// Magic numbers for multiplicative inverse to divide by 1,000,000</span></div>
<div class="line">  <span class="comment">// are 1125899907 and shift right 18 bits.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mul_invs_1m =</div>
<div class="line">    { 1125899907, 1125899907, 1125899907, 1125899907 };</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> shift_1m = 18;</div>
<div class="line">  <span class="comment">// Need const for microseconds/second to extract remainder.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> usec_sec =</div>
<div class="line">    { 1000000, 1000000, 1000000, 1000000 };</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> tmp, tb_usec, seconds, useconds;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> timespec1, timespec2;</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Convert 512MHz timebase to microseconds with rounding.</span></div>
<div class="line">      tmp = vec_avg (*tb++, rnd_512);</div>
<div class="line">      tb_usec = <a class="code" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (tmp, 8);</div>
<div class="line">      <span class="comment">// extract integer seconds from tb_usec.</span></div>
<div class="line">      tmp = <a class="code" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">vec_mulhuw</a> (tb_usec, mul_invs_1m);</div>
<div class="line">      seconds = <a class="code" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (tmp, shift_1m);</div>
<div class="line">      <span class="comment">// Extract remainder microseconds.</span></div>
<div class="line">      tmp = <a class="code" href="vec__int32__ppc_8h.html#ab3ea7653d4e60454b91d669e2b1bcfdf">vec_muluwm</a> (seconds, usec_sec);</div>
<div class="line">      useconds = vec_sub (tb_usec, tmp);</div>
<div class="line">      <span class="comment">// Use merge high/low to interleave seconds and useconds in timespec.</span></div>
<div class="line">      timespec1 = vec_mergeh (seconds, useconds);</div>
<div class="line">      timespec2 = vec_mergel (seconds, useconds);</div>
<div class="line">      <span class="comment">// Store timespec.</span></div>
<div class="line">      *timespec++ = timespec1;</div>
<div class="line">      *timespec++ = timespec2;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="int32_perf_0_0"></a>
Performance data.</h1>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a85ec15f292163e0e40e6faa5f4797367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ec15f292163e0e40e6faa5f4797367">&#9670;&nbsp;</a></span>vec_absduw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_absduw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Absolute Difference Unsigned Word. </p>
<p>Compute the absolute difference for each word. For each unsigned word, subtract VRB[i] from VRA[i] and return the absolute value of the difference.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>vector of 4 x unsigned words </td></tr>
    <tr><td class="paramname">vrb</td><td>vector of 4 x unsigned words </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the absolute differences. </dd></dl>

</div>
</div>
<a id="afbe65a777f2b75022ae584f76d0a2777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe65a777f2b75022ae584f76d0a2777">&#9670;&nbsp;</a></span>vec_clzw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_clzw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Count Leading Zeros word. </p>
<p>Count the number of leading '0' bits (0-32) within each word element of a 128-bit vector.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Count Leading Zeros Word instruction <b>vclzw</b>. Otherwise use sequence of pre 2.07 VMX instructions. SIMDized count leading zeros inspired by:</p>
<p>Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 5 Counting Bits, Figure 5-12.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 4 x 32-bit integer (words) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the Leading Zeros count for each word element. </dd></dl>

</div>
</div>
<a id="a43d8feaed351dfc1747ed1f3692040c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d8feaed351dfc1747ed1f3692040c1">&#9670;&nbsp;</a></span>vec_ctzw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_ctzw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Count Trailing Zeros word. </p>
<p>Count the number of trailing '0' bits (0-32) within each word element of a 128-bit vector.</p>
<p>For POWER9 (PowerISA 3.0B) or later use the Vector Count Trailing Zeros Word instruction <b>vctzw</b>. Otherwise use a sequence of pre ISA 3.0 VMX instructions. SIMDized count Trailing zeros inspired by:</p>
<p>Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 5 Counting Bits, Section 5-4.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-8 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 4 x 32-bit integer (words) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the Trailng Zeros count for each word element. </dd></dl>

</div>
</div>
<a id="a0d39dc4278a5e0711e9109746b23f2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d39dc4278a5e0711e9109746b23f2c7">&#9670;&nbsp;</a></span>vec_mrgahw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgahw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Algebraic High Words. </p>
<p>Merge only the high words from 4 x Algebraic doublewords across vectors vra and vrb. This effectively the Vector Merge Even Word operation that is not modified for endian.</p>
<p>For example merge the high 32-bits from 4 x 64-bit products as generated by vec_muleuw/vec_mulouw. This result is effectively a vector multiply high unsigned word.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned long. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the high words of the 4 x Algebraic doublewords across vra and vrb. </dd></dl>

</div>
</div>
<a id="a4107474cdf1907051de84ea063417911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4107474cdf1907051de84ea063417911">&#9670;&nbsp;</a></span>vec_mrgalw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgalw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector merge Algebraic low words. </p>
<p>Merge the arithmetic low words 4 x Algebraic doublewords across vectors vra and vrb. This is effectively the Vector Merge Odd Word operation that is not modified for endian.</p>
<p>For example merge the low 32-bits from 4 x 64-bit products as generated by vec_muleuw/vec_mulouw. This result is effectively a vector multiply low unsigned word (multiply unsigned word modulo).</p>
<dl class="section note"><dt>Note</dt><dd>This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned long. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the low words of the 4 x Algebraic doublewords across vra and vrb. </dd></dl>

</div>
</div>
<a id="ab67359d6f4003fcb7cca8ed1b64b7cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67359d6f4003fcb7cca8ed1b64b7cf4">&#9670;&nbsp;</a></span>vec_mrgew()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Even Words. </p>
<p>Merge the even word elements from the concatenation of 2 x vectors (vra and vrb).</p><ul>
<li>res[0] = vra[0];</li>
<li>res[1] = vrb[0];</li>
<li>res[2] = vra[2];</li>
<li>res[3] = vrb[2];</li>
</ul>
<p>The element numbering changes between big and little-endian environements. So the compiler and this implementation adjusts the generated code to reflect this.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the even words of vra and vrb. </dd></dl>

</div>
</div>
<a id="af10a13aa644282aa60dcbfbd8b02f0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10a13aa644282aa60dcbfbd8b02f0bc">&#9670;&nbsp;</a></span>vec_mrgow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Odd Words. </p>
<p>Merge the odd word elements from the concatenation of 2 x vectors (vra and vrb).</p><ul>
<li>res[0] = vra[1];</li>
<li>res[1] = vrb[1];</li>
<li>res[2] = vra[3];</li>
<li>res[3] = vrb[3];</li>
</ul>
<p>The element numbering changes between big and little-endian environements. So the compiler and this implementation adjusts the generated code to reflect this.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the even words of vra and vrb. </dd></dl>

</div>
</div>
<a id="add7b91bf6138d029d9d8cc57b0905f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7b91bf6138d029d9d8cc57b0905f1f">&#9670;&nbsp;</a></span>vec_mulesw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_mulesw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply even signed words. </p>
<p>Multiple the even words of two vector signed int values and return the signed long product of the even words.</p>
<p>For POWER8 and later we can use the vmulesw instruction. But for POWER7 and earlier we have to construct word multiplies from halfword multiplies. See <a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8" title="Vector multiply even unsigned words.">vec_muleuw()</a>.</p>
<p>Here we start with a unsigned vec_muleuw product, then correct the high 32-bits of the product to signed. Based on: Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 8 Multiplication, Section 8-3 High-Order Product Signed from/to Unsigned.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector signed long product of the even words of a and b. </dd></dl>

</div>
</div>
<a id="ac93f07d5ad73243db2771da83b50d6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93f07d5ad73243db2771da83b50d6d8">&#9670;&nbsp;</a></span>vec_muleuw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_muleuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply even unsigned words. </p>
<p>Multiple the even words of two vector unsigned int values and return the unsigned long product of the even words.</p>
<p>For POWER8 and later we can use the vmuleuw instruction. But for POWER7 and earlier we have to construct word multiplies from two halfword multiplies (vmuleuh and vmulouh). Then sum the partial products for the final doubleword results. This is complicated by the fact that vector add doubleword is not available for POWER7. So we need to construct the doubleword add from Vector Add Unsigned Word Modulo (vadduwm) and Vector Add and Write Carry-Out Unsigned Word (vaddcuw) with shift double quadword to reposition the low word carry and a final vadduwm to complete the carry propagation for the doubleword add.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long product of the even words of a and b. </dd></dl>

</div>
</div>
<a id="a316e9909abc24eb4f9b5d6d29fe64185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316e9909abc24eb4f9b5d6d29fe64185">&#9670;&nbsp;</a></span>vec_mulhsw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vec_mulhsw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Signed Word. </p>
<p>Multiple the corresponding word elements of two vector signed int values and return the high order 32-bits, for each 64-bit product element.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">9 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">9 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the high order 32-bits of the product of the word elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="a094c6adb04c1515361426ad58b0fdbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094c6adb04c1515361426ad58b0fdbb3">&#9670;&nbsp;</a></span>vec_mulhuw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mulhuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Unsigned Word. </p>
<p>Multiple the corresponding word elements of two vector unsigned int values and return the high order 32-bits, from each 64-bit product.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">9 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">9 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This operation can be used to effectively perform a divide by multiplying by the scaled multiplicative inverse (reciprocal).</dd></dl>
<p>Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 10, Integer Division by Constants.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the high order 32-bits of the signed product of the word elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="a415942bd7b8183634e44e56b6a40101b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415942bd7b8183634e44e56b6a40101b">&#9670;&nbsp;</a></span>vec_mulosw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_mulosw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply odd signed words. </p>
<p>Multiple the odd words of two vector signed int values and return the signed long product of the odd words.</p>
<p>For POWER8 and later we can use the vmulosw instruction. But for POWER7 and earlier we have to construct word multiplies from halfword multiplies. See <a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d" title="Vector multiply odd unsigned words.">vec_mulouw()</a>.</p>
<p>Here we start with a unsigned vec_mulouw product, then correct the high-order 32-bits of the product to signed. Based on: Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 8 Multiplication, Section 8-3 High-Order Product Signed from/to Unsigned.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector signed long product of the odd words of a and b. </dd></dl>

</div>
</div>
<a id="a3ca45c65b9627abfc493d4ad500a961d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca45c65b9627abfc493d4ad500a961d">&#9670;&nbsp;</a></span>vec_mulouw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mulouw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply odd unsigned words. </p>
<p>Multiple the odd words of two vector unsigned int values and return the unsigned long product of the odd words.</p>
<p>For POWER8 and later we can use the vmulouw instruction. But for POWER7 and earlier we have to construct word multiplies from two halfword multiplies (vmuleuh and vmulouh). Then sum the partial products for the final doubleword results. This is complicated by the fact that vector add doubleword is not available for POWER7. So we need to construct the doubleword add from Vector Add Unsigned Word Modulo (vadduwm) and Vector Add and Write Carry-Out Unsigned Word (vaddcuw) with shift double quadword to reposition the low word carry and a final vadduwm to complete the carry propagation for the doubleword add.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long product of the odd words of a and b. </dd></dl>

</div>
</div>
<a id="ab3ea7653d4e60454b91d669e2b1bcfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ea7653d4e60454b91d669e2b1bcfdf">&#9670;&nbsp;</a></span>vec_muluwm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_muluwm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Unsigned Word Modulo. </p>
<p>Multiple the corresponding word elements of two vector unsigned int values and return the low order 32-bits of the 64-bit product for each element.</p>
<dl class="section note"><dt>Note</dt><dd>vec_muluwm can be used for unsigned or signed integers. It is the vector equivalent of Multiply Low Word.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the low order 32-bits of the unsigned product of the word elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="acb5b81dc628ca80e079a86515e391023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5b81dc628ca80e079a86515e391023">&#9670;&nbsp;</a></span>vec_popcntw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_popcntw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Population Count word. </p>
<p>Count the number of '1' bits (0-32) within each word element of a 128-bit vector.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Population Count Word instruction. Otherwise use the pveclib vec_popcntb to count each byte then sum across with Vector Sum across Quarter Unsigned Byte Saturate.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 4 x 32-bit integer (words) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the population count for each word element. </dd></dl>

</div>
</div>
<a id="ae4d2c7192202e70f52997ab743418a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d2c7192202e70f52997ab743418a77">&#9670;&nbsp;</a></span>vec_revbw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_revbw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>byte reverse each word of a vector unsigned int. </p>
<p>For each word of the input vector, reverse the order of bytes / octets within the word.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector with the bytes of each word reversed. </dd></dl>

</div>
</div>
<a id="aa713f51a760e1175a00d645dd4b43ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa713f51a760e1175a00d645dd4b43ebc">&#9670;&nbsp;</a></span>vec_setb_sw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a> vec_setb_sw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Set Bool from Signed Word. </p>
<p>For each word, propagate the sign bit to all 32-bits of that word. The result is vector bool int reflecting the sign bit of each 32-bit word.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-4 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2-5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>Vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector bool int reflecting the sign bits of each word. </dd></dl>

</div>
</div>
<a id="a500924c8925b336d49b6a5d4307fe14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500924c8925b336d49b6a5d4307fe14c">&#9670;&nbsp;</a></span>vec_slwi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_slwi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift left Word Immediate. </p>
<p>Shift left each word element [0-3], 0-31 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-31. A shift count of 0 returns the original value of vra. Shift counts greater then 31 bits return zero.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned int, shifted left shb bits. </dd></dl>

</div>
</div>
<a id="aefb4872afdd52b5ba965856c7e1a58ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb4872afdd52b5ba965856c7e1a58ad">&#9670;&nbsp;</a></span>vec_srawi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vec_srawi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Algebraic Word Immediate. </p>
<p>Shift Right Algebraic each word element [0-3], 0-31 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-31. A shift count of 0 returns the original value of vra. Shift counts greater then 31 bits return the sign bit propagated to each bit of each element.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector signed int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector signed int, shifted right shb bits. </dd></dl>

</div>
</div>
<a id="af73a97260ce07b46031e2c8560a5320b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73a97260ce07b46031e2c8560a5320b">&#9670;&nbsp;</a></span>vec_srwi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_srwi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Word Immediate. </p>
<p>Shift right each word element [0-3], 0-31 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-31. A shift count of 0 returns the original value of vra. Shift counts greater then 31 bits return zero.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned char. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned int, shifted right shb bits. </dd></dl>

</div>
</div>
<a id="aedb1891a74721a4d3e997af85544cdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb1891a74721a4d3e997af85544cdf6">&#9670;&nbsp;</a></span>vec_vgl4wso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_vgl4wso </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load 4 Words from scalar Offsets. </p>
<p>For each scalar offset[0,1,2,3], load the word from the effective address formed by *(char*)array+offset[0-3]. Merge resulting word elements [0,1,2,3] and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">11 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">offset0</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset1</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset2</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset3</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector word containing word elements [0-3] loaded from *(char*)array+offset[0-3]. </dd></dl>

</div>
</div>
<a id="accce3d13dc8346f05a56c587e2a21432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accce3d13dc8346f05a56c587e2a21432">&#9670;&nbsp;</a></span>vec_vgl4wwo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_vgl4wwo </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load 4 Words from Vector Word Offsets. </p>
<p>For each signed word element [i] of vra, load the word element at *(char*)array+vra[i]. Merge those word elements and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">15 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector word containing word elements [0-3], each loaded from *(char*)array+vra[0-3]. </dd></dl>

</div>
</div>
<a id="aaba8cd6ad53df6d25c8d41a84f42c21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba8cd6ad53df6d25c8d41a84f42c21d">&#9670;&nbsp;</a></span>vec_vgl4wwsx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_vgl4wwsx </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load 4 Words from Vector Word Scaled Indexes. </p>
<p>For each signed word element [i] of vra, load the word element at array[vra[i] &lt;&lt; scale]. Merge those word elements and return the resulting vector.</p>
<dl class="section note"><dt>Note</dt><dd>Signed word indexes are expanded (unpacked) to doublewords before shifting left 2+scale bits. This converts each index to an 64-bit offset for effective address calculation.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">16-25 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">18-27 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) indexes. </td></tr>
    <tr><td class="paramname">scale</td><td>8-bit integer. Indexes are multiplying by 2<sup>scale</sup>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector word containing word elements [0-3] each loaded from array[vra[0-3] &lt;&lt; scale]. </dd></dl>

</div>
</div>
<a id="ab18942f74154258bb0929be4597638f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18942f74154258bb0929be4597638f0">&#9670;&nbsp;</a></span>vec_vgl4wwx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_vgl4wwx </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load 4 Words from Vector Word Indexes. </p>
<p>For word element [i] of vra, load the word element at array[vra[i]]. Merge those word elements and return the resulting vector.</p>
<dl class="section note"><dt>Note</dt><dd>Signed word indexes are expanded (unpacked) to doublewords before shifting left 2 bits. This converts each index to an 64-bit offset for effective address calculation.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">16-25 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">18-27 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) indexes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector word containing word elements [0-3], each loaded from array[vra[0-3]]. </dd></dl>

</div>
</div>
<a id="a8f05ef2940a8a9ba515895f5dd72739e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f05ef2940a8a9ba515895f5dd72739e">&#9670;&nbsp;</a></span>vec_vglswdo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_vglswdo </td>
          <td>(</td>
          <td class="paramtype">signed int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Signed Words from Vector Doubleword Offsets. </p>
<p>For each doubleword element [i] of vra, load the sign extended word element at *(char*)array+vra[i]. Merge doubleword elements [0,1] and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">11 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of signed words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword (64-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector doubleword elements [0,1] loaded from sign extended words at *(char*)array+vra[0,1]. </dd></dl>

</div>
</div>
<a id="a229fefaa88337ca7d376d37e83a44788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229fefaa88337ca7d376d37e83a44788">&#9670;&nbsp;</a></span>vec_vglswdsx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_vglswdsx </td>
          <td>(</td>
          <td class="paramtype">signed int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Signed Words from Vector Doubleword Scaled Indexes. </p>
<p>For each doubleword element [i] of vra, load the sign extended word element at array[vra[i] &lt;&lt; scale)]. Merge doubleword elements [0,1] and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">13-22 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of signed words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword indexes from &amp;array. </td></tr>
    <tr><td class="paramname">scale</td><td>8-bit integer. Indexes are multiplying by 2<sup>scale</sup>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector doubleword elements [0,1] loaded from the sign extended words at array[vra[0,1]&lt;&lt;scale]. </dd></dl>

</div>
</div>
<a id="a19d46e364500751fef08efbb16a128ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d46e364500751fef08efbb16a128ee">&#9670;&nbsp;</a></span>vec_vglswdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_vglswdx </td>
          <td>(</td>
          <td class="paramtype">signed int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Signed Words from Vector Doubleword Indexes. </p>
<p>For each doubleword element [i] of vra, load the sign extended word element at array[vra[i]]. Merge doubleword elements [0,1] and return the resulting vector.</p>
<dl class="section note"><dt>Note</dt><dd>As effective address calculation is modulo 64-bits, signed or unsigned doubleword offsets are equivalent.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">13-22 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of signed words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword indexes from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector doubleword elements [0,1] loaded from sign extended words at array[vra[0,1]]. </dd></dl>

</div>
</div>
<a id="aeab36f02d6b29264e7f40a47b9ea7d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab36f02d6b29264e7f40a47b9ea7d9c">&#9670;&nbsp;</a></span>vec_vglswso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_vglswso </td>
          <td>(</td>
          <td class="paramtype">signed int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Signed Word from Scalar Offsets. </p>
<p>For each scalar offset[0|1], load the signed word (sign extended) from the effective address formed by *(char*)array+offset[0|1]. Merge resulting doubleword elements and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">8 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of words. </td></tr>
    <tr><td class="paramname">offset0</td><td>Scalar (64-bit) byte offsets from &amp;array. </td></tr>
    <tr><td class="paramname">offset1</td><td>Scalar (64-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector doubleword elements [0,1] loaded from sign extend words at *(char*)array+offset[0,1]. </dd></dl>

</div>
</div>
<a id="a947ca10d28d0839d02bbc3c33c0f5ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947ca10d28d0839d02bbc3c33c0f5ef6">&#9670;&nbsp;</a></span>vec_vgluwdo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vgluwdo </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Unsigned Words from Vector Doubleword Offsets. </p>
<p>For each doubleword element [0,1] of vra, load the zero extended word element at *(char*)array+vra[0,1]. Merge those doubleword elements [0,1] and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">11 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of unsigned words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword (64-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector doubleword elements [0,1] loaded from zero extended words at *(char*)array+vra[0,1]. </dd></dl>

</div>
</div>
<a id="a179b8f8813c3c0d21e0281c570c2d7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179b8f8813c3c0d21e0281c570c2d7cb">&#9670;&nbsp;</a></span>vec_vgluwdsx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vgluwdsx </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Unsigned Words from Vector Doubleword Scaled Indexes. </p>
<p>For each doubleword element [0,1] of vra, load the zero extended word element at array[vra[0,1] &lt;&lt; scale)]. Merge doubleword elements [0,1] and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">13-22 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of unsigned words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword indexes from &amp;array. </td></tr>
    <tr><td class="paramname">scale</td><td>8-bit integer. Indexes are multiplying by 2<sup>scale</sup>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector doubleword elements [0,1] loaded from zero extended words at array[vra[0,1]&lt;&lt;scale]. </dd></dl>

</div>
</div>
<a id="a52ba8ecf5b44a6f43edb9f1be9c6e5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ba8ecf5b44a6f43edb9f1be9c6e5af">&#9670;&nbsp;</a></span>vec_vgluwdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vgluwdx </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Unsigned Words from Vector Doubleword Indexes. </p>
<p>For each doubleword element [0,1] of vra, load the zero extended word element at array[vra[0,1]]. Merge those doubleword elements [0,1] and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">13-22 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of unsigned words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword indexes from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector doubleword [0,1] loaded from zero extended words at array[vra[0,1]]. </dd></dl>

</div>
</div>
<a id="a2ace130b253389747902768a5fa029d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ace130b253389747902768a5fa029d5">&#9670;&nbsp;</a></span>vec_vgluwso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vgluwso </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Unsigned Word from Scalar Offsets. </p>
<p>For each scalar offset[0,1], load the unsigned word (zero extended) from the effective address formed by *(char*)array+offset[0,1] Merge resulting doubleword [0,1] elements and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">8 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of words. </td></tr>
    <tr><td class="paramname">offset0</td><td>Scalar (64-bit) byte offsets from &amp;array. </td></tr>
    <tr><td class="paramname">offset1</td><td>Scalar (64-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector doubleword elements [0,1] loaded from zero extened words at *(char*)array+offset[0,1]. </dd></dl>

</div>
</div>
<a id="a9890d6fcb05c52af03d2b6fc3f516aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9890d6fcb05c52af03d2b6fc3f516aeb">&#9670;&nbsp;</a></span>vec_vlxsiwax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_vlxsiwax </td>
          <td>(</td>
          <td class="paramtype">const signed long long&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const signed int *&#160;</td>
          <td class="paramname"><em>rb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Load Scalar Integer Word Algebraic Indexed. </p>
<p>Load the left most doubleword of vector <b>xt</b> as a scalar sign extended word from the effective address formed by <b>rb+ra</b>. The operand <b>rb</b> is a pointer to an array of words. The operand <b>ra</b> is a doubleword integer byte offset from <b>rb</b>. The result <b>xt</b> is returned as a vi64_t vector. For best performance <b>rb</b> and <b>ra</b> should be word aligned (integer multiple of 4).</p>
<dl class="section note"><dt>Note</dt><dd>The right most doubleword of vector <b>xt</b> is left <em>undefined</em> by this operation.</dd></dl>
<p>This operation is an alternate form of Vector Load Element (vec_lde), with the added simplification that data is always left justified in the vector. Another advantage for Power8 and later, the lxsiwax instruction combines load with sign extend word and can load directly into any of the 64 VSRs. Both simplify merging elements for gather operations.</p>
<dl class="section note"><dt>Note</dt><dd>The lxsiwax instruction was introduced in PowerISA 2.07 (POWER8). Power7 and earlier will use lvewx.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ra</td><td>const doubleword index (offset/displacement). </td></tr>
    <tr><td class="paramname">rb</td><td>const word pointer to an array of integers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The word stored at (ra + rb) is sign extended and loaded into vector doubleword element 0. Element 1 is undefined. </dd></dl>

</div>
</div>
<a id="a629c4f5c26758f8eb6ca8f21d9def4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629c4f5c26758f8eb6ca8f21d9def4f8">&#9670;&nbsp;</a></span>vec_vlxsiwzx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vlxsiwzx </td>
          <td>(</td>
          <td class="paramtype">const signed long long&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>rb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Load Scalar Integer Word and Zero Indexed. </p>
<p>Load the left most doubleword of vector <b>xt</b> as a scalar unsigned word (zero extended to doubleword) from the effective address formed by <b>rb+ra</b>. The operand <b>rb</b> is a pointer to an array of words. The operand <b>ra</b> is a doubleword integer byte offset from <b>rb</b>. The result <b>xt</b> is returned as a vui64_t vector. For best performance <b>rb</b> and <b>ra</b> should be word aligned (integer multiple of 4).</p>
<dl class="section note"><dt>Note</dt><dd>the right most doubleword of vector <b>xt</b> is left <em>undefined</em> by this operation.</dd></dl>
<p>This operation is an alternate form of Vector Load Element (vec_lde), with the added simplification that data is always left justified in the vector. Another advantage for Power8 and later, the lxsiwzx instruction combines load with zero extend word and can load directly into any of the 64 VSRs. Both simplify merging elements for gather operations.</p>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
The lxsiwzx instruction was introduced in PowerISA 2.07 (POWER8). Power7 and earlier will use lvewx.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ra</td><td>const doubleword index (offset/displacement). </td></tr>
    <tr><td class="paramname">rb</td><td>const word pointer to an array of integers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The word stored at (ra + rb) is zero extended and loaded into vector doubleword element 0. Element 1 is undefined. </dd></dl>

</div>
</div>
<a id="a1b046a56d566ec2ea351042fd9dd11de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b046a56d566ec2ea351042fd9dd11de">&#9670;&nbsp;</a></span>vec_vmadd2euw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmadd2euw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add2 Even Unsigned Words. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int64__ppc_8h.html#a1b046a56d566ec2ea351042fd9dd11de">vec_int64_ppc::h::vec_vmadd2euw()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo.">vec_addudm()</a>. </dd></dl>

</div>
</div>
<a id="a40ab00ed413c1aa1a8148cd9981235bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ab00ed413c1aa1a8148cd9981235bf">&#9670;&nbsp;</a></span>vec_vmadd2ouw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmadd2ouw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add2 Odd Unsigned Words. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int64__ppc_8h.html#a40ab00ed413c1aa1a8148cd9981235bf">vec_int64_ppc::h::vec_vmadd2ouw()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo.">vec_addudm()</a>. </dd></dl>

</div>
</div>
<a id="a1e20bdd1df7e3e49dca06d5512ada84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e20bdd1df7e3e49dca06d5512ada84b">&#9670;&nbsp;</a></span>vec_vmaddeuw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmaddeuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add Even Unsigned Words. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int64__ppc_8h.html#a1e20bdd1df7e3e49dca06d5512ada84b">vec_int64_ppc::h::vec_vmaddeuw()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo.">vec_addudm()</a>. </dd></dl>

</div>
</div>
<a id="a32acead723b7867ff4c9f8be9bb708ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32acead723b7867ff4c9f8be9bb708ca">&#9670;&nbsp;</a></span>vec_vmaddouw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmaddouw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add Odd Unsigned Words. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int64__ppc_8h.html#a32acead723b7867ff4c9f8be9bb708ca">vec_int64_ppc::h::vec_vmaddouw()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo.">vec_addudm()</a>. </dd></dl>

</div>
</div>
<a id="a0bb37f8c3bb75090db08ab0981249ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb37f8c3bb75090db08ab0981249ae7">&#9670;&nbsp;</a></span>vec_vmsumuwm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmsumuwm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Sum Unsigned Word Modulo. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int64__ppc_8h.html#a431720fd713485fcb13963cdcb89ac76">vec_int64_ppc::h::vec_vmsumuwm()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo.">vec_addudm()</a>. </dd></dl>

</div>
</div>
<a id="ae30f226bd27241513f0611b50967a080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30f226bd27241513f0611b50967a080">&#9670;&nbsp;</a></span>vec_vmuleuw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmuleuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Even Unsigned words. </p>
<p>Multiply the even words of two vector unsigned int values and return the unsigned long product of the even words.</p>
<p>For POWER8 and later we can use the vmuleuw instruction. But for POWER7 and earlier we have to construct word multiplies from two halfword multiplies (vmuleuh and vmulouh). Then sum the partial products for the final doubleword results. This is complicated by the fact that vector add doubleword is not available for POWER7. So we need to construct the doubleword add from Vector Add Unsigned Word Modulo (vadduwm) and Vector Add and Write Carry-Out Unsigned Word (vaddcuw) with shift double quadword to reposition the low word carry and a final vadduwm to complete the carry propagation for the doubleword add.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long product of the even words of a and b. </dd></dl>

</div>
</div>
<a id="ae52349ced57857d20fb5e06b1b09cc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52349ced57857d20fb5e06b1b09cc05">&#9670;&nbsp;</a></span>vec_vmulouw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmulouw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Odd Unsigned Words. </p>
<p>Multiply the odd words of two vector unsigned int values and return the unsigned long product of the odd words.</p>
<p>For POWER8 and later we can use the vmulouw instruction. But for POWER7 and earlier we have to construct word multiplies from two halfword multiplies (vmuleuh and vmulouh). Then sum the partial products for the final doubleword results. This is complicated by the fact that vector add doubleword is not available for POWER7. So we need to construct the doubleword add from Vector Add Unsigned Word Modulo (vadduwm) and Vector Add and Write Carry-Out Unsigned Word (vaddcuw) with shift double quadword to reposition the low word carry and a final vadduwm to complete the carry propagation for the doubleword add.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long product of the odd words of a and b. </dd></dl>

</div>
</div>
<a id="aedabb123d258fd438bda778262d5b33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedabb123d258fd438bda778262d5b33f">&#9670;&nbsp;</a></span>vec_vsst4wso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsst4wso </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store 4 words to Scalar Offsets. </p>
<p>For each word element [i] of xs, store the element xs[i] at *(char*)array+offset[i].</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">4 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector integer word elements to scatter store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">offset0</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset1</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset2</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset3</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c8284f1aee85e266219c6bd02b428a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8284f1aee85e266219c6bd02b428a4">&#9670;&nbsp;</a></span>vec_vsst4wwo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsst4wwo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store 4 words to Vector Word Offsets. </p>
<p>For each word element [i] of xs, store the element xs[i] at *(char*)array+vra[i].</p>
<dl class="section note"><dt>Note</dt><dd>Signed word offsets are expanded (unpacked) to doublewords before transfer to GRPs for effective address calculation.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector integer word elements to scatter store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b82ded6af003670f3e45b5fcd2029d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b82ded6af003670f3e45b5fcd2029d4">&#9670;&nbsp;</a></span>vec_vsst4wwsx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsst4wwsx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store 4 words to Vector Word Indexes. </p>
<p>For each word element [i] of xs, store the element xs[i] at *(char*)array[vra[i]&lt;&lt;scale].</p>
<dl class="section note"><dt>Note</dt><dd>Signed word indexes are expanded (unpacked) to doublewords before shifting left (2+scale) bits before transfer to GRPs for effective address calculation. This converts each index to an 64-bit offset.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12-21 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">15-24 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector integer word elements to scatter store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) indexes from array. </td></tr>
    <tr><td class="paramname">scale</td><td>8-bit integer. Indexes are multiplying by 2<sup>scale</sup>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a602707a2b979bbb6964c8940b3efd7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602707a2b979bbb6964c8940b3efd7aa">&#9670;&nbsp;</a></span>vec_vsst4wwx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsst4wwx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store 4 words to Vector Word Indexes. </p>
<p>For each word element [i] of xs, store the element xs[i] at *(char*)array[vra[i]].</p>
<dl class="section note"><dt>Note</dt><dd>Signed word indexes are expanded (unpacked) to doublewords before shifting left 2 bits. This converts each index to an 64-bit offset for effective address calculation.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12-21 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">15-24 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector doubleword elements to scatter store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) indexes from array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adad8cd35dc45feabf51aec9ee6abc9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad8cd35dc45feabf51aec9ee6abc9f5">&#9670;&nbsp;</a></span>vec_vsstwdo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstwdo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Words to Vector Doubleword Offsets. </p>
<p>For each doubleword element [i] of vra, Store the low order word element xs[i+1] at *(char*)array+offset[0|1].</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">9 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector doubleword elements to scatter store low order words of each doubleword. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword (64-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4975a4d756f76a89fbb17c0f731c5e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4975a4d756f76a89fbb17c0f731c5e7b">&#9670;&nbsp;</a></span>vec_vsstwdsx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstwdsx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Words to Vector Doubleword Scaled Indexes. </p>
<p>For each doubleword element [i] of vra, Store the low order word element xs[i+1] at array[vra[i]&lt;&lt;scale].</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector doubleword elements to scatter store low order words of each doubleword. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword (64-bit) indexes from &amp;array. </td></tr>
    <tr><td class="paramname">scale</td><td>8-bit integer. Indexes are multiplying by 2<sup>scale</sup>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb70258df78db91bb28686f0fc6ed045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb70258df78db91bb28686f0fc6ed045">&#9670;&nbsp;</a></span>vec_vsstwdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstwdx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Words to Vector Doubleword Indexes. </p>
<p>For each doubleword element [i] of vra, Store the low order word element xs[i+1] at array[vra[i]].</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector doubleword elements to scatter store low order words of each doubleword. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword (64-bit) indexes from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d0c9b011e0062ae7673443f9560961e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0c9b011e0062ae7673443f9560961e">&#9670;&nbsp;</a></span>vec_vsstwso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstwso </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Words to Scalar Offsets. </p>
<p>For each doubleword element [i] of vra, Store the low order word element xs[i+1] at *(char*)array+offset[0|1].</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector doubleword elements to scatter store low order words of each doubleword. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">offset0</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset1</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecd395b358951d46fa96abf19974dd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd395b358951d46fa96abf19974dd15">&#9670;&nbsp;</a></span>vec_vstxsiwx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vstxsiwx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const signed long long&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>rb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Store Scalar Integer Word Indexed. </p>
<p>Stores word element 1 of vector <b>xs</b> as a scalar word at the effective address formed by <b>rb+ra</b>. The operand <b>rb</b> is a pointer to an array of integer words. The operand <b>ra</b> is a doubleword integer byte offset from <b>rb</b>. For best performance <b>rb</b> and <b>ra</b> should be word aligned (integer multiple of 4).</p>
<p>This operation is an alternate form of vector store element (vec_ste), with the added simplification that data is always left justified in the vector. Another advantage for Power8 and later, the stxsiwx instruction can load directly into any of the 64 VSRs. Both simplify scatter operations.</p>
<dl class="section note"><dt>Note</dt><dd>The stxsiwx instruction was introduced in PowerISA 2.07 (POWER8). Power7 and earlier will use stvewx.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">0 - 2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">0 - 2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>vector doubleword element 0 to be stored. </td></tr>
    <tr><td class="paramname">ra</td><td>const doubleword index (offset/displacement). </td></tr>
    <tr><td class="paramname">rb</td><td>const doubleword pointer to an array of doubles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2c88cebf964ac77e5022f22a3651ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c88cebf964ac77e5022f22a3651ba7">&#9670;&nbsp;</a></span>vec_vsum2sw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vec_vsum2sw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Sum-across Half Signed Word Saturate. </p>
<p>Sum across adjacent signed words within doublewords from <em>vra</em> and word addends from <em>vrb</em>. This is effectively the vec_sum2s built-in operation (vsum2sws instruction) without the endian sensitive modifications mandated by the ABI.</p>
<p>This is useful for computing the final doubleword counts for operations like population count and count leading/trailing zeros. These results are often used as inputs to shift operations that require shift counts in bits 58:63 of the doubleword element (word elements 1 and 3).</p>
<p>For vec_sum2s and little endian the ABI mandates that the addend words from vrb be from little endian word elements 1 and 3 (vector element 0 and 2) be used for the sum. The ABI also mandates that saturated word sum results are are in little endian elements 1 and 3 (vector element 0 and 2). This requires a 3 instruction dependent sequence to precondition vrb and and rotate the vsum2sws result to match little endian element numbering. This adds 4 (6 for POWER9) cycles latency.</p>
<p>This also leaves the sums in bits 26:31 of the doubleword element and out of position for doubleword shift/rotate. This in turn requires an additional corrective shift/rotate before using the sums. Or use this operation instead of vec_sum2s.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>Vector signed int as adjcent words within doublewords. </td></tr>
    <tr><td class="paramname">vrb</td><td>Vector signed int where odd words are summed with adjacent words from vra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector signed int with even words set to 0 and odd words containing the word sums within doublewords. </dd></dl>

</div>
</div>
<a id="a2a3b69b0eec926af6a6625767f9f0bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3b69b0eec926af6a6625767f9f0bd5">&#9670;&nbsp;</a></span>vec_vsumsw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vec_vsumsw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Sum-across Signed Word Saturate. </p>
<p>Sum across the 4 signed words from <em>vra</em> and word element 3 from <em>vrb</em>. This is effectively the vec_sums built-in operation (vsumsws instruction) without the endian sensitive modifications mandated by the ABI.</p>
<p>This is useful for computing the final quadword counts for operations like population count and count leading/trailing zeros. These results are often used as inputs to shift operations that require shift counts in bits 121:127 of the quadword (word element 3).</p>
<p>For vec_sums and little endian the ABI mandates that the addend word from vrb be from little endian word elements 3 (vector element 0) be used for the sum. The ABI also mandates that saturated word sum results are are in little endian elements 3 (vector element 0). This requires a 3 instruction dependent sequence to precondition vrb and and rotate the vsumsws result to match little endian element numbering. This adds 4 (6 for POWER9) cycles latency.</p>
<p>This also leaves the sums in bits 25:31 of the quadword and out of position for quadword shift/rotate. This in turn requires an additional corrective shift/rotate before using the sums. Or use this operation instead of vec_sums.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>Vector signed int as words within quadword. </td></tr>
    <tr><td class="paramname">vrb</td><td>Vector signed int where word element 3 is summed with words from vra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector signed int with words 0-2 set to 0 and word element 3 containing the word sums. </dd></dl>

</div>
</div>
<a id="a3ce8dca3fa26586bf511650af3e19a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce8dca3fa26586bf511650af3e19a76">&#9670;&nbsp;</a></span>vec_vupkhsw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_vupkhsw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Unpack High Signed Word. </p>
<p>From the word source in vra. For each integer word [i] from 0 to 1, sign extend to 64-bit and place in doubleword element [i] of the result vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This operation is the equivalent of the generic vec_unpackh for type vector signed int. However vec_unpackh (for this type) is not available for _ARCH_PWR7 and earlier versions of GCC. This PVECLIB operation is available to both. </dd>
<dd>
Use vec_vupkhsw naming but only if the compiler does not define it in &lt;altivec.h&gt;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 4 x signed integers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector treated as 2 x signed long long integers. </dd></dl>

</div>
</div>
<a id="a804a352598f61e47b191df7cc769f80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804a352598f61e47b191df7cc769f80f">&#9670;&nbsp;</a></span>vec_vupkhuw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vupkhuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Unpack High Unsigned Word. </p>
<p>From the word source in vra. For each integer word [i] from 0 to 1, zero extend to 64-bit and place in doubleword element [i] of the result vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-4 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2-4 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>vec_vupkhuw does not exist in &lt;altivec.h&gt; nor as an instruction is the PowerISA. But it is easy to construct using vec_mergeh and a zero vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 4 x unsigned integers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector treated as 2 x unsigned long long integers. </dd></dl>

</div>
</div>
<a id="aab93fbc9683c31e32d93966f1a65d786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab93fbc9683c31e32d93966f1a65d786">&#9670;&nbsp;</a></span>vec_vupklsw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_vupklsw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Unpack Low Signed Word. </p>
<p>From the word source in vra. For each integer word [i+2] from 0 to 1 (words 2 and 3), sign extend to 64-bit and place in doubleword element [i] of the result vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Use vec_vupkhsw naming but only if the compiler does not define it in &lt;altivec.h&gt;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 4 x signed integers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector treated as 2 x signed long long integers. </dd></dl>

</div>
</div>
<a id="a9f3791b0177b07e467d80a466d13671f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3791b0177b07e467d80a466d13671f">&#9670;&nbsp;</a></span>vec_vupkluw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vupkluw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Unpack Low Unsigned Word. </p>
<p>From the word source in vra. For each integer word [i+2] from 0 to 1 (words 2 and 3), zero extend to 64-bit and place in doubleword element [i] of the result vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-4 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2-4 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>vec_vupkluw does not exist in &lt;altivec.h&gt; nor as an instruction is the PowerISA. But it is easy to construct using vec_mergeh and a zero vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 4 x unsigned integers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector treated as 2 x unsigned long long integers. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="avec__int32__ppc_8h_html_a0d39dc4278a5e0711e9109746b23f2c7"><div class="ttname"><a href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a></div><div class="ttdeci">static vui32_t vec_mrgahw(vui64_t vra, vui64_t vrb)</div><div class="ttdoc">Vector Merge Algebraic High Words.</div><div class="ttdef"><b>Definition:</b> vec_int32_ppc.h:653</div></div>
<div class="ttc" id="avec__int32__ppc_8h_html_ac93f07d5ad73243db2771da83b50d6d8"><div class="ttname"><a href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a></div><div class="ttdeci">static vui64_t vec_muleuw(vui32_t a, vui32_t b)</div><div class="ttdoc">Vector multiply even unsigned words.</div><div class="ttdef"><b>Definition:</b> vec_int32_ppc.h:1007</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a7e03d3eaeafea2c6613233fd58f98ec1"><div class="ttname"><a href="vec__common__ppc_8h.html#a7e03d3eaeafea2c6613233fd58f98ec1">CONST_VINT32_W</a></div><div class="ttdeci">#define CONST_VINT32_W(__w0, __w1, __w2, __w3)</div><div class="ttdoc">Arrange elements of word initializer in high-&gt;low order.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:306</div></div>
<div class="ttc" id="avec__int32__ppc_8h_html_a094c6adb04c1515361426ad58b0fdbb3"><div class="ttname"><a href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">vec_mulhuw</a></div><div class="ttdeci">static vui32_t vec_mulhuw(vui32_t vra, vui32_t vrb)</div><div class="ttdoc">Vector Multiply High Unsigned Word.</div><div class="ttdef"><b>Definition:</b> vec_int32_ppc.h:1103</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a52a773b6353c69a546bdc2e8686a50ec"><div class="ttname"><a href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div><div class="ttdeci">__vector unsigned long long vui64_t</div><div class="ttdoc">vector of 64-bit unsigned long long elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:208</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_aed458e4755a6589049b936cf9f24f6f8"><div class="ttname"><a href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a></div><div class="ttdeci">__vector unsigned char vui8_t</div><div class="ttdoc">vector of 8-bit unsigned char elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:202</div></div>
<div class="ttc" id="avec__int32__ppc_8h_html_af73a97260ce07b46031e2c8560a5320b"><div class="ttname"><a href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a></div><div class="ttdeci">static vui32_t vec_srwi(vui32_t vra, const unsigned int shb)</div><div class="ttdoc">Vector Shift Right Word Immediate.</div><div class="ttdef"><b>Definition:</b> vec_int32_ppc.h:1405</div></div>
<div class="ttc" id="avec__int32__ppc_8h_html_ab3ea7653d4e60454b91d669e2b1bcfdf"><div class="ttname"><a href="vec__int32__ppc_8h.html#ab3ea7653d4e60454b91d669e2b1bcfdf">vec_muluwm</a></div><div class="ttdeci">static vui32_t vec_muluwm(vui32_t a, vui32_t b)</div><div class="ttdoc">Vector Multiply Unsigned Word Modulo.</div><div class="ttdef"><b>Definition:</b> vec_int32_ppc.h:1132</div></div>
<div class="ttc" id="avec__int32__ppc_8h_html_a3ca45c65b9627abfc493d4ad500a961d"><div class="ttname"><a href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a></div><div class="ttdeci">static vui64_t vec_mulouw(vui32_t a, vui32_t b)</div><div class="ttdoc">Vector multiply odd unsigned words.</div><div class="ttdef"><b>Definition:</b> vec_int32_ppc.h:1043</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a2ff4a776536870e01b7c9e454586544b"><div class="ttname"><a href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div><div class="ttdeci">__vector unsigned int vui32_t</div><div class="ttdoc">vector of 32-bit unsigned int elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:206</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 21 2021 17:24:16 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
