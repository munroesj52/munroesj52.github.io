<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_f32_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_f32_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over 4x32-bit floating point elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__common__ppc_8h_source.html">pveclib/vec_common_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__int128__ppc_8h_source.html">pveclib/vec_int128_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__f32__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a033068a4da4bc268328b136f3ffff689"><td class="memItemLeft" align="right" valign="top"><a id="a033068a4da4bc268328b136f3ffff689"></a>
typedef <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a033068a4da4bc268328b136f3ffff689">__vbinary32</a></td></tr>
<tr class="memdesc:a033068a4da4bc268328b136f3ffff689"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef __vbinary32 to vector of 4 xfloat elements. <br /></td></tr>
<tr class="separator:a033068a4da4bc268328b136f3ffff689"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a083462955e2fcb17cbaefb8dd3f3193d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a083462955e2fcb17cbaefb8dd3f3193d">vec_absf32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32x)</td></tr>
<tr class="memdesc:a083462955e2fcb17cbaefb8dd3f3193d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector float absolute value.  <a href="vec__f32__ppc_8h.html#a083462955e2fcb17cbaefb8dd3f3193d">More...</a><br /></td></tr>
<tr class="separator:a083462955e2fcb17cbaefb8dd3f3193d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dda81cc549201824af4d72d94e0f4d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a31dda81cc549201824af4d72d94e0f4d">vec_all_isfinitef32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:a31dda81cc549201824af4d72d94e0f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 4x32-bit vector float values are Finite (Not NaN nor Inf).  <a href="vec__f32__ppc_8h.html#a31dda81cc549201824af4d72d94e0f4d">More...</a><br /></td></tr>
<tr class="separator:a31dda81cc549201824af4d72d94e0f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9b6d623a59f26811e630cf9c5adf07"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a0b9b6d623a59f26811e630cf9c5adf07">vec_all_isinff32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:a0b9b6d623a59f26811e630cf9c5adf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all 4x32-bit vector float values are infinity.  <a href="vec__f32__ppc_8h.html#a0b9b6d623a59f26811e630cf9c5adf07">More...</a><br /></td></tr>
<tr class="separator:a0b9b6d623a59f26811e630cf9c5adf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5c70afc6b1790af8f3c0d646a93aaf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#aeb5c70afc6b1790af8f3c0d646a93aaf">vec_all_isnanf32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:aeb5c70afc6b1790af8f3c0d646a93aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of 4x32-bit vector float values are NaN.  <a href="vec__f32__ppc_8h.html#aeb5c70afc6b1790af8f3c0d646a93aaf">More...</a><br /></td></tr>
<tr class="separator:aeb5c70afc6b1790af8f3c0d646a93aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4248a6cd2fc4843c86bb9ecccce94062"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a4248a6cd2fc4843c86bb9ecccce94062">vec_all_isnormalf32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:a4248a6cd2fc4843c86bb9ecccce94062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of 4x32-bit vector float values are normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f32__ppc_8h.html#a4248a6cd2fc4843c86bb9ecccce94062">More...</a><br /></td></tr>
<tr class="separator:a4248a6cd2fc4843c86bb9ecccce94062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d876f718e28c11dd2cc05e5d942b33a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a9d876f718e28c11dd2cc05e5d942b33a">vec_all_issubnormalf32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:a9d876f718e28c11dd2cc05e5d942b33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of 4x32-bit vector float values is subnormal (denormal).  <a href="vec__f32__ppc_8h.html#a9d876f718e28c11dd2cc05e5d942b33a">More...</a><br /></td></tr>
<tr class="separator:a9d876f718e28c11dd2cc05e5d942b33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fcf345ca020c68f8067029d6656cb4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#aa5fcf345ca020c68f8067029d6656cb4">vec_all_iszerof32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:aa5fcf345ca020c68f8067029d6656cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of 4x32-bit vector float values are +-0.0.  <a href="vec__f32__ppc_8h.html#aa5fcf345ca020c68f8067029d6656cb4">More...</a><br /></td></tr>
<tr class="separator:aa5fcf345ca020c68f8067029d6656cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7493764e30ad8714335e54f3f18174"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a0a7493764e30ad8714335e54f3f18174">vec_any_isfinitef32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:a0a7493764e30ad8714335e54f3f18174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any 4x32-bit vector float values are Finite (Not NaN nor Inf).  <a href="vec__f32__ppc_8h.html#a0a7493764e30ad8714335e54f3f18174">More...</a><br /></td></tr>
<tr class="separator:a0a7493764e30ad8714335e54f3f18174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8272872f72ae6a67a0d4e00f59f6a1b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#af8272872f72ae6a67a0d4e00f59f6a1b">vec_any_isinff32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:af8272872f72ae6a67a0d4e00f59f6a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any 4x32-bit vector float values are infinity.  <a href="vec__f32__ppc_8h.html#af8272872f72ae6a67a0d4e00f59f6a1b">More...</a><br /></td></tr>
<tr class="separator:af8272872f72ae6a67a0d4e00f59f6a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08efce0a5e59ec168e17f93a5c099d9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#ad08efce0a5e59ec168e17f93a5c099d9">vec_any_isnanf32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:ad08efce0a5e59ec168e17f93a5c099d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 4x32-bit vector float values are NaN.  <a href="vec__f32__ppc_8h.html#ad08efce0a5e59ec168e17f93a5c099d9">More...</a><br /></td></tr>
<tr class="separator:ad08efce0a5e59ec168e17f93a5c099d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d2962ea183dc8d6f897baefbe28e91"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a95d2962ea183dc8d6f897baefbe28e91">vec_any_isnormalf32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:a95d2962ea183dc8d6f897baefbe28e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 4x32-bit vector float values are normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f32__ppc_8h.html#a95d2962ea183dc8d6f897baefbe28e91">More...</a><br /></td></tr>
<tr class="separator:a95d2962ea183dc8d6f897baefbe28e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7869701b5edad32495a5bc766987079"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#aa7869701b5edad32495a5bc766987079">vec_any_issubnormalf32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:aa7869701b5edad32495a5bc766987079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 4x32-bit vector float values is subnormal (denormal).  <a href="vec__f32__ppc_8h.html#aa7869701b5edad32495a5bc766987079">More...</a><br /></td></tr>
<tr class="separator:aa7869701b5edad32495a5bc766987079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3947cd426bd36bd2456d44679b41ba"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#aac3947cd426bd36bd2456d44679b41ba">vec_any_iszerof32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:aac3947cd426bd36bd2456d44679b41ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of 4x32-bit vector float values are +-0.0.  <a href="vec__f32__ppc_8h.html#aac3947cd426bd36bd2456d44679b41ba">More...</a><br /></td></tr>
<tr class="separator:aac3947cd426bd36bd2456d44679b41ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69f31ac3c33aa7ff7dca9572a40b851"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#ab69f31ac3c33aa7ff7dca9572a40b851">vec_copysignf32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32x, <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32y)</td></tr>
<tr class="memdesc:ab69f31ac3c33aa7ff7dca9572a40b851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign bit from vf32x merged with magnitude from vf32y and return the resulting vector float values.  <a href="vec__f32__ppc_8h.html#ab69f31ac3c33aa7ff7dca9572a40b851">More...</a><br /></td></tr>
<tr class="separator:ab69f31ac3c33aa7ff7dca9572a40b851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30f36fba977bc11812ef24b08887613"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#ab30f36fba977bc11812ef24b08887613">vec_isfinitef32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:ab30f36fba977bc11812ef24b08887613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 4x32-bit vector boolean true values for each float element that is Finite (Not NaN nor Inf).  <a href="vec__f32__ppc_8h.html#ab30f36fba977bc11812ef24b08887613">More...</a><br /></td></tr>
<tr class="separator:ab30f36fba977bc11812ef24b08887613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f0df67473a5496a40bbecf41bd54d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a11f0df67473a5496a40bbecf41bd54d9">vec_isinff32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:a11f0df67473a5496a40bbecf41bd54d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 4x32-bit vector boolean true values for each float, if infinity.  <a href="vec__f32__ppc_8h.html#a11f0df67473a5496a40bbecf41bd54d9">More...</a><br /></td></tr>
<tr class="separator:a11f0df67473a5496a40bbecf41bd54d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd364c3e220e61061f6c5ecd858a78de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#acd364c3e220e61061f6c5ecd858a78de">vec_isnanf32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:acd364c3e220e61061f6c5ecd858a78de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 4x32-bit vector boolean true values, for each float NaN value.  <a href="vec__f32__ppc_8h.html#acd364c3e220e61061f6c5ecd858a78de">More...</a><br /></td></tr>
<tr class="separator:acd364c3e220e61061f6c5ecd858a78de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d808fb7bf9b6603274b1b3fdbe626a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a0d808fb7bf9b6603274b1b3fdbe626a1">vec_isnormalf32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:a0d808fb7bf9b6603274b1b3fdbe626a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 4x32-bit vector boolean true values, for each float value, if normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f32__ppc_8h.html#a0d808fb7bf9b6603274b1b3fdbe626a1">More...</a><br /></td></tr>
<tr class="separator:a0d808fb7bf9b6603274b1b3fdbe626a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c112ab3e88b7514180cea612232bcab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a7c112ab3e88b7514180cea612232bcab">vec_issubnormalf32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:a7c112ab3e88b7514180cea612232bcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 4x32-bit vector boolean true values, for each float value that is subnormal (denormal).  <a href="vec__f32__ppc_8h.html#a7c112ab3e88b7514180cea612232bcab">More...</a><br /></td></tr>
<tr class="separator:a7c112ab3e88b7514180cea612232bcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b76fdcb61ad12bdbedb3cb6b766a1fc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a0b76fdcb61ad12bdbedb3cb6b766a1fc">vec_iszerof32</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vf32)</td></tr>
<tr class="memdesc:a0b76fdcb61ad12bdbedb3cb6b766a1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 4x32-bit vector boolean true values, for each float value that is +-0.0.  <a href="vec__f32__ppc_8h.html#a0b76fdcb61ad12bdbedb3cb6b766a1fc">More...</a><br /></td></tr>
<tr class="separator:a0b76fdcb61ad12bdbedb3cb6b766a1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92138896f19fc0b50aabaea6c5ab97f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a92138896f19fc0b50aabaea6c5ab97f9">vec_setb_sp</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vra)</td></tr>
<tr class="memdesc:a92138896f19fc0b50aabaea6c5ab97f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Set Bool from Sign, Single Precision.  <a href="vec__f32__ppc_8h.html#a92138896f19fc0b50aabaea6c5ab97f9">More...</a><br /></td></tr>
<tr class="separator:a92138896f19fc0b50aabaea6c5ab97f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b2d79f8d3afb30b92638ad78c80ca9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a80b2d79f8d3afb30b92638ad78c80ca9">vec_vgl4fsso</a> (float *array, const long long offset0, const long long offset1, const long long offset2, const long long offset3)</td></tr>
<tr class="memdesc:a80b2d79f8d3afb30b92638ad78c80ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load 4 Words from scalar Offsets.  <a href="vec__f32__ppc_8h.html#a80b2d79f8d3afb30b92638ad78c80ca9">More...</a><br /></td></tr>
<tr class="separator:a80b2d79f8d3afb30b92638ad78c80ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa738671df6a9afc3be51ae2970e51f8f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#aa738671df6a9afc3be51ae2970e51f8f">vec_vgl4fswo</a> (float *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra)</td></tr>
<tr class="memdesc:aa738671df6a9afc3be51ae2970e51f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load 4 Words from Vector Word Offsets.  <a href="vec__f32__ppc_8h.html#aa738671df6a9afc3be51ae2970e51f8f">More...</a><br /></td></tr>
<tr class="separator:aa738671df6a9afc3be51ae2970e51f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e36d8f19d43eb728ecfbe6419a20850"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a4e36d8f19d43eb728ecfbe6419a20850">vec_vgl4fswsx</a> (float *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, const unsigned char scale)</td></tr>
<tr class="memdesc:a4e36d8f19d43eb728ecfbe6419a20850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load 4 Words from Vector Word Scaled Indexes.  <a href="vec__f32__ppc_8h.html#a4e36d8f19d43eb728ecfbe6419a20850">More...</a><br /></td></tr>
<tr class="separator:a4e36d8f19d43eb728ecfbe6419a20850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89a9d6a379b26eafa55684e7df30450"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#ad89a9d6a379b26eafa55684e7df30450">vec_vgl4fswx</a> (float *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra)</td></tr>
<tr class="memdesc:ad89a9d6a379b26eafa55684e7df30450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load 4 Words from Vector Word Indexes.  <a href="vec__f32__ppc_8h.html#ad89a9d6a379b26eafa55684e7df30450">More...</a><br /></td></tr>
<tr class="separator:ad89a9d6a379b26eafa55684e7df30450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dedf6bd70933b544b9b6497464f6fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#ab4dedf6bd70933b544b9b6497464f6fd">vec_vglfsdo</a> (float *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:ab4dedf6bd70933b544b9b6497464f6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Single Floats from Vector Doubleword Offsets.  <a href="vec__f32__ppc_8h.html#ab4dedf6bd70933b544b9b6497464f6fd">More...</a><br /></td></tr>
<tr class="separator:ab4dedf6bd70933b544b9b6497464f6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d59fa048a9edc9d6b9ab74e3ee74783"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a4d59fa048a9edc9d6b9ab74e3ee74783">vec_vglfsdsx</a> (float *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, const unsigned char scale)</td></tr>
<tr class="memdesc:a4d59fa048a9edc9d6b9ab74e3ee74783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Single Floats from Vector Doubleword Scaled Indexes.  <a href="vec__f32__ppc_8h.html#a4d59fa048a9edc9d6b9ab74e3ee74783">More...</a><br /></td></tr>
<tr class="separator:a4d59fa048a9edc9d6b9ab74e3ee74783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920bcaf787edd68353498f26da93d992"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a920bcaf787edd68353498f26da93d992">vec_vglfsdx</a> (float *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:a920bcaf787edd68353498f26da93d992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Single Floats from Vector Doubleword Indexes.  <a href="vec__f32__ppc_8h.html#a920bcaf787edd68353498f26da93d992">More...</a><br /></td></tr>
<tr class="separator:a920bcaf787edd68353498f26da93d992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5d547a963230f7e6eb252b6f85afeb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#afc5d547a963230f7e6eb252b6f85afeb">vec_vglfsso</a> (float *array, const long long offset0, const long long offset1)</td></tr>
<tr class="memdesc:afc5d547a963230f7e6eb252b6f85afeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Gather-Load Float Single from scalar Offsets.  <a href="vec__f32__ppc_8h.html#afc5d547a963230f7e6eb252b6f85afeb">More...</a><br /></td></tr>
<tr class="separator:afc5d547a963230f7e6eb252b6f85afeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae605ed47fb58a86fe1f81ed86992ceb3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#ae605ed47fb58a86fe1f81ed86992ceb3">vec_vlxsspx</a> (const signed long long ra, const float *rb)</td></tr>
<tr class="memdesc:ae605ed47fb58a86fe1f81ed86992ceb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Load Scalar Single Float Indexed.  <a href="vec__f32__ppc_8h.html#ae605ed47fb58a86fe1f81ed86992ceb3">More...</a><br /></td></tr>
<tr class="separator:ae605ed47fb58a86fe1f81ed86992ceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af415ea9d80ac5a992ad232670626757d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#af415ea9d80ac5a992ad232670626757d">vec_vsst4fsso</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> xs, float *array, const long long offset0, const long long offset1, const long long offset2, const long long offset3)</td></tr>
<tr class="memdesc:af415ea9d80ac5a992ad232670626757d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store 4 Float Singles to Scalar Offsets.  <a href="vec__f32__ppc_8h.html#af415ea9d80ac5a992ad232670626757d">More...</a><br /></td></tr>
<tr class="separator:af415ea9d80ac5a992ad232670626757d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b16c013a9084caef73af7070c1072d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a3b16c013a9084caef73af7070c1072d5">vec_vsst4fswo</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> xs, float *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra)</td></tr>
<tr class="memdesc:a3b16c013a9084caef73af7070c1072d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store 4 Float Singles to Vector Word Offsets.  <a href="vec__f32__ppc_8h.html#a3b16c013a9084caef73af7070c1072d5">More...</a><br /></td></tr>
<tr class="separator:a3b16c013a9084caef73af7070c1072d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7891eef242ff07d4deb226a5ef85ded9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a7891eef242ff07d4deb226a5ef85ded9">vec_vsst4fswsx</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> xs, float *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, const unsigned char scale)</td></tr>
<tr class="memdesc:a7891eef242ff07d4deb226a5ef85ded9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store 4 Float Singles to Vector Word Indexes.  <a href="vec__f32__ppc_8h.html#a7891eef242ff07d4deb226a5ef85ded9">More...</a><br /></td></tr>
<tr class="separator:a7891eef242ff07d4deb226a5ef85ded9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedacc721ace30ad81c6fd59611f9969"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#aeedacc721ace30ad81c6fd59611f9969">vec_vsst4fswx</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> xs, float *array, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra)</td></tr>
<tr class="memdesc:aeedacc721ace30ad81c6fd59611f9969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store 4 Float Singles to Vector Word Indexes.  <a href="vec__f32__ppc_8h.html#aeedacc721ace30ad81c6fd59611f9969">More...</a><br /></td></tr>
<tr class="separator:aeedacc721ace30ad81c6fd59611f9969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d3d15a97b7bcc2a4f5f7fdbefd7f0a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a97d3d15a97b7bcc2a4f5f7fdbefd7f0a">vec_vsstfsdo</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> xs, float *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:a97d3d15a97b7bcc2a4f5f7fdbefd7f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Floats Singles to Vector Doubleword Offsets.  <a href="vec__f32__ppc_8h.html#a97d3d15a97b7bcc2a4f5f7fdbefd7f0a">More...</a><br /></td></tr>
<tr class="separator:a97d3d15a97b7bcc2a4f5f7fdbefd7f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9767f903d031042659ff9472b37e3b31"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a9767f903d031042659ff9472b37e3b31">vec_vsstfsdsx</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> xs, float *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, const unsigned char scale)</td></tr>
<tr class="memdesc:a9767f903d031042659ff9472b37e3b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Words to Vector Doubleword Scaled Indexes.  <a href="vec__f32__ppc_8h.html#a9767f903d031042659ff9472b37e3b31">More...</a><br /></td></tr>
<tr class="separator:a9767f903d031042659ff9472b37e3b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c149fbe4e0f53b4ad43b744bb4428d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a52c149fbe4e0f53b4ad43b744bb4428d">vec_vsstfsdx</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> xs, float *array, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra)</td></tr>
<tr class="memdesc:a52c149fbe4e0f53b4ad43b744bb4428d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Words to Vector Doubleword Indexes.  <a href="vec__f32__ppc_8h.html#a52c149fbe4e0f53b4ad43b744bb4428d">More...</a><br /></td></tr>
<tr class="separator:a52c149fbe4e0f53b4ad43b744bb4428d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdbcf3ec478943fe7ced3d718d02bd0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#aebdbcf3ec478943fe7ced3d718d02bd0">vec_vsstfsso</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> xs, float *array, const long long offset0, const long long offset1)</td></tr>
<tr class="memdesc:aebdbcf3ec478943fe7ced3d718d02bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Scatter-Store Float Singles to Scalar Offsets.  <a href="vec__f32__ppc_8h.html#aebdbcf3ec478943fe7ced3d718d02bd0">More...</a><br /></td></tr>
<tr class="separator:aebdbcf3ec478943fe7ced3d718d02bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f3412bdb1819590b3a1d949f488ab5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a46f3412bdb1819590b3a1d949f488ab5">vec_vstxsspx</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> xs, const signed long long ra, float *rb)</td></tr>
<tr class="memdesc:a46f3412bdb1819590b3a1d949f488ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Store Scalar Single Float Indexed.  <a href="vec__f32__ppc_8h.html#a46f3412bdb1819590b3a1d949f488ab5">More...</a><br /></td></tr>
<tr class="separator:a46f3412bdb1819590b3a1d949f488ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ac757161dfee660dcbcd428c1b8c00"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a08ac757161dfee660dcbcd428c1b8c00">vec_xviexpsp</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> sig, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> exp)</td></tr>
<tr class="memdesc:a08ac757161dfee660dcbcd428c1b8c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Insert Exponent Single-Precision.  <a href="vec__f32__ppc_8h.html#a08ac757161dfee660dcbcd428c1b8c00">More...</a><br /></td></tr>
<tr class="separator:a08ac757161dfee660dcbcd428c1b8c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4460b8901074a6752edce65ea33257"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#a8e4460b8901074a6752edce65ea33257">vec_xvxexpsp</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vrb)</td></tr>
<tr class="memdesc:a8e4460b8901074a6752edce65ea33257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Extract Exponent Single-Precision.  <a href="vec__f32__ppc_8h.html#a8e4460b8901074a6752edce65ea33257">More...</a><br /></td></tr>
<tr class="separator:a8e4460b8901074a6752edce65ea33257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf211d6b7de2a8aee04ca6b97c69851f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f32__ppc_8h.html#aaf211d6b7de2a8aee04ca6b97c69851f">vec_xvxsigsp</a> (<a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vrb)</td></tr>
<tr class="memdesc:aaf211d6b7de2a8aee04ca6b97c69851f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Extract Significand Single-Precision.  <a href="vec__f32__ppc_8h.html#aaf211d6b7de2a8aee04ca6b97c69851f">More...</a><br /></td></tr>
<tr class="separator:aaf211d6b7de2a8aee04ca6b97c69851f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over 4x32-bit floating point elements. </p>
<p>Most vector float (32-bit float) operations are implemented with PowerISA VMX instructions either defined by the original VMX (a.k.a. Altivec) or added to later versions of the PowerISA. POWER8 added the Vector Scalar Extended (VSX) with access to additional vector registers (64 total) and operations. Most of these operations (compiler built-ins, or intrinsics) are defined in &lt;altivec.h&gt; and described in the <a href="https://gcc.gnu.org/onlinedocs/">compiler documentation</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power7</b>, some of the wordwise pack, unpack and merge operations useful for conversions are not defined and the equivalent vec_perm and permute control must be used instead. This header will provide the appropriate substitutions, will generate the minimum code, appropriate for the target, and produce correct results.</dd>
<dd>
Most ppc64le compilers will default to -mcpu=power8 if not specified.</dd></dl>
<p>Most of these operations are implemented in a single instruction on newer (POWER8/POWER9) processors. This header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides an inline assembler implementation for older compilers that do not provide the built-ins.</p>
<p>POWER9 adds useful vector float operations, including: test data class, extract exponent, extract significand, and insert exponent. These operations are common in math library implementations.</p>
<dl class="section note"><dt>Note</dt><dd>GCC 7.3 defines vector forms of the test data class, extract significand, and extract/insert_exp for float and double. These built-ins are not defined in GCC 6.4. See <a href="https://gcc.gnu.org/onlinedocs/">compiler documentation</a>. These are useful operations and can be implement in a few vector logical instruction for earlier machines.</dd></dl>
<p>So it is reasonable for this header to provide vector forms of the floating point classification functions (isnormal/subnormal/finite/inf/nan/zero, etc.). These functions can be implemented directly using (one or more) POWER9 instructions, or a few vector logical and integer compare instructions for POWER7/8. Each is comfortably small enough to be in-lined and inherently faster than the equivalent POSIX or compiler built-in runtime scalar functions.</p>
<p>This header covers operations that are any of the following:</p>
<ul>
<li>Implemented in hardware instructions in newer processors, but useful to programmers on slightly older processors (even if the equivalent function requires more instructions). Examples include the floating point test data class, extract exponent, extract significand, and insert exponent operations.</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.h&gt; provided by available compilers in common use. Examples include vector float even/odd.</li>
<li>Providing special vector float tests for special conditions without generating extraneous floating-point exceptions. This is important for implementing vectorized forms of ISO C99 Math functions.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious.</li>
</ul>
<h1><a class="anchor" id="f32_examples_0_0"></a>
Examples</h1>
<p>For example: using the the classification functions for implementing the math library function sine and cosine. The POSIX specification requires that special input values are processed without raising extraneous floating point exceptions and return specific floating point values in response. For example the sin() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>value</em>.</li>
<li>If the input <em>value</em> is subnormal then return <em>value</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a NaN.</li>
<li>Otherwise compute and return sin(value).</li>
</ul>
<p>The following code example uses functions from this header to address the POSIX requirements for special values input to for a vectorized sinf(): </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a></div>
<div class="line">test_vec_sinf32 (<a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> value)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vec_f0 = { 0.0, 0.0, 0.0, 0.0 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_f32_qnan =</div>
<div class="line">    { 0x7f800001, 0x7fc00000, 0x7fc00000, 0x7fc00000 };</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> result;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a> normmask, infmask;</div>
<div class="line"> </div>
<div class="line">  normmask = <a class="code" href="vec__f32__ppc_8h.html#a0d808fb7bf9b6603274b1b3fdbe626a1">vec_isnormalf32</a> (value);</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f32__ppc_8h.html#a95d2962ea183dc8d6f897baefbe28e91">vec_any_isnormalf32</a> (value))</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// replace non-normal input values with safe values.</span></div>
<div class="line">      <a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> safeval = vec_sel (vec_f0, value, normmask);</div>
<div class="line">      <span class="comment">// body of vec_sin(safeval) computation elided for this example.</span></div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    result = value;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// merge non-normal input values back into result</span></div>
<div class="line">  result = vec_sel (value, result, normmask);</div>
<div class="line">  <span class="comment">// Inf input value elements return quiet-nan</span></div>
<div class="line">  infmask = <a class="code" href="vec__f32__ppc_8h.html#a11f0df67473a5496a40bbecf41bd54d9">vec_isinff32</a> (value);</div>
<div class="line">  result = vec_sel (result, (<a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>) vec_f32_qnan, infmask);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The code generated for this fragment runs between 24 (-mcpu=power9) and 40 (-mcpu=power8) instructions. The normal execution path is 14 to 25 instructions respectively.</p>
<p>Another example the cos() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>1.0</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a NaN.</li>
<li>Otherwise compute and return cos(value).</li>
</ul>
<p>The following code example uses functions from this header to address the POSIX requirements for special values input to vectorized cosf(): </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a></div>
<div class="line">test_vec_cosf32 (<a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> value)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> result;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vec_f0 = { 0.0, 0.0, 0.0, 0.0 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vec_f1 = { 1.0, 1.0, 1.0, 1.0 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_f32_qnan =</div>
<div class="line">    { 0x7f800001, 0x7fc00000, 0x7fc00000, 0x7fc00000 };</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a> finitemask, infmask, zeromask;</div>
<div class="line"> </div>
<div class="line">  finitemask = <a class="code" href="vec__f32__ppc_8h.html#ab30f36fba977bc11812ef24b08887613">vec_isfinitef32</a> (value);</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f32__ppc_8h.html#a0a7493764e30ad8714335e54f3f18174">vec_any_isfinitef32</a> (value))</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// replace non-finite input values with safe values</span></div>
<div class="line">      <a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> safeval = vec_sel (vec_f0, value, finitemask);</div>
<div class="line">      <span class="comment">// body of vec_sin(safeval) computation elided for this example</span></div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    result = value;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// merge non-finite input values back into result</span></div>
<div class="line">  result = vec_sel (value, result, finitemask);</div>
<div class="line">  <span class="comment">// Set +-0.0 input elements to exactly 1.0 in result</span></div>
<div class="line">  zeromask = <a class="code" href="vec__f32__ppc_8h.html#a0b76fdcb61ad12bdbedb3cb6b766a1fc">vec_iszerof32</a> (value);</div>
<div class="line">  result = vec_sel (result, vec_f1, zeromask);</div>
<div class="line">  <span class="comment">// Set Inf input elements to quiet-nan in result</span></div>
<div class="line">  infmask = <a class="code" href="vec__f32__ppc_8h.html#a11f0df67473a5496a40bbecf41bd54d9">vec_isinff32</a> (value);</div>
<div class="line">  result = vec_sel (result, (<a class="code" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>) vec_f32_qnan, infmask);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Neither example raises floating point exceptions or sets <b>errno</b>, as appropriate for a vector math library.</p>
<h1><a class="anchor" id="f32_perf_0_0"></a>
Performance data.</h1>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a083462955e2fcb17cbaefb8dd3f3193d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083462955e2fcb17cbaefb8dd3f3193d">&#9670;&nbsp;</a></span>vec_absf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vec_absf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector float absolute value. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32x</td><td>vector float values containing the magnitudes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector absolute values of 4x float elements of vf32x. </dd></dl>

</div>
</div>
<a id="a31dda81cc549201824af4d72d94e0f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31dda81cc549201824af4d72d94e0f4d">&#9670;&nbsp;</a></span>vec_all_isfinitef32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isfinitef32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 4x32-bit vector float values are Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary32 finite value has an exponent between 0x000 and 0x7f0 (a 0x7f8 indicates NaN or Inf). The significand can be any value. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="a0b9b6d623a59f26811e630cf9c5adf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9b6d623a59f26811e630cf9c5adf07">&#9670;&nbsp;</a></span>vec_all_isinff32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isinff32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all 4x32-bit vector float values are infinity. </p>
<p>A IEEE Binary32 infinity has a exponent of 0x7f8 and significand of all zeros. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int, true if all 4 float values are infinity </dd></dl>

</div>
</div>
<a id="aeb5c70afc6b1790af8f3c0d646a93aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5c70afc6b1790af8f3c0d646a93aaf">&#9670;&nbsp;</a></span>vec_all_isnanf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnanf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all of 4x32-bit vector float values are NaN. </p>
<p>A IEEE Binary32 NaN value has an exponent between 0x7f8 and the significand is nonzero. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all of 4 vector float values are NaN. </dd></dl>

</div>
</div>
<a id="a4248a6cd2fc4843c86bb9ecccce94062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4248a6cd2fc4843c86bb9ecccce94062">&#9670;&nbsp;</a></span>vec_all_isnormalf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnormalf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all of 4x32-bit vector float values are normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary32 normal value has an exponent between 0x008 and 0x7f (a 0x7f8 indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all of 4 vector float values are normal. </dd></dl>

</div>
</div>
<a id="a9d876f718e28c11dd2cc05e5d942b33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d876f718e28c11dd2cc05e5d942b33a">&#9670;&nbsp;</a></span>vec_all_issubnormalf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_issubnormalf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all of 4x32-bit vector float values is subnormal (denormal). </p>
<p>A IEEE Binary32 subnormal has an exponent of 0x000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-30 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all of 4 vector float values are subnormal. </dd></dl>

</div>
</div>
<a id="aa5fcf345ca020c68f8067029d6656cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fcf345ca020c68f8067029d6656cb4">&#9670;&nbsp;</a></span>vec_all_iszerof32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_iszerof32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all of 4x32-bit vector float values are +-0.0. </p>
<p>A IEEE Binary32 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if all of 4 vector float values are +/- zero. </dd></dl>

</div>
</div>
<a id="a0a7493764e30ad8714335e54f3f18174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7493764e30ad8714335e54f3f18174">&#9670;&nbsp;</a></span>vec_any_isfinitef32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_isfinitef32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any 4x32-bit vector float values are Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary32 finite value has an exponent between 0x000 and 0x7f0 (a 0x7f8 indicates NaN or Inf). The significand can be any value. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="af8272872f72ae6a67a0d4e00f59f6a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8272872f72ae6a67a0d4e00f59f6a1b">&#9670;&nbsp;</a></span>vec_any_isinff32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_isinff32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any 4x32-bit vector float values are infinity. </p>
<p>A IEEE Binary32 infinity has a exponent of 0x7f8 and significand of all zeros.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int, true if any of 4 float values are infinity </dd></dl>

</div>
</div>
<a id="ad08efce0a5e59ec168e17f93a5c099d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08efce0a5e59ec168e17f93a5c099d9">&#9670;&nbsp;</a></span>vec_any_isnanf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_isnanf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 4x32-bit vector float values are NaN. </p>
<p>A IEEE Binary32 NaN value has an exponent between 0x7f8 and the significand is nonzero. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if any of 4 vector float values are NaN. </dd></dl>

</div>
</div>
<a id="a95d2962ea183dc8d6f897baefbe28e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d2962ea183dc8d6f897baefbe28e91">&#9670;&nbsp;</a></span>vec_any_isnormalf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_isnormalf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 4x32-bit vector float values are normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary32 normal value has an exponent between 0x008 and 0x7f (a 0x7f8 indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-24 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if any of 4 vector float values are normal. </dd></dl>

</div>
</div>
<a id="aa7869701b5edad32495a5bc766987079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7869701b5edad32495a5bc766987079">&#9670;&nbsp;</a></span>vec_any_issubnormalf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_issubnormalf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 4x32-bit vector float values is subnormal (denormal). </p>
<p>A IEEE Binary32 subnormal has an exponent of 0x000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-18 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if any of 4 vector float values are subnormal. </dd></dl>

</div>
</div>
<a id="aac3947cd426bd36bd2456d44679b41ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3947cd426bd36bd2456d44679b41ba">&#9670;&nbsp;</a></span>vec_any_iszerof32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_any_iszerof32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any of 4x32-bit vector float values are +-0.0. </p>
<p>A IEEE Binary32 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if any of 4 vector float values are +/- zero. </dd></dl>

</div>
</div>
<a id="ab69f31ac3c33aa7ff7dca9572a40b851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69f31ac3c33aa7ff7dca9572a40b851">&#9670;&nbsp;</a></span>vec_copysignf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vec_copysignf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the sign bit from vf32x merged with magnitude from vf32y and return the resulting vector float values. </p>
<dl class="section note"><dt>Note</dt><dd>This operation was patterned after the intrinsic vec_cpsgn (altivec.h) introduced for POWER7 and VSX. It turns out the original (GCC 4.9) compiler implementation reversed the operands and does not match the PowerISA or the Vector Intrinsic Programming Reference manuals. Subsequent compilers and PVECLIB implementations replicated this (operand order) error. This has now been reported as bug against the compilers, which are in the process of applying fixes and distributing updates. This version of PVECLIB is updated to match the Vector Intrinsic Programming Reference. This implementation is independent of the compilers update status.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32x</td><td>vector float values containing the sign bits. </td></tr>
    <tr><td class="paramname">vf32y</td><td>vector float values containing the magnitudes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector float values with magnitude from vf32y and the sign of vf32x. </dd></dl>

</div>
</div>
<a id="ab30f36fba977bc11812ef24b08887613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30f36fba977bc11812ef24b08887613">&#9670;&nbsp;</a></span>vec_isfinitef32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a> vec_isfinitef32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 4x32-bit vector boolean true values for each float element that is Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary32 finite value has an exponent between 0x000 and 0x7f0 (a 0x7f8 indicates NaN or Inf). The significand can be any value. Using the vec_cmpeq conditional to generate the predicate mask for NaN / Inf and then invert this for the finite condition. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-15 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a11f0df67473a5496a40bbecf41bd54d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f0df67473a5496a40bbecf41bd54d9">&#9670;&nbsp;</a></span>vec_isinff32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a> vec_isinff32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 4x32-bit vector boolean true values for each float, if infinity. </p>
<p>A IEEE Binary32 infinity has a exponent of 0x7f8 and significand of all zeros.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-13 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="acd364c3e220e61061f6c5ecd858a78de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd364c3e220e61061f6c5ecd858a78de">&#9670;&nbsp;</a></span>vec_isnanf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a> vec_isnanf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 4x32-bit vector boolean true values, for each float NaN value. </p>
<p>A IEEE Binary32 NaN value has an exponent between 0x7f8 and the significand is nonzero. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-13 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a0d808fb7bf9b6603274b1b3fdbe626a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d808fb7bf9b6603274b1b3fdbe626a1">&#9670;&nbsp;</a></span>vec_isnormalf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a> vec_isnormalf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 4x32-bit vector boolean true values, for each float value, if normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary32 normal value has an exponent between 0x008 and 0x7f (a 0x7f8 indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-15 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a7c112ab3e88b7514180cea612232bcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c112ab3e88b7514180cea612232bcab">&#9670;&nbsp;</a></span>vec_issubnormalf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a> vec_issubnormalf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 4x32-bit vector boolean true values, for each float value that is subnormal (denormal). </p>
<p>A IEEE Binary32 subnormal has an exponent of 0x000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-16 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a0b76fdcb61ad12bdbedb3cb6b766a1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b76fdcb61ad12bdbedb3cb6b766a1fc">&#9670;&nbsp;</a></span>vec_iszerof32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a> vec_iszerof32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vf32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 4x32-bit vector boolean true values, for each float value that is +-0.0. </p>
<p>A IEEE Binary32 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal float compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-13 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf32</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a92138896f19fc0b50aabaea6c5ab97f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92138896f19fc0b50aabaea6c5ab97f9">&#9670;&nbsp;</a></span>vec_setb_sp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a> vec_setb_sp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Set Bool from Sign, Single Precision. </p>
<p>For each float, propagate the sign bit to all 32-bits of that word. The result is vector bool int reflecting the sign bit of each 32-bit float.</p>
<p>The resulting mask can be used in masking and select operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation will set the sign mask regardless of data class, while the Vector Test Data Class will not distinguish between +/- NaN.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-9 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2-8 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>Vector float. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector bool int reflecting the sign bits of each float value. </dd></dl>

</div>
</div>
<a id="a80b2d79f8d3afb30b92638ad78c80ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b2d79f8d3afb30b92638ad78c80ca9">&#9670;&nbsp;</a></span>vec_vgl4fsso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vec_vgl4fsso </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load 4 Words from scalar Offsets. </p>
<p>For each scalar offset[0,1,2,3], load the word from the effective address formed by *(char*)array+offset[0-3]. Merge resulting float single word elements [0,1,2,3] and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">11 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">offset0</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset1</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset2</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset3</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector word containing word elements [0-3] loaded from *(char*)array+offset[0-3]. </dd></dl>

</div>
</div>
<a id="aa738671df6a9afc3be51ae2970e51f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa738671df6a9afc3be51ae2970e51f8f">&#9670;&nbsp;</a></span>vec_vgl4fswo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vec_vgl4fswo </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load 4 Words from Vector Word Offsets. </p>
<p>For each signed word element [i] of vra, load the float single word element at *(char*)array+vra[i]. Merge those word elements [0-3] and return the resulting vector.</p>
<dl class="section note"><dt>Note</dt><dd>Signed word offsets are expanded (unpacked) to doublewords before transfer to GRPs for effective address calculation.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">15 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector word containing word elements [0-3], each loaded from *(char*)array+vra[0-3]. </dd></dl>

</div>
</div>
<a id="a4e36d8f19d43eb728ecfbe6419a20850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e36d8f19d43eb728ecfbe6419a20850">&#9670;&nbsp;</a></span>vec_vgl4fswsx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vec_vgl4fswsx </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load 4 Words from Vector Word Scaled Indexes. </p>
<p>For each signed word element [i] of vra, load the float single word element at array[vra[i] &lt;&lt; scale]. Merge those word elements [0-3] and return the resulting vector.</p>
<dl class="section note"><dt>Note</dt><dd>Signed word indexes are expanded (unpacked) to doublewords before shifting left (2+scale) bits before transfer to GRPs for effective address calculation. This converts each index to an 64-bit offset.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">16-25 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">18-27 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) indexes. </td></tr>
    <tr><td class="paramname">scale</td><td>8-bit integer. Indexes are multiplying by 2<sup>scale</sup>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector word containing word elements [0-3] each loaded from array[vra[0-3] &lt;&lt; scale]. </dd></dl>

</div>
</div>
<a id="ad89a9d6a379b26eafa55684e7df30450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89a9d6a379b26eafa55684e7df30450">&#9670;&nbsp;</a></span>vec_vgl4fswx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vec_vgl4fswx </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load 4 Words from Vector Word Indexes. </p>
<p>For word element [i] of vra, load the float single word element at array[vra[i]]. Merge those word elements [0-3] and return the resulting vector.</p>
<dl class="section note"><dt>Note</dt><dd>Signed word indexes are expanded (unpacked) to doublewords before shifting left 2 bits. This converts each index to an 64-bit offset for effective address calculation.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">16-25 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">18-27 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of integer words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) indexes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector word containing word elements [0-3], each loaded from array[vra[0-3]]. </dd></dl>

</div>
</div>
<a id="ab4dedf6bd70933b544b9b6497464f6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4dedf6bd70933b544b9b6497464f6fd">&#9670;&nbsp;</a></span>vec_vglfsdo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_vglfsdo </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Single Floats from Vector Doubleword Offsets. </p>
<p>For each doubleword element [0-1] of vra, load the float single word element at *(char*)array+vra[i] expanding them to float double format. Merge doubleword elements [0,1] and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">11 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of float singles. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword (64-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector doubleword elements [0,1] loaded from expanded float single words at *(char*)array+vra[i]. </dd></dl>

</div>
</div>
<a id="a4d59fa048a9edc9d6b9ab74e3ee74783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d59fa048a9edc9d6b9ab74e3ee74783">&#9670;&nbsp;</a></span>vec_vglfsdsx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_vglfsdsx </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Single Floats from Vector Doubleword Scaled Indexes. </p>
<p>For each doubleword element [0-1] of vra, load the float single word element at array[vra[i] &lt;&lt; scale)]. Merge doubleword elements [0,1] and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">13-22 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of float. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword indexes from &amp;array. </td></tr>
    <tr><td class="paramname">scale</td><td>8-bit integer. Indexes are multiplying by 2<sup>scale</sup>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector doubleword elements [0,1] loaded from the float single words at array[vra[0,1]&lt;&lt;scale]. </dd></dl>

</div>
</div>
<a id="a920bcaf787edd68353498f26da93d992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920bcaf787edd68353498f26da93d992">&#9670;&nbsp;</a></span>vec_vglfsdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_vglfsdx </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Single Floats from Vector Doubleword Indexes. </p>
<p>For each doubleword element [0-1] of vra, load the float single word element at array[vra[i]]. Merge doubleword elements [0,1] and return the resulting vector.</p>
<dl class="section note"><dt>Note</dt><dd>As effective address calculation is modulo 64-bits, signed or unsigned doubleword offsets are equivalent.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">13-22 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of float. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword indexes from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector doubleword elements [0,1] loaded from float single words at array[vra[0,1]]. </dd></dl>

</div>
</div>
<a id="afc5d547a963230f7e6eb252b6f85afeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5d547a963230f7e6eb252b6f85afeb">&#9670;&nbsp;</a></span>vec_vglfsso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_vglfsso </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Gather-Load Float Single from scalar Offsets. </p>
<p>For each scalar offset[0|1], load the float single element at *(char*)array+offset[0|1] expanding them to float double format. Merge doubleword elements [0,1] and return the resulting vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array of floats. </td></tr>
    <tr><td class="paramname">offset0</td><td>Scalar (64-bit) byte offsets from &amp;array. </td></tr>
    <tr><td class="paramname">offset1</td><td>Scalar (64-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector double containing elements loaded from *(char*)array+offset0 and *(char*)array+offset1. </dd></dl>

</div>
</div>
<a id="ae605ed47fb58a86fe1f81ed86992ceb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae605ed47fb58a86fe1f81ed86992ceb3">&#9670;&nbsp;</a></span>vec_vlxsspx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_vlxsspx </td>
          <td>(</td>
          <td class="paramtype">const signed long long&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>rb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Load Scalar Single Float Indexed. </p>
<p>Load doubleword[0] of vector <b>xt</b> as a scalar (double float formatted) single float word from the effective address formed by <b>rb+ra</b>. The operand <b>rb</b> is a pointer to an array of float words. The operand <b>ra</b> is a doubleword integer byte offset from <b>rb</b>. The result <b>xt</b> is returned as a vf64_t vector. For best performance <b>rb</b> and <b>ra</b> should be word aligned (integer multiple of 4).</p>
<dl class="section note"><dt>Note</dt><dd>The Left most doubleword is the single float value, expanded and formated as a double float. The right most doubleword of vector <b>xt</b> is left <em>undefined</em> by this operation.</dd></dl>
<p>This operation is an alternate form of Vector Load Element (vec_lde), with the added simplification that data is always left justified in the vector. Another advantage for Power8 and later, the lxsspx instruction can load directly into any of the 64 VSRs, while expanding the single float word value into float double format, in a single operation. Both simplify merging elements for gather operations.</p>
<dl class="section note"><dt>Note</dt><dd>The lxsspx instruction was introduced in PowerISA 2.07 (POWER8). Power7 and earlier will use lfs[x] and xxpermdi to move the result from VSR/FPR range to VSR/VR range if needed.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">8 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ra</td><td>const doubleword index (offset/displacement). </td></tr>
    <tr><td class="paramname">rb</td><td>const pointer to an array of floats. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The word stored at (ra + rb) is expanded from single to double float format and loaded into vector doubleword element 0. Element 1 is undefined. </dd></dl>

</div>
</div>
<a id="af415ea9d80ac5a992ad232670626757d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af415ea9d80ac5a992ad232670626757d">&#9670;&nbsp;</a></span>vec_vsst4fsso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsst4fsso </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store 4 Float Singles to Scalar Offsets. </p>
<p>For each float word element [0-3] of xs, store the float element xs[i] at *(char*)array+offset[i].</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">4 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector float elements to scatter store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of float words. </td></tr>
    <tr><td class="paramname">offset0</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset1</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset2</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset3</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b16c013a9084caef73af7070c1072d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b16c013a9084caef73af7070c1072d5">&#9670;&nbsp;</a></span>vec_vsst4fswo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsst4fswo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store 4 Float Singles to Vector Word Offsets. </p>
<p>For each float word element [0-3] of xs, store the float element xs[i] at *(char*)array+vra[i].</p>
<dl class="section note"><dt>Note</dt><dd>Signed word offsets are expanded (unpacked) to doublewords before transfer to GRPs for effective address calculation.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector float elements to scatter store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of float words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7891eef242ff07d4deb226a5ef85ded9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7891eef242ff07d4deb226a5ef85ded9">&#9670;&nbsp;</a></span>vec_vsst4fswsx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsst4fswsx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store 4 Float Singles to Vector Word Indexes. </p>
<p>For each float word element [0-4] of xs, store the float element xs[i] at *(char*)array[vra[i]&lt;&lt;scale].</p>
<dl class="section note"><dt>Note</dt><dd>Signed word indexes are expanded (unpacked) to doublewords before shifting left (2+scale) bits before transfer to GRPs for effective address calculation. This converts each index to an 64-bit offset.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12-21 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">15-24 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector float elements to scatter store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of float words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) indexes from array. </td></tr>
    <tr><td class="paramname">scale</td><td>8-bit integer. Indexes are multiplying by 2<sup>scale</sup>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeedacc721ace30ad81c6fd59611f9969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedacc721ace30ad81c6fd59611f9969">&#9670;&nbsp;</a></span>vec_vsst4fswx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsst4fswx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store 4 Float Singles to Vector Word Indexes. </p>
<p>For each float word element [0-3] of xs, store the float element xs[i] at *(char*)array[vra[i]].</p>
<dl class="section note"><dt>Note</dt><dd>Signed word indexes are expanded (unpacked) to doublewords before shifting left 2 bits before transfer to GRPs for effective address calculation. This converts each index to an 64-bit offset.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12-21 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">15-24 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector float elements to scatter store. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of float words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of signed word (32-bit) indexes from array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97d3d15a97b7bcc2a4f5f7fdbefd7f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d3d15a97b7bcc2a4f5f7fdbefd7f0a">&#9670;&nbsp;</a></span>vec_vsstfsdo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstfsdo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Floats Singles to Vector Doubleword Offsets. </p>
<p>For each doubleword element [0-1] of vra, store the doubleword float element xs[i], converted to float single word format, at *(char*)array+vra[i].</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">9 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector doubleword elements to scatter store as float single words. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of float words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword (64-bit) byte offsets from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9767f903d031042659ff9472b37e3b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9767f903d031042659ff9472b37e3b31">&#9670;&nbsp;</a></span>vec_vsstfsdsx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstfsdsx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Words to Vector Doubleword Scaled Indexes. </p>
<p>For each doubleword element [0-1] of vra, store the doubleword float element xs[i], converted to float single word format, at array[vra[i]&lt;&lt;scale].</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector doubleword elements to scatter store as float single words. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of float words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword (64-bit) indexes from &amp;array. </td></tr>
    <tr><td class="paramname">scale</td><td>8-bit integer. Indexes are multiplying by 2<sup>scale</sup>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52c149fbe4e0f53b4ad43b744bb4428d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c149fbe4e0f53b4ad43b744bb4428d">&#9670;&nbsp;</a></span>vec_vsstfsdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstfsdx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Words to Vector Doubleword Indexes. </p>
<p>For each doubleword element [0-1] of vra, store the doubleword float element xs[i], converted to float single word format, at array[vra[i]].</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector doubleword elements to scatter store as float single words. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of float words. </td></tr>
    <tr><td class="paramname">vra</td><td>Vector of doubleword (64-bit) indexes from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebdbcf3ec478943fe7ced3d718d02bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdbcf3ec478943fe7ced3d718d02bd0">&#9670;&nbsp;</a></span>vec_vsstfsso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vsstfsso </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>offset1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Scatter-Store Float Singles to Scalar Offsets. </p>
<p>For each scalar offset[0-1], Store the doubleword element xs[i], converted to float single word format, at *(char*)array+offset[0|1].</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Vector doubleword elements to scatter store as float single words. </td></tr>
    <tr><td class="paramname">array</td><td>Pointer to array of float words. </td></tr>
    <tr><td class="paramname">offset0</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
    <tr><td class="paramname">offset1</td><td>Scalar (64-bit) byte offset from &amp;array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46f3412bdb1819590b3a1d949f488ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f3412bdb1819590b3a1d949f488ab5">&#9670;&nbsp;</a></span>vec_vstxsspx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vec_vstxsspx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const signed long long&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Store Scalar Single Float Indexed. </p>
<p>Stores doubleword float element 0 of vector <b>xs</b> as a scalar float word at the effective address formed by <b>rb+ra</b>. The operand <b>rb</b> is a pointer to an array of float. The operand <b>ra</b> is a doubleword integer byte offset from <b>rb</b>. For best performance <b>rb</b> and <b>ra</b> should be word aligned (integer multiple of 4).</p>
<p>This operation is an alternate form of vector store element (vec_ste), with the added simplification that data is always left justified in the vector. Another advantage for Power8 and later, the stxsspx instruction can load directly into any of the 64 VSRs. Both simplify scatter operations.</p>
<dl class="section note"><dt>Note</dt><dd>The stxsspx instruction was introduced in PowerISA 2.07 (POWER8). Power7 and earlier will, move the source (xs) from VSR/VR range to VSR/FPR range if needed, then use stsf[x].</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">0 - 2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">0 - 2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>vector doubleword element 0 to be stored as single float. </td></tr>
    <tr><td class="paramname">ra</td><td>const doubleword index (offset/displacement). </td></tr>
    <tr><td class="paramname">rb</td><td>const pointer to an array of floats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08ac757161dfee660dcbcd428c1b8c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ac757161dfee660dcbcd428c1b8c00">&#9670;&nbsp;</a></span>vec_xviexpsp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> vec_xviexpsp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Insert Exponent Single-Precision. </p>
<p>For each word of <b>sig</b> and <b>exp</b>, merge the sign (bit 0) and significand (bits 9:31) from <b>sig</b> with the 8-bit exponent from <b>exp</b> (bits 24:31). The exponent is merged into bits 1:8 of the final result. The result is returned as a Vector Single-Precision floating point value.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xviexpsp instruction and the built-in vec_insert_exp. These require a POWER9-enabled compiler targeting -mcpu=power9 and are not available for older compilers nor POWER8 and earlier. This function provides this operation for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-15 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Vector unsigned int containing the Sign Bit and 23-bit significand. </td></tr>
    <tr><td class="paramname">exp</td><td>Vector unsigned int containing the 8-bit exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vf32_t value where the exponent bits (1:8) of sig are replaced from bits 24:31 of exp. </dd></dl>

</div>
</div>
<a id="a8e4460b8901074a6752edce65ea33257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4460b8901074a6752edce65ea33257">&#9670;&nbsp;</a></span>vec_xvxexpsp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_xvxexpsp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Extract Exponent Single-Precision. </p>
<p>For each word of <b>vrb</b>, Extract the single-precision exponent (bits 1:8) and right justify it to (bits 24:31 of) of the result vector word. The result is returned as vector unsigned integer value.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xvxexpsp instruction and the built-in vec_extract_exp. These require a POWER9-enabled compiler targeting -mcpu=power9 and are not available for older compilers nor POWER8 and earlier. This function provides this operation for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-15 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vrb</td><td>vector double value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned int containing the 8-bit exponent right justified in each word </dd></dl>

</div>
</div>
<a id="aaf211d6b7de2a8aee04ca6b97c69851f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf211d6b7de2a8aee04ca6b97c69851f">&#9670;&nbsp;</a></span>vec_xvxsigsp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_xvxsigsp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Extract Significand Single-Precision. </p>
<p>For each word of <b>vrb</b>, Extract the single-precision significand (bits 0:31) and restore the implied (hidden) bit (bit 8) if the single-precision value is normal (not zero, subnormal, Infinity or NaN). The result is return as vector unsigned int value with up to 24 bits of significance.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xvxsigsp instruction and the built-in vec_extract_sig. These require a POWER9-enabled compiler targeting -mcpu=power9 and are not available for older compilers nor POWER8 and earlier. This function provides this operation for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vrb</td><td>vector double value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned int containing the significand. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="avec__f32__ppc_8h_html_ab30f36fba977bc11812ef24b08887613"><div class="ttname"><a href="vec__f32__ppc_8h.html#ab30f36fba977bc11812ef24b08887613">vec_isfinitef32</a></div><div class="ttdeci">static vb32_t vec_isfinitef32(vf32_t vf32)</div><div class="ttdoc">Return 4x32-bit vector boolean true values for each float element that is Finite (Not NaN nor Inf).</div><div class="ttdef"><b>Definition:</b> vec_f32_ppc.h:864</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_aafeddf1e79ef817440ff01fafb0e00ca"><div class="ttname"><a href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a></div><div class="ttdeci">__vector __bool int vb32_t</div><div class="ttdoc">vector of 32-bit bool int elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:228</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a18f1382a0cb269770bbb8387dfcbbe1c"><div class="ttname"><a href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a></div><div class="ttdeci">__vector float vf32_t</div><div class="ttdoc">vector of 32-bit float elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:219</div></div>
<div class="ttc" id="avec__f32__ppc_8h_html_a0a7493764e30ad8714335e54f3f18174"><div class="ttname"><a href="vec__f32__ppc_8h.html#a0a7493764e30ad8714335e54f3f18174">vec_any_isfinitef32</a></div><div class="ttdeci">static int vec_any_isfinitef32(vf32_t vf32)</div><div class="ttdoc">Return true if any 4x32-bit vector float values are Finite (Not NaN nor Inf).</div><div class="ttdef"><b>Definition:</b> vec_f32_ppc.h:534</div></div>
<div class="ttc" id="avec__f32__ppc_8h_html_a0b76fdcb61ad12bdbedb3cb6b766a1fc"><div class="ttname"><a href="vec__f32__ppc_8h.html#a0b76fdcb61ad12bdbedb3cb6b766a1fc">vec_iszerof32</a></div><div class="ttdeci">static vb32_t vec_iszerof32(vf32_t vf32)</div><div class="ttdoc">Return 4x32-bit vector boolean true values, for each float value that is +-0.0.</div><div class="ttdef"><b>Definition:</b> vec_f32_ppc.h:1090</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a2ff4a776536870e01b7c9e454586544b"><div class="ttname"><a href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div><div class="ttdeci">__vector unsigned int vui32_t</div><div class="ttdoc">vector of 32-bit unsigned int elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:206</div></div>
<div class="ttc" id="avec__f32__ppc_8h_html_a0d808fb7bf9b6603274b1b3fdbe626a1"><div class="ttname"><a href="vec__f32__ppc_8h.html#a0d808fb7bf9b6603274b1b3fdbe626a1">vec_isnormalf32</a></div><div class="ttdeci">static vb32_t vec_isnormalf32(vf32_t vf32)</div><div class="ttdoc">Return 4x32-bit vector boolean true values, for each float value, if normal (Not NaN,...</div><div class="ttdef"><b>Definition:</b> vec_f32_ppc.h:996</div></div>
<div class="ttc" id="avec__f32__ppc_8h_html_a11f0df67473a5496a40bbecf41bd54d9"><div class="ttname"><a href="vec__f32__ppc_8h.html#a11f0df67473a5496a40bbecf41bd54d9">vec_isinff32</a></div><div class="ttdeci">static vb32_t vec_isinff32(vf32_t vf32)</div><div class="ttdoc">Return 4x32-bit vector boolean true values for each float, if infinity.</div><div class="ttdef"><b>Definition:</b> vec_f32_ppc.h:908</div></div>
<div class="ttc" id="avec__f32__ppc_8h_html_a95d2962ea183dc8d6f897baefbe28e91"><div class="ttname"><a href="vec__f32__ppc_8h.html#a95d2962ea183dc8d6f897baefbe28e91">vec_any_isnormalf32</a></div><div class="ttdeci">static int vec_any_isnormalf32(vf32_t vf32)</div><div class="ttdoc">Return true if any of 4x32-bit vector float values are normal (Not NaN, Inf, denormal,...</div><div class="ttdef"><b>Definition:</b> vec_f32_ppc.h:668</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 10 2022 14:57:44 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
