<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_f128_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_f128_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over Quad-Precision floating point elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__common__ppc_8h_source.html">pveclib/vec_common_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__int128__ppc_8h_source.html">pveclib/vec_int128_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__f64__ppc_8h_source.html">pveclib/vec_f64_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__f128__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union____VF__128.html">__VF_128</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union used to transfer 128-bit data between vector and __float128 types.  <a href="union____VF__128.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5c0751a2b64a9a560e9a964294f63166"><td class="memItemLeft" align="right" valign="top"><a id="a5c0751a2b64a9a560e9a964294f63166"></a>
typedef <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a></td></tr>
<tr class="memdesc:a5c0751a2b64a9a560e9a964294f63166"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 128-bit binary128 element. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a5c0751a2b64a9a560e9a964294f63166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="memItemLeft" align="right" valign="top"><a id="a5f89d266b82d1a8f300348cf99b9ae3f"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5f89d266b82d1a8f300348cf99b9ae3f">__Float128</a></td></tr>
<tr class="memdesc:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __Float128 if not defined by the compiler. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443a43ae34ab3b78564d2a8277503cac"><td class="memItemLeft" align="right" valign="top"><a id="a443a43ae34ab3b78564d2a8277503cac"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></td></tr>
<tr class="memdesc:a443a43ae34ab3b78564d2a8277503cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __binary128 if not defined by the compiler. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a443a43ae34ab3b78564d2a8277503cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af2270bedc312f7d99c0605358cd28c"><td class="memItemLeft" align="right" valign="top"><a id="a4af2270bedc312f7d99c0605358cd28c"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4af2270bedc312f7d99c0605358cd28c">__float128</a></td></tr>
<tr class="memdesc:a4af2270bedc312f7d99c0605358cd28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __float128 if not defined by the compiler. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a4af2270bedc312f7d99c0605358cd28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55019fe6dc8271e91613db7b1ae96721"><td class="memItemLeft" align="right" valign="top"><a id="a55019fe6dc8271e91613db7b1ae96721"></a>
typedef long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a55019fe6dc8271e91613db7b1ae96721">__IBM128</a></td></tr>
<tr class="memdesc:a55019fe6dc8271e91613db7b1ae96721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __IBM128 if not defined by the compiler. Same as old long double for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a55019fe6dc8271e91613db7b1ae96721"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2843ee28bf45b6e7589f2b1d073a2187"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a2843ee28bf45b6e7589f2b1d073a2187">vec_sel_bin128_2_bin128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb, <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> mask)</td></tr>
<tr class="memdesc:a2843ee28bf45b6e7589f2b1d073a2187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value.  <a href="vec__f128__ppc_8h.html#a2843ee28bf45b6e7589f2b1d073a2187">More...</a><br /></td></tr>
<tr class="separator:a2843ee28bf45b6e7589f2b1d073a2187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e62b9910ec833dfc20719d09e526e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mask)</td></tr>
<tr class="memdesc:aae0e62b9910ec833dfc20719d09e526e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask.  <a href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">More...</a><br /></td></tr>
<tr class="separator:aae0e62b9910ec833dfc20719d09e526e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfcf3adea80e0407b40c6ec0e851aab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mask)</td></tr>
<tr class="memdesc:aedfcf3adea80e0407b40c6ec0e851aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask.  <a href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">More...</a><br /></td></tr>
<tr class="separator:aedfcf3adea80e0407b40c6ec0e851aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796440333ee623aa782ef3eb5a021587"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a796440333ee623aa782ef3eb5a021587">vec_andc_bin128_2_vui128t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> mask)</td></tr>
<tr class="memdesc:a796440333ee623aa782ef3eb5a021587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector __int128 and logical AND Compliment with mask.  <a href="vec__f128__ppc_8h.html#a796440333ee623aa782ef3eb5a021587">More...</a><br /></td></tr>
<tr class="separator:a796440333ee623aa782ef3eb5a021587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a57dc5b9171d5ce3d49f0f12795659c1a">vec_xfer_bin128_2_vui8t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector char.  <a href="vec__f128__ppc_8h.html#a57dc5b9171d5ce3d49f0f12795659c1a">More...</a><br /></td></tr>
<tr class="separator:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0629194f4f63bb083c271844459072"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aff0629194f4f63bb083c271844459072">vec_xfer_bin128_2_vui16t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aff0629194f4f63bb083c271844459072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector short int.  <a href="vec__f128__ppc_8h.html#aff0629194f4f63bb083c271844459072">More...</a><br /></td></tr>
<tr class="separator:aff0629194f4f63bb083c271844459072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a8043c2c5ac35d2b0a8bd8f33779c91a6">vec_xfer_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector int.  <a href="vec__f128__ppc_8h.html#a8043c2c5ac35d2b0a8bd8f33779c91a6">More...</a><br /></td></tr>
<tr class="separator:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac5809f5f651e45113de8410664f2c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#acac5809f5f651e45113de8410664f2c7">vec_xfer_bin128_2_vui64t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:acac5809f5f651e45113de8410664f2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector long long int.  <a href="vec__f128__ppc_8h.html#acac5809f5f651e45113de8410664f2c7">More...</a><br /></td></tr>
<tr class="separator:acac5809f5f651e45113de8410664f2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6e44a75847d3d3e5611b89eed71c0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aec6e44a75847d3d3e5611b89eed71c0a">vec_xfer_bin128_2_vui128t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aec6e44a75847d3d3e5611b89eed71c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector __int128.  <a href="vec__f128__ppc_8h.html#aec6e44a75847d3d3e5611b89eed71c0a">More...</a><br /></td></tr>
<tr class="separator:aec6e44a75847d3d3e5611b89eed71c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a047b7dc5b55b2d13e2fd826c63872ea9">vec_xfer_vui8t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> f128)</td></tr>
<tr class="memdesc:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned char to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#a047b7dc5b55b2d13e2fd826c63872ea9">More...</a><br /></td></tr>
<tr class="separator:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dec5c23a659b2fca1c219fe783f88eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3dec5c23a659b2fca1c219fe783f88eb">vec_xfer_vui16t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> f128)</td></tr>
<tr class="memdesc:a3dec5c23a659b2fca1c219fe783f88eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned short to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#a3dec5c23a659b2fca1c219fe783f88eb">More...</a><br /></td></tr>
<tr class="separator:a3dec5c23a659b2fca1c219fe783f88eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0596ab318ba6d1ec5e7ed40871255a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> f128)</td></tr>
<tr class="memdesc:af0596ab318ba6d1ec5e7ed40871255a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned int to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">More...</a><br /></td></tr>
<tr class="separator:af0596ab318ba6d1ec5e7ed40871255a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8002c29875a226d11ec57a42b5b3955"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ae8002c29875a226d11ec57a42b5b3955">vec_xfer_vui64t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> f128)</td></tr>
<tr class="memdesc:ae8002c29875a226d11ec57a42b5b3955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned long long to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#ae8002c29875a226d11ec57a42b5b3955">More...</a><br /></td></tr>
<tr class="separator:ae8002c29875a226d11ec57a42b5b3955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b99b632646aaca91de6834e2b1da26"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">vec_xfer_vui128t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> f128)</td></tr>
<tr class="memdesc:a91b99b632646aaca91de6834e2b1da26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned __int128 to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">More...</a><br /></td></tr>
<tr class="separator:a91b99b632646aaca91de6834e2b1da26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add641f5a217eff45f0e836fa98613584"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#add641f5a217eff45f0e836fa98613584">vec_absf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:add641f5a217eff45f0e836fa98613584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the sign bit of __float128 input and return the resulting positive __float128 value.  <a href="vec__f128__ppc_8h.html#add641f5a217eff45f0e836fa98613584">More...</a><br /></td></tr>
<tr class="separator:add641f5a217eff45f0e836fa98613584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946ffd501b32f3ec96563ab101afbfad"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">vec_all_isfinitef128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a946ffd501b32f3ec96563ab101afbfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is Finite (Not NaN nor Inf).  <a href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">More...</a><br /></td></tr>
<tr class="separator:a946ffd501b32f3ec96563ab101afbfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fc4e7c94d0b30bb3515931aaf723da"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a66fc4e7c94d0b30bb3515931aaf723da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is infinity.  <a href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">More...</a><br /></td></tr>
<tr class="separator:a66fc4e7c94d0b30bb3515931aaf723da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06b73ac57985011c558670adc283e89"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:af06b73ac57985011c558670adc283e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is Not a Number (NaN).  <a href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">More...</a><br /></td></tr>
<tr class="separator:af06b73ac57985011c558670adc283e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc830b382bd45dc0ff815024c1bfb26d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">vec_all_isnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:afc830b382bd45dc0ff815024c1bfb26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">More...</a><br /></td></tr>
<tr class="separator:afc830b382bd45dc0ff815024c1bfb26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1a94cccdb3f106a0e6399e2f034718"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#adf1a94cccdb3f106a0e6399e2f034718">vec_all_issubnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:adf1a94cccdb3f106a0e6399e2f034718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is subnormal (denormal).  <a href="vec__f128__ppc_8h.html#adf1a94cccdb3f106a0e6399e2f034718">More...</a><br /></td></tr>
<tr class="separator:adf1a94cccdb3f106a0e6399e2f034718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac554a9d0d12fca036772aaaee5908414"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">vec_all_iszerof128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:ac554a9d0d12fca036772aaaee5908414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is +-0.0.  <a href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">More...</a><br /></td></tr>
<tr class="separator:ac554a9d0d12fca036772aaaee5908414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb73eac40698921735bad8ac4ce560e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e">vec_copysignf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128x, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128y)</td></tr>
<tr class="memdesc:adfb73eac40698921735bad8ac4ce560e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign bit from f128y and merge with the magnitude from f128x. The merged result is returned as a __float128 value.  <a href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e">More...</a><br /></td></tr>
<tr class="separator:adfb73eac40698921735bad8ac4ce560e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a0a30726ccfb216e4d2e1ede3854ab96b">vec_const_huge_valf128</a> ()</td></tr>
<tr class="memdesc:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a positive infinity.  <a href="vec__f128__ppc_8h.html#a0a30726ccfb216e4d2e1ede3854ab96b">More...</a><br /></td></tr>
<tr class="separator:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c68f73f69c4776bb054d42915e7103d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9c68f73f69c4776bb054d42915e7103d">vec_const_inff128</a> ()</td></tr>
<tr class="memdesc:a9c68f73f69c4776bb054d42915e7103d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a positive infinity.  <a href="vec__f128__ppc_8h.html#a9c68f73f69c4776bb054d42915e7103d">More...</a><br /></td></tr>
<tr class="separator:a9c68f73f69c4776bb054d42915e7103d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fb1013dfcf633156cd7f855a11fb56"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ()</td></tr>
<tr class="memdesc:af7fb1013dfcf633156cd7f855a11fb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a quiet NaN.  <a href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">More...</a><br /></td></tr>
<tr class="separator:af7fb1013dfcf633156cd7f855a11fb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac806c62ebaae6ab8faca87794cb917c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aac806c62ebaae6ab8faca87794cb917c">vec_const_nansf128</a> ()</td></tr>
<tr class="memdesc:aac806c62ebaae6ab8faca87794cb917c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a signaling NaN.  <a href="vec__f128__ppc_8h.html#aac806c62ebaae6ab8faca87794cb917c">More...</a><br /></td></tr>
<tr class="separator:aac806c62ebaae6ab8faca87794cb917c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec73dba497304699389a168256f32d29"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aec73dba497304699389a168256f32d29">vec_cmpeqtoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aec73dba497304699389a168256f32d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#aec73dba497304699389a168256f32d29">More...</a><br /></td></tr>
<tr class="separator:aec73dba497304699389a168256f32d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83177380e5feaacb1da72c99df1c6d82"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a83177380e5feaacb1da72c99df1c6d82">vec_cmpequzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a83177380e5feaacb1da72c99df1c6d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a83177380e5feaacb1da72c99df1c6d82">More...</a><br /></td></tr>
<tr class="separator:a83177380e5feaacb1da72c99df1c6d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3f85b4c3fe43ae58df0c72d1f29920"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a7e3f85b4c3fe43ae58df0c72d1f29920">vec_cmpequqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a7e3f85b4c3fe43ae58df0c72d1f29920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a7e3f85b4c3fe43ae58df0c72d1f29920">More...</a><br /></td></tr>
<tr class="separator:a7e3f85b4c3fe43ae58df0c72d1f29920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320639a93f8bc42359d9214a5e9c17e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ae320639a93f8bc42359d9214a5e9c17e">vec_cmpgttoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ae320639a93f8bc42359d9214a5e9c17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ae320639a93f8bc42359d9214a5e9c17e">More...</a><br /></td></tr>
<tr class="separator:ae320639a93f8bc42359d9214a5e9c17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbd885123cdb812bf19d2758cde202f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a6fbd885123cdb812bf19d2758cde202f">vec_cmpgtuzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a6fbd885123cdb812bf19d2758cde202f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a6fbd885123cdb812bf19d2758cde202f">More...</a><br /></td></tr>
<tr class="separator:a6fbd885123cdb812bf19d2758cde202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd8774bd68a914ac0fe3f66d16a8965"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4bd8774bd68a914ac0fe3f66d16a8965">vec_cmpgtuqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a4bd8774bd68a914ac0fe3f66d16a8965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a4bd8774bd68a914ac0fe3f66d16a8965">More...</a><br /></td></tr>
<tr class="separator:a4bd8774bd68a914ac0fe3f66d16a8965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1668ff13922ca04059f1844a7a1464f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ad1668ff13922ca04059f1844a7a1464f">vec_isfinitef128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:ad1668ff13922ca04059f1844a7a1464f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is Finite (Not NaN nor Inf).  <a href="vec__f128__ppc_8h.html#ad1668ff13922ca04059f1844a7a1464f">More...</a><br /></td></tr>
<tr class="separator:ad1668ff13922ca04059f1844a7a1464f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd9706acb775392282cfe4d4e3a03aa"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aebd9706acb775392282cfe4d4e3a03aa">vec_isinf_signf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aebd9706acb775392282cfe4d4e3a03aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true (nonzero) value if the __float128 value is infinity. For infinity indicate the sign as +1 for positive infinity and -1 for negative infinity.  <a href="vec__f128__ppc_8h.html#aebd9706acb775392282cfe4d4e3a03aa">More...</a><br /></td></tr>
<tr class="separator:aebd9706acb775392282cfe4d4e3a03aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a94f9c7429c2ebd9b9f32ad6e98689ebb">vec_isinff128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 128-bit vector boolean true if the __float128 value is infinity.  <a href="vec__f128__ppc_8h.html#a94f9c7429c2ebd9b9f32ad6e98689ebb">More...</a><br /></td></tr>
<tr class="separator:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c410994f958a6b4ac9583878a55a72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">vec_isnanf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a11c410994f958a6b4ac9583878a55a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN).  <a href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">More...</a><br /></td></tr>
<tr class="separator:a11c410994f958a6b4ac9583878a55a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25185c83b69f6af3f3d9399199c8a57"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aa25185c83b69f6af3f3d9399199c8a57">vec_isnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aa25185c83b69f6af3f3d9399199c8a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f128__ppc_8h.html#aa25185c83b69f6af3f3d9399199c8a57">More...</a><br /></td></tr>
<tr class="separator:aa25185c83b69f6af3f3d9399199c8a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9670e4655a9c7888c80343780cd7abf9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9670e4655a9c7888c80343780cd7abf9">vec_issubnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a9670e4655a9c7888c80343780cd7abf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true value, if the __float128 value is subnormal (denormal).  <a href="vec__f128__ppc_8h.html#a9670e4655a9c7888c80343780cd7abf9">More...</a><br /></td></tr>
<tr class="separator:a9670e4655a9c7888c80343780cd7abf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598a822d22b02ba0d2c2a1095a4e700d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a598a822d22b02ba0d2c2a1095a4e700d">vec_iszerof128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a598a822d22b02ba0d2c2a1095a4e700d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true value, if the value that is +-0.0.  <a href="vec__f128__ppc_8h.html#a598a822d22b02ba0d2c2a1095a4e700d">More...</a><br /></td></tr>
<tr class="separator:a598a822d22b02ba0d2c2a1095a4e700d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47637906e95a7c94cffc093bc2e57dbf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a47637906e95a7c94cffc093bc2e57dbf">vec_self128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb, <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> mask)</td></tr>
<tr class="memdesc:a47637906e95a7c94cffc093bc2e57dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value.  <a href="vec__f128__ppc_8h.html#a47637906e95a7c94cffc093bc2e57dbf">More...</a><br /></td></tr>
<tr class="separator:a47637906e95a7c94cffc093bc2e57dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73">vec_setb_qp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Set Bool from Quadword Floating-point.  <a href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73">More...</a><br /></td></tr>
<tr class="separator:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4ca7749d334c2a2c17a4d2a98b5bf755">vec_signbitf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return int boolean true if the __float128 value is negative (sign bit is '1').  <a href="vec__f128__ppc_8h.html#a4ca7749d334c2a2c17a4d2a98b5bf755">More...</a><br /></td></tr>
<tr class="separator:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95c675ceebc0627c777d2c7e2daef0b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> sig, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp)</td></tr>
<tr class="memdesc:af95c675ceebc0627c777d2c7e2daef0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Insert Exponent Quad-Precision.  <a href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">More...</a><br /></td></tr>
<tr class="separator:af95c675ceebc0627c777d2c7e2daef0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d78e42d9cc58491fa46149bf5798167"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a3d78e42d9cc58491fa46149bf5798167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Extract Exponent Quad-Precision.  <a href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">More...</a><br /></td></tr>
<tr class="separator:a3d78e42d9cc58491fa46149bf5798167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eb10beac182e936d7e49d491c34fe0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">vec_xsxsigqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:ab1eb10beac182e936d7e49d491c34fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Extract Significand Quad-Precision.  <a href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">More...</a><br /></td></tr>
<tr class="separator:ab1eb10beac182e936d7e49d491c34fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over Quad-Precision floating point elements. </p>
<p>PowerISA 3.0B added Quad-Precision floating point type and operations to the Vector-Scalar Extension (VSX) facility. The first hardware implementation is available in POWER9.</p>
<p>PowerISA 3.1 added new min/max/compare Quad-Precision operations. Also added new quadword (128-bit) integer operations including converts between quadword integer and Quad-Precision floating point. The first hardware implementation is available in POWER10.</p>
<p>While all Quad-Precision operations are on 128-bit vector registers, they are defined as scalars in the PowerISA. The OpenPOWER ABI also treats the __float128 type as scalar that just happens to use vector registers for parameter passing and operations. As such no operations using __float128 (_Float128, or __ieee128) as parameter or return value are defined as vector built-ins in the ABI or &lt;altivec.h&gt;.</p>
<dl class="section note"><dt>Note</dt><dd>GCC 8.2 does document some built-ins, using the <em>scalar</em> prefix (scalar_extract_exp, scalar_extract_sig, scalar_test_data_class), that do accept the __ieee128 type. This work seems to be incomplete as scalar_exp_cmp_* for the __ieee128 type are not present. GCC 7.3 defines vector and scalar forms of the extract/insert_exp for float and double but not for __ieee128. These built-ins are not defined in GCC 6.4. See <a href="https://gcc.gnu.org/onlinedocs/">compiler documentation</a>. These are useful operations and can be implement in a few vector logical instruction for earlier machines. So it seems reasonable to add these to pveclib for both vector and scalar forms.</dd></dl>
<p>Quad-Precision is not supported in hardware until POWER9. However the compiler and runtime supports the __float128 type and arithmetic operations via soft-float emulation for earlier processors. The soft-float implementation follows the ABI and passes __float128 parameters and return values in vector registers.</p>
<p>So it is not unreasonable for this header to provide vector forms of the __float128 classification functions (isnormal/subnormal/finite/inf/nan/zero, copysign, and abs). These functions can be implemented directly using (one or more) POWER9 instructions, or a few vector logical and integer compare instructions for POWER7/8. Each is comfortably small enough to be in-lined and inherently faster than the equivalent POSIX or compiler built-in runtime functions. Performing these operations in-line and directly in vector registers (VRs) avoids call/return and VR &lt;-&gt; GPR transfer overhead.</p>
<p>It also seems reasonable to provide Quad-Precision extract/insert exponent/significand and compare exponent operations for POWER7/8. And with the PowerISA 3.1 release providing POWER9/8 implementations of min/max/convert/compare.</p>
<p>These PVECLIB operations should be useful for applications using Quad-Precision while needing to still support POWER8. They should also be useful and improve performance for soft-float implementations of math library functions.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power8</b>, Quad-Precision floating-point built-ins operations useful for floating point classification are not defined. This header provides the appropriate substitutions, will generate the minimum code, appropriate for the target, and produce correct results.</dd>
<dd>
Most ppc64le compilers will default to <b>-mcpu=</b><em>power8</em> if <b>-mcpu</b> is not specified.</dd></dl>
<p>This header covers operations that are any of the following:</p>
<ul>
<li>Implemented in hardware instructions in newer processors, but useful to programmers on slightly older processors (even if the equivalent function requires more instructions).</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.h&gt; provided by available compilers in common use. Examples include scalar_test_neg, scalar_test_data_class, etc.</li>
<li>Providing special vector float tests for special conditions without generating extraneous floating-point exceptions. This is important for implementing __float128 forms of ISO C99 Math functions. Examples include vector isnan, isinf, etc.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious.</li>
</ul>
<h1><a class="anchor" id="f128_softfloat_0_0"></a>
Vector implementation of Quad-Precision Soft-float</h1>
<p>The discussion above raises a interesting question. If we can provide useful implementations of Quad-Precision; classification, extract/insert, and compare exponent operations, why not continue with Quad-Precision compare, convert to/from integer, and arithmetic operations?</p>
<p>This raises the stakes in complexity and size of implementation. Providing a vector soft-float implementation equivalent to the GCC run-time libgcc <b>__addkf3/__divkf3/__mulkf3/__subkf3</b> would be a substantial effort. The IEEE standard is exacting about rounding and exception handling. Comparisons require special handling of; signed zero, infinities, and NaNs. Even float/integer conversions require correct rounding and return special values for overflow. Also it is not clear how such an effort would be accepted.</p>
<p>The good news is PVECLIB already provides a strong quadword integer operations set. Integer Add, subtract, and multiply are covered with the usual compare/shift/rotate operations (See <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>). The weak spot is general quadword integer divide. Until recently, integer divide has not been part of the vector ISA. But the introduction of Vector Divide Signed/Unsigned Quadword in POWER10 raises the priority of vector integer divide for PVECLIB.</p>
<p>For now we propose a phased approach, starting with enablers and infrastructure, building up layers, starting simple and adding complexity.</p>
<ul>
<li>Basic enablers; classification, extract/insert exponent, compare exponent.</li>
<li>Quad-Precision comparison operators.<ul>
<li>Initially ignore special cases and exceptions</li>
<li>Add Signed Zero, Infinity. and NaN special cases</li>
<li>Exceptions when someone asks</li>
</ul>
</li>
<li>Quad-Precision from/to integer word/doubleword/quadword.<ul>
<li>Cases that don't require rounding (i.e truncate and DW to QP).</li>
<li>Cases that require rounding<ul>
<li>Round to odd</li>
<li>Round to Nearest/Even</li>
<li>Others if asked</li>
</ul>
</li>
</ul>
</li>
<li>Quad-Precision arithmetic<ul>
<li>Add/Sub/Mul<ul>
<li>Round-to-Odd first</li>
<li>Initially ignore special cases and exceptions</li>
</ul>
</li>
<li>Fused Multiply-Add<ul>
<li>Round-to-Odd first</li>
</ul>
</li>
<li>Divide<ul>
<li>Round-to-Odd first</li>
</ul>
</li>
<li>Add Signed Zero, Infinity. and NaN special cases</li>
<li>Other rounding modes</li>
<li>Exceptions when someone asks</li>
</ul>
</li>
</ul>
<p>The intent is that such PVECLIB operations can be mixed in with or substituted for C Language _FLoat128 expressions or functions. The in-lined operations should have performance advantages over equivalent library functions on both POWER8/9.</p>
<p>This is a big list. It is TBD how far I will get given my current limited resources.</p>
<dl class="section note"><dt>Note</dt><dd>We are focusing on POWER8 here because the implementation gets a lot harder for POWER7 and earlier. POWER7 is missing: Quadword integer add/sub with carry extend. Wide (word) integer multiply. Direct transfer between VRs and GPRs. Doubleword integer arithmetic, compares. and count-leading zeros.</dd></dl>
<h2><a class="anchor" id="f128_softfloat_0_0_0"></a>
Quad-Precision data class and exponent access for POWER8</h2>
<p>Most math library functions need to test the data class (normal, infinity, NaN, etc) and or range of input values. This usually involves separating the sign, exponent, and significand out from __float128 values, and comparing one or more of these parts, to special integer values.</p>
<p>PowerISA 3.0B (POWER9) provides instructions for these in addition to a comprehensive set of arithmetic and compare instructions. These operations are also useful for the soft-float implementation of __float128 for POWER8 and earlier. The OpenPOWER ABI specifies __float128 parameters are in VRs and are immediately accessible to VMX/VSR instructions. This is important as the cost of transferring values between VRs and GPRs is quite high on POWER8 and even higher for POWER7 and earlier (which requires store to temporaries and reload).</p>
<p>Fortunately these operations only require logical (and/or/xor), shift and integer compare operations to implement. These are available as vector intrinsics or provides by PVECLIB (see <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>).</p>
<p>The operations in this group include:</p><ul>
<li>Altivec like predicates; <a class="el" href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad" title="Return true if the __float128 value is Finite (Not NaN nor Inf).">vec_all_isfinitef128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da" title="Return true if the __float128 value is infinity.">vec_all_isinff128()</a>, <a class="el" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89" title="Return true if the __float128 value is Not a Number (NaN).">vec_all_isnanf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d" title="Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).">vec_all_isnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#adf1a94cccdb3f106a0e6399e2f034718" title="Return true if the __float128 value is subnormal (denormal).">vec_all_issubnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414" title="Return true if the __float128 value is +-0.0.">vec_all_iszerof128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a4ca7749d334c2a2c17a4d2a98b5bf755" title="Return int boolean true if the __float128 value is negative (sign bit is &#39;1&#39;).">vec_signbitf128()</a>.</li>
<li>Vector boolean predicates; <a class="el" href="vec__f128__ppc_8h.html#ad1668ff13922ca04059f1844a7a1464f" title="Return 128-bit vector boolean true if the __float128 value is Finite (Not NaN nor Inf).">vec_isfinitef128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a94f9c7429c2ebd9b9f32ad6e98689ebb" title="Return a 128-bit vector boolean true if the __float128 value is infinity.">vec_isinff128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72" title="Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN).">vec_isnanf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#aa25185c83b69f6af3f3d9399199c8a57" title="Return 128-bit vector boolean true if the __float128 value is normal (Not NaN, Inf,...">vec_isnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a9670e4655a9c7888c80343780cd7abf9" title="Return 128-bit vector boolean true value, if the __float128 value is subnormal (denormal).">vec_issubnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a598a822d22b02ba0d2c2a1095a4e700d" title="Return 128-bit vector boolean true value, if the value that is +-0.0.">vec_iszerof128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73" title="Vector Set Bool from Quadword Floating-point.">vec_setb_qp()</a>.</li>
<li>Data manipulation; <a class="el" href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e" title="Copy the sign bit from f128y and merge with the magnitude from f128x. The merged result is returned a...">vec_copysignf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b" title="Scalar Insert Exponent Quad-Precision.">vec_xsiexpqp()</a>, <a class="el" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167" title="Scalar Extract Exponent Quad-Precision.">vec_xsxexpqp()</a>, <a class="el" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0" title="Scalar Extract Significand Quad-Precision.">vec_xsxsigqp()</a>.</li>
<li>Exponent Compare; TBD: The compare exponent quad-precision operation defined for P9.</li>
</ul>
<p>For example the data class test isnan: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line"><a class="code" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">vec_isnanf128</a> (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR9) &amp;&amp; defined (scalar_test_data_class) &amp;&amp; \</span></div>
<div class="line"><span class="preprocessor">  defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> result = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (scalar_test_data_class (f128, 0x40))</div>
<div class="line">    result = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(-1, -1, -1, -1);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>)result;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> tmp;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x7fff0000, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line">  tmp = <a class="code" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (f128, signmask);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>)tmp , (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>)expmask);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">}</span></div>
</div><!-- fragment --><p> Which has implementations for POWER9 (and later) and POWER8 (and earlier).</p>
<p>For POWER9 it generates: </p><div class="fragment"><div class="line">xststdcqp cr0,v2,64</div>
<div class="line">bne     .+12</div>
<div class="line">xxspltib vs34,255</div>
<div class="line">b       .+8</div>
<div class="line">xxspltib vs34,0</div>
</div><!-- fragment --><p> Which uses the intrinsic scalar_test_data_class() to generate the VSX Scalar Test Data Class Quad-Precision instruction with "data class mask" of <em>class.NaN</em> to set the condition code. If the condition is <em>match</em>, load the 128-bit bool value of all 1's (true). Otherwise load all 0's (false).</p>
<p>For POWER8 it generates </p><div class="fragment"><div class="line">addis   r9,r2,@ha.rodata.cst16+0x30</div>
<div class="line">vspltisw v1,-1</div>
<div class="line">vspltisw v12,0</div>
<div class="line">addi    r9,r9,@l.rodata.cst16+0x30</div>
<div class="line">vslw    v1,v1,v1</div>
<div class="line">lvx     v0,0,r9</div>
<div class="line">vsldoi  v1,v1,v12,12</div>
<div class="line"> </div>
<div class="line">xxlandc vs33,vs34,vs33</div>
<div class="line">vsubcuq v0,v0,v1</div>
<div class="line">xxspltw vs32,vs32,3</div>
<div class="line">vcmpequw v2,v0,v12</div>
</div><!-- fragment --><p> The first 7 instructions above, load the constant vectors needed by the logic. These constants only need to be generated once per function and can be shared across operations.</p>
<p>In the C code we use a special transfer function combined with logical AND complement (<a class="el" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab" title="Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask.">vec_andc_bin128_2_vui32t()</a>). This is required because while __float128 values are held in VRs, the compiler considers them to be scalars and will not allow simple casts to (any) vector type. So the PVECLIB implementation provides <em>xfer</em> function using a unions to transfer the __float128 value to a vector type. In most case this logical transfer simply serves to make the compiler happy and does not need to generate any code. In this case the <em>xfer</em> function combines the transfer with a vector and complement to mask off the sign bit.</p>
<p>Then compare the masked result as a 128-bit integer value greater than infinity (expmask). Here we use the <a class="el" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e" title="Vector Compare Greater Than Unsigned Quadword.">vec_cmpgtuq()</a> operation from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>. For POWER8, <a class="el" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e" title="Vector Compare Greater Than Unsigned Quadword.">vec_cmpgtuq()</a> generates the Vector Subtract and Write Carry Unsigned Quadword instruction for 128-bit unsigned compares. A '0' carry indicates greater than. The next two instructions (from <a class="el" href="vec__int128__ppc_8h.html#a921647d5b67f0de5006ee32fb3d9c4f1" title="Vector Set Bool from Quadword not Carry.">vec_setb_ncq()</a>) convert the carry bit to the required 128-bit bool value.</p>
<p>While the POWER8 sequence requires more instructions (including the const vector set up) than POWER9, it is not significantly larger. And as mentioned above, the set-up code can be optimized across operations sharing the same constants. The code (less the setup) is only 10 cycles for POWER8 vs 6 for POWER9. Also the code is not any larger than the function call overhead for the libgcc runtime equivalent <b>__unordkf2</b>. And is much faster then the generic soft-float implementation.</p>
<p>Another example, Scalar Extract Exponent Quad-Precision:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div>
<div class="line"><a class="code" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR9) &amp;&amp; defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xsxexpqp %0,%1&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (f128)</div>
<div class="line">      : );</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> tmp;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x7fff0000, 0, 0, 0)</div>
<div class="line"> </div>
<div class="line">  tmp = <a class="code" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (f128, expmask);</div>
<div class="line">  result = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) vec_sld (tmp, tmp, 10);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Which has implementations for POWER9 (and later) and POWER8 (and earlier).</p>
<p>For POWER9 it generates the VSX Scalar Extract Exponent Quad-Precision instruction. </p><div class="fragment"><div class="line">xsxexpqp v2,v2</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Should use the intrinsic scalar_extract_exp() here but this is not available until GCC 11. So use in-line assembler until the internsic is available and verified.</dd></dl>
<p>For POWER8 we generate </p><div class="fragment"><div class="line">addis   r9,r2,.rodata.cst16+0xc0@ha</div>
<div class="line">addi    r9,r9,.rodata.cst16+0xc0@l</div>
<div class="line">lvx     v13,0,r9</div>
<div class="line"> </div>
<div class="line">xxland  vs34,vs34,vs45</div>
<div class="line">vsldoi  v2,v2,v2,10</div>
</div><!-- fragment --><p> The first 3 instructions above load the constant vector needed by the logic. This constant only needs to be generated once per function and can be shared across operations.</p>
<p>Again we use a special transfer function combined with logical AND (<a class="el" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e" title="Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask.">vec_and_bin128_2_vui32t()</a>) to transfer the__float128 to a vector type and mask off all bits except for the 15-bit exponent. Then we rotate the exponent logically right 48-bit to right justify the exponent in vector doubleword 0. This matches the results of the xsxexpqp instruction.</p>
<h2><a class="anchor" id="f128_softfloat_0_0_1"></a>
Quad-Precision compares for POWER8</h2>
<p>IEEE floating-point compare is a bit more complicated than binary integer compare operations. The two main complications are; Not-a-Number (NaN) which IEEE insists are <em>unordered</em>, and signed 0.0 where IEEE insists that -0.0 is equal to +0.0. If you ignore the NaN and signed 0.0 cases you can treat floating-point as signed magnitude binary integers, and use integer compares and boolean logic. Which looks like this:</p>
<ul>
<li>a =<sup>f</sup> b == (a =<sup>s</sup> b)</li>
<li>a &lt;<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;<sup>s</sup> b) | (a &lt;<sup>s</sup> 0 &amp; a &gt;<sup>u</sup> b)</li>
<li>a &lt;=<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;=<sup>s</sup> b) | (a &lt;<sup>s</sup> 0 &amp; a &gt;=<sup>u</sup> b)</li>
</ul>
<p>Where; =<sup>f</sup>, &lt;<sup>f</sup>, and &lt;=<sup>f</sup> are the desired floating-point compares, =<sup>s</sup>, &lt;<sup>s</sup>, &lt;=<sup>s</sup>, &gt;<sup>s</sup> and &gt;=<sup>s</sup>, are signed integer compares, and =<sup>s</sup>, &gt;<sup>u</sup>, and &gt;=<sup>u</sup> are unsigned integer compares.</p>
<dl class="section see"><dt>See also</dt><dd>"Hacker's Delight, 2nd Edition," Henry S. Warren, Jr, Addison Wesley, 2013. Chapter 17, Floating-point, Section 17-3 Comparing Floating-Point Numbers Using Integer Operations.</dd></dl>
<p>One key implication of this is that we will need signed and unsigned 128-bit compare operations. Instructions for 128-bit integer compares was added for PowerISA 3.1 (POWER10) but we also need to support POWER8/9. The good news is that PowerISA 2.07B (POWER8) includes Vector Add/Subtract Modulo/Carry/Extend Quadword instructions. Specifically Vector Subtract &amp; write Carry Unsigned Quadword can implement all the unsigned ordered (&lt;. &lt;=, &gt;, &gt;=) compares by manipulating the comparand order and evaluating the carry for 0 or 1.</p>
<p>POWER8 also includes vector doubleword integer compare instructions. And the Vector Compare Equal To Unsigned Doubleword instruction can be used with a few additional logical operations to implement 128-bit equal and not equal operations. These operations are already provided by <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<p>Some additional observations:</p><ul>
<li>The unsigned compare equal can be used for unsigned or signed integers.</li>
<li>(a &gt;=<sup>s</sup> 0) == ~(a &lt;<sup>s</sup> 0).<ul>
<li>So we only need one compare boolean and the binary NOT.</li>
<li>((a &gt;=<sup>s</sup> 0) &amp; a &lt;<sup>s</sup> b) | (~(a &gt;=<sup>s</sup> 0) &amp; a &gt;<sup>u</sup> b).</li>
<li>Now this starts to look like a vector select operation.</li>
<li>(src1 &amp; ~mask) | (src2 &amp; mask)</li>
</ul>
</li>
<li>(a &gt;=<sup>s</sup> 0) is a special case that only depends on the sign-bit.<ul>
<li>A unsigned compare can be used with a slight change,</li>
<li>Propagating the sign-bit across the (quad)word generates the same boolean. This is the <a class="el" href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802" title="Vector Set Bool from Signed Quadword.">vec_setb_sq()</a> operation. The __float128 variant is <a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73" title="Vector Set Bool from Quadword Floating-point.">vec_setb_qp()</a></li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The examples that follow, use vector __int128 parameters instead of __binary128 to avoid the hassles of cast incompatibility between scalar __binary128's and vector types. The actual implementations use the xfer functions.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line">test_cmpltf128_v1c (<a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfa128, <a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfb128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> altb, agtb;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> signbool;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Replace (vfa &gt;= 0) with (vfa &lt; 0) == vec_setb_qp (vfa)</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> shift = vec_splat_u8 (7);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> splat = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfa128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  signbool = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (splat, shift);</div>
<div class="line"> </div>
<div class="line">  altb = <a class="code" href="vec__int128__ppc_8h.html#a82d83d78ff2330205a8d74741b34a1be">vec_cmpltsq</a> (vfa128, vfb128);</div>
<div class="line">  agtb = <a class="code" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfa128, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfb128);</div>
<div class="line">  result = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)altb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)agtb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)signbool);</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we can tackle the pesky signed 0.0 case. The simplest method is to add another term that test for either a or b is -0.0. This simplifies to just logical a OR b and unsigned compare to -0.0. Which looks like this:</p>
<ul>
<li>a =<sup>f</sup> b == (a =<sup>s</sup> b) | ((a | b) == 0x80000000...0)</li>
<li>a &lt;<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;<sup>s</sup> b) | ((a &lt;<sup>s</sup> 0 &amp; a &gt;<sup>u</sup> b) &amp; ((a | b) != 0x80000000...0))</li>
<li>a &lt;=<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;=<sup>s</sup> b) | ((a &lt;<sup>s</sup> 0 &amp; a &gt;=<sup>u</sup> b) | ((a | b) == 0x80000000...0))</li>
</ul>
<p>Again we can replace signed compares (a &gt;= 0) and (a &lt; 0) with a single <a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73" title="Vector Set Bool from Quadword Floating-point.">vec_setb_qp()</a> and simplify the boolean logic by using vec_sel(). For the ((a | b) != 0x80000000...0) term we can save an instruction by replacing <a class="el" href="vec__int128__ppc_8h.html#a186d0b94bbc652e700ab4e1733b9524c" title="Vector Compare Not Equal Unsigned Quadword.">vec_cmpneuq()</a> with <a class="el" href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0" title="Vector Compare Equal Unsigned Quadword.">vec_cmpequq()</a> and replacing the AND operation with AND compliment. </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line">test_cmpltf128_v2c (<a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfa128, <a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfb128)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> altb, agtb, nesm;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> or_ab;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> signbool;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Replace (vfa &gt;= 0) with (vfa &lt; 0) == vec_setb_qp (vfa)</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> shift = vec_splat_u8 (7);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> splat = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfa128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  signbool = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (splat, shift);</div>
<div class="line"> </div>
<div class="line">  altb = <a class="code" href="vec__int128__ppc_8h.html#a82d83d78ff2330205a8d74741b34a1be">vec_cmpltsq</a> (vfa128, vfb128);</div>
<div class="line">  agtb = <a class="code" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfa128, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfb128);</div>
<div class="line"> </div>
<div class="line">  or_ab = vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfa128, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfb128 );</div>
<div class="line">  <span class="comment">// For ne compare eq and and compliment</span></div>
<div class="line">  nesm = <a class="code" href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0">vec_cmpequq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) or_ab, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) signmask);</div>
<div class="line">  agtb = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_andc ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) agtb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) nesm);</div>
<div class="line">  <span class="comment">// select altb for 0&#39;s and agtb for 1&#39;s</span></div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)altb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)agtb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)signbool);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This sequence runs27 instructions when you include the constant loads.</p>
<p>An alternative compare method converts both floating-point values in a way that a single (unsigned) integer compare can be used.</p>
<div class="fragment"><div class="line"><span class="comment">// for each comparand</span></div>
<div class="line"> <span class="keywordflow">if</span> (n &gt;= 0)</div>
<div class="line">   n = n + 0x80000000;</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">   n = -n;</div>
<div class="line"><span class="comment">// Use unsigned integer comparison</span></div>
</div><!-- fragment --><p> An interesting feature of this method is that +0.0 becomes (0x00000000 + 0x80000000 = 0x80000000) and -0.0 becomes (0x80000000 - 0x80000000 = 0x80000000) which effectively converts any -0.0 into +0.0 for comparison. Signed 0.0 solved.</p>
<p>Another optimization converts (n = n + 0x80000000) to (n = n XOR 0x80000000). Gives the same result and for POWER8 a vec_xor() is 2 cycles latency vs 4 cycles for _vec_adduqm().</p>
<div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line">test_cmpltf128_v3d (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vfa128, <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vfb128)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> shift = vec_splat_u8 (7);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> result;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> age0, bge0;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vra, vrap, vran;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vrb, vrbp, vrbn;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> splta, spltb;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// signbool = vec_setb_qp;</span></div>
<div class="line">  splta = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfa128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  age0 = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (splta, shift);</div>
<div class="line"> </div>
<div class="line">  vrap = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_xor ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfa128, signmask);</div>
<div class="line">  vran = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) zero, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfa128);</div>
<div class="line">  vra  = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrap, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vran, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)age0);</div>
<div class="line"> </div>
<div class="line">  spltb = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfb128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  bge0 = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (spltb, shift);</div>
<div class="line"> </div>
<div class="line">  vrbp = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_xor ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfb128, signmask);</div>
<div class="line">  vrbn = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) zero, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfb128);</div>
<div class="line">  vrb  = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrbp, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrbn, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)bge0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int128__ppc_8h.html#a7f9ebc5ad32b151a3e08136d51aad4dc">vec_cmpltuq</a> (vra, vrb);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This sequence runs (approximately) 20 instructions when you include loading the required constants. It also manages to use only splat-immediate forms to load constants and so does not need to establish the TOC pointer nor any address calculations to access constants via load instructions.</p>
<p>The next IEEE issue is detecting NaNs and returning <em>unordered</em> status. Adding the following code to a compare operation insures that if either comparand is NaN; false (unordered) is returned for compares (eq, lt, gt).</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (vfa) || <a class="code" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (vfb))</div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_splat_u32 (0);</div>
</div><!-- fragment --><p> The pair of <a class="el" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89" title="Return true if the __float128 value is Not a Number (NaN).">vec_all_isnanf128()</a> operations add significant overhead both in code size (39 instructions) and cycles. This form should only be used if is required for correct results and has not been tested by prior logic in this code path.</p>
<dl class="section note"><dt>Note</dt><dd>At this point we are not trying to comply with PowerISA by setting any FPSCR bits associated with Quad-Precision compare. If such is required, VXSNAN and/or VXVC can be set using the Move To FPSCR Bit 1 (mtfsb1) instruction.</dd></dl>
<h2><a class="anchor" id="f128_softfloat_0_0_2"></a>
Quad-Precision converts for POWER8</h2>
<p>TBD.</p>
<h1><a class="anchor" id="f128_examples_0_0"></a>
Examples</h1>
<p>For example: using the the classification functions for implementing the math library function sine and cosine. The Posix specification requires that special input values are processed without raising extraneous floating point exceptions and return specific floating point values in response. For example the sin() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>value</em>.</li>
<li>If the input <em>value</em> is subnormal then return <em>value</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a NaN.</li>
<li>Otherwise compute and return sin(value).</li>
</ul>
<p>The following code example uses functions from this header to address the POSIX requirements for special values input to sinf128(): </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line">test_sinf128 (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> value)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">vec_all_isnormalf128</a> (value))</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// body of taylor series.</span></div>
<div class="line">      ...</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (value))</div>
<div class="line">        result = <a class="code" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ();</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        result = value;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For another example the cos() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>1.0</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a NaN.</li>
<li>Otherwise compute and return cos(value).</li>
</ul>
<p>The following code example uses functions from this header to address the Posix requirements for special values input to cosf128(): </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line">test_cosf128 (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> value)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">vec_all_isfinitef128</a> (value))</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">vec_all_iszerof128</a> (value))</div>
<div class="line">        result = 1.0Q;</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// body of taylor series ...</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (value))</div>
<div class="line">        result = <a class="code" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ();</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        result = value;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Neither example raises floating point exceptions or sets <b>errno</b>, as appropriate for a vector math library.</p>
<h1><a class="anchor" id="f128_perf_0_0"></a>
Performance data</h1>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="add641f5a217eff45f0e836fa98613584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add641f5a217eff45f0e836fa98613584">&#9670;&nbsp;</a></span>vec_absf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_absf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the sign bit of __float128 input and return the resulting positive __float128 value. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value containing a signed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128 and a positive sign of f128. </dd></dl>

</div>
</div>
<a id="a946ffd501b32f3ec96563ab101afbfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946ffd501b32f3ec96563ab101afbfad">&#9670;&nbsp;</a></span>vec_all_isfinitef128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isfinitef128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary128 finite value has an exponent between 0x0000 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value. Using the !vec_all_eq compare conditional verify this condition and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="a66fc4e7c94d0b30bb3515931aaf723da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fc4e7c94d0b30bb3515931aaf723da">&#9670;&nbsp;</a></span>vec_all_isinff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isinff128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. Using the vec_all_eq compare conditional verifies both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="af06b73ac57985011c558670adc283e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06b73ac57985011c558670adc283e89">&#9670;&nbsp;</a></span>vec_all_isnanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnanf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is Not a Number (NaN). </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. Using the combined vec_all_eq / vec_any_gt compare conditional verify both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-29 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="afc830b382bd45dc0ff815024c1bfb26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc830b382bd45dc0ff815024c1bfb26d">&#9670;&nbsp;</a></span>vec_all_isnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary128 normal value has an exponent between 0x0001 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). Using the combined vec_all_ne compares conditional verify both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-29 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="adf1a94cccdb3f106a0e6399e2f034718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1a94cccdb3f106a0e6399e2f034718">&#9670;&nbsp;</a></span>vec_all_issubnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_issubnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is subnormal (denormal). </p>
<p>A IEEE Binary128 subnormal has an exponent of 0x0000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-29 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary128 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if the __float128 value is subnormal. </dd></dl>

</div>
</div>
<a id="ac554a9d0d12fca036772aaaee5908414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac554a9d0d12fca036772aaaee5908414">&#9670;&nbsp;</a></span>vec_all_iszerof128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_iszerof128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is +-0.0. </p>
<p>A IEEE Binary128 zero has an exponent of 0x0000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if the __float128 value is +/- zero. </dd></dl>

</div>
</div>
<a id="aae0e62b9910ec833dfc20719d09e526e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0e62b9910ec833dfc20719d09e526e">&#9670;&nbsp;</a></span>vec_and_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_and_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value ANDed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="a796440333ee623aa782ef3eb5a021587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796440333ee623aa782ef3eb5a021587">&#9670;&nbsp;</a></span>vec_andc_bin128_2_vui128t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_andc_bin128_2_vui128t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector __int128 and logical AND Compliment with mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned __int128 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value ANDed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="aedfcf3adea80e0407b40c6ec0e851aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfcf3adea80e0407b40c6ec0e851aab">&#9670;&nbsp;</a></span>vec_andc_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_andc_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value ANDed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="aec73dba497304699389a168256f32d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec73dba497304699389a168256f32d29">&#9670;&nbsp;</a></span>vec_cmpeqtoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpeqtoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa == vfb, otherwise all '0's. Zeros, Infinities and NaN of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or a VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a7e3f85b4c3fe43ae58df0c72d1f29920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3f85b4c3fe43ae58df0c72d1f29920">&#9670;&nbsp;</a></span>vec_cmpequqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpequqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa == vfb, otherwise all '0's. Zeros of either sign compare equal. Infinities of the same sign compare equal. A NaN in either or both operands compare unequal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">18-30 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a83177380e5feaacb1da72c99df1c6d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83177380e5feaacb1da72c99df1c6d82">&#9670;&nbsp;</a></span>vec_cmpequzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpequzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa == vfb, otherwise all '0's. Zeros of either sign compare equal. Infinities and NaNs of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or a VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="ae320639a93f8bc42359d9214a5e9c17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae320639a93f8bc42359d9214a5e9c17e">&#9670;&nbsp;</a></span>vec_cmpgttoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgttoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt; vfb, otherwise all '0's. Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a4bd8774bd68a914ac0fe3f66d16a8965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd8774bd68a914ac0fe3f66d16a8965">&#9670;&nbsp;</a></span>vec_cmpgtuqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgtuqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt; vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a6fbd885123cdb812bf19d2758cde202f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbd885123cdb812bf19d2758cde202f">&#9670;&nbsp;</a></span>vec_cmpgtuzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgtuzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt; vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a0a30726ccfb216e4d2e1ede3854ab96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a30726ccfb216e4d2e1ede3854ab96b">&#9670;&nbsp;</a></span>vec_const_huge_valf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_huge_valf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a positive infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>const __float128 positive infinity. </dd></dl>

</div>
</div>
<a id="a9c68f73f69c4776bb054d42915e7103d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c68f73f69c4776bb054d42915e7103d">&#9670;&nbsp;</a></span>vec_const_inff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_inff128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a positive infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 positive infinity. </dd></dl>

</div>
</div>
<a id="af7fb1013dfcf633156cd7f855a11fb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fb1013dfcf633156cd7f855a11fb56">&#9670;&nbsp;</a></span>vec_const_nanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_nanf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a quiet NaN. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 quiet NaN. </dd></dl>

</div>
</div>
<a id="aac806c62ebaae6ab8faca87794cb917c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac806c62ebaae6ab8faca87794cb917c">&#9670;&nbsp;</a></span>vec_const_nansf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_nansf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a signaling NaN. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 signaling NaN. </dd></dl>

</div>
</div>
<a id="adfb73eac40698921735bad8ac4ce560e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb73eac40698921735bad8ac4ce560e">&#9670;&nbsp;</a></span>vec_copysignf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_copysignf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the sign bit from f128y and merge with the magnitude from f128x. The merged result is returned as a __float128 value. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128x</td><td>a __float128 value containing the magnitude. </td></tr>
    <tr><td class="paramname">f128y</td><td>a __float128 value containing the sign bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128x and the sign of f128y. </dd></dl>

</div>
</div>
<a id="ad1668ff13922ca04059f1844a7a1464f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1668ff13922ca04059f1844a7a1464f">&#9670;&nbsp;</a></span>vec_isfinitef128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isfinitef128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary128 finite value has an exponent between 0x0000 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value. Using the vec_cmpeq conditional to generate the predicate mask for NaN / Inf and then invert this for the finite condition. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="aebd9706acb775392282cfe4d4e3a03aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd9706acb775392282cfe4d4e3a03aa">&#9670;&nbsp;</a></span>vec_isinf_signf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_isinf_signf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true (nonzero) value if the __float128 value is infinity. For infinity indicate the sign as +1 for positive infinity and -1 for negative infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. Using the vec_all_eq compare conditional verifies both conditions. A subsequent vec_any_gt checks the sign bit and set the result appropriately. The sign bit is ignored.</p>
<p>This sequence avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12-32 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3-12 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 if not infinity and +1/-1 otherwise. </dd></dl>

</div>
</div>
<a id="a94f9c7429c2ebd9b9f32ad6e98689ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f9c7429c2ebd9b9f32ad6e98689ebb">&#9670;&nbsp;</a></span>vec_isinff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isinff128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a 128-bit vector boolean true if the __float128 value is infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s.. </dd></dl>

</div>
</div>
<a id="a11c410994f958a6b4ac9583878a55a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c410994f958a6b4ac9583878a55a72">&#9670;&nbsp;</a></span>vec_isnanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isnanf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN). </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. This requires a combination of verifying the exponent and that any bit of the significand is nonzero. Using the combined vec_all_eq / vec_any_gt compare conditional verify both conditions before negating the result from zero to all ones.. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="aa25185c83b69f6af3f3d9399199c8a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25185c83b69f6af3f3d9399199c8a57">&#9670;&nbsp;</a></span>vec_isnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary128 normal value has an exponent between 0x0001 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="a9670e4655a9c7888c80343780cd7abf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9670e4655a9c7888c80343780cd7abf9">&#9670;&nbsp;</a></span>vec_issubnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_issubnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true value, if the __float128 value is subnormal (denormal). </p>
<p>A IEEE Binary128 subnormal has an exponent of 0x0000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">16-25 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a598a822d22b02ba0d2c2a1095a4e700d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598a822d22b02ba0d2c2a1095a4e700d">&#9670;&nbsp;</a></span>vec_iszerof128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_iszerof128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true value, if the value that is +-0.0. </p>
<p>A IEEE Binary64 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a2843ee28bf45b6e7589f2b1d073a2187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2843ee28bf45b6e7589f2b1d073a2187">&#9670;&nbsp;</a></span>vec_sel_bin128_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_sel_bin128_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">vfb</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector bool __int128 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit of vfa or vfb depending on the mask. </dd></dl>

</div>
</div>
<a id="a47637906e95a7c94cffc093bc2e57dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47637906e95a7c94cffc093bc2e57dbf">&#9670;&nbsp;</a></span>vec_self128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_self128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">vfb</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector bool __int128 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit of vfa or vfb depending on the mask. </dd></dl>

</div>
</div>
<a id="a4d5b388cfc9af26418bdd4ec8e4e6f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5b388cfc9af26418bdd4ec8e4e6f73">&#9670;&nbsp;</a></span>vec_setb_qp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_setb_qp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Set Bool from Quadword Floating-point. </p>
<p>If the quadword's sign bit is '1' then return a vector bool __int128 that is all '1's. Otherwise return all '0's.</p>
<p>The resulting mask can be used in vector masking and select operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation will set the sign mask regardless of data class. For POWER9 the Scalar Test Data Class instructions copy the sign bit to CR bit 0 which distinguishes between +/- NaN.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4 - 6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a 128-bit vector treated a signed __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector bool of all '1's if the sign bit is '1'. Otherwise all '0's. </dd></dl>

</div>
</div>
<a id="a4ca7749d334c2a2c17a4d2a98b5bf755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca7749d334c2a2c17a4d2a98b5bf755">&#9670;&nbsp;</a></span>vec_signbitf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_signbitf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return int boolean true if the __float128 value is negative (sign bit is '1'). </p>
<p>For POWER9 use scalar_test_neg (a special case of scalar_test_data_class). For POWER8 and earlier, vec_and with a signmask and then vec_all_eq compare with that mask generates the boolean of the sign bit.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-10 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a int boolean indicating the sign bit. </dd></dl>

</div>
</div>
<a id="aec6e44a75847d3d3e5611b89eed71c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6e44a75847d3d3e5611b89eed71c0a">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui128t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_xfer_bin128_2_vui128t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector __int128. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector __int128. </dd></dl>

</div>
</div>
<a id="aff0629194f4f63bb083c271844459072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0629194f4f63bb083c271844459072">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui16t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_xfer_bin128_2_vui16t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector short int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector short int. </dd></dl>

</div>
</div>
<a id="a8043c2c5ac35d2b0a8bd8f33779c91a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8043c2c5ac35d2b0a8bd8f33779c91a6">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_xfer_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="acac5809f5f651e45113de8410664f2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac5809f5f651e45113de8410664f2c7">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui64t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xfer_bin128_2_vui64t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector long long int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector long long int. </dd></dl>

</div>
</div>
<a id="a57dc5b9171d5ce3d49f0f12795659c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57dc5b9171d5ce3d49f0f12795659c1a">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui8t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_xfer_bin128_2_vui8t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector char. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector char. </dd></dl>

</div>
</div>
<a id="a91b99b632646aaca91de6834e2b1da26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b99b632646aaca91de6834e2b1da26">&#9670;&nbsp;</a></span>vec_xfer_vui128t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui128t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned __int128 to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned __int128 value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="a3dec5c23a659b2fca1c219fe783f88eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dec5c23a659b2fca1c219fe783f88eb">&#9670;&nbsp;</a></span>vec_xfer_vui16t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui16t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned short to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned short value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="af0596ab318ba6d1ec5e7ed40871255a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0596ab318ba6d1ec5e7ed40871255a9">&#9670;&nbsp;</a></span>vec_xfer_vui32t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui32t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned int to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="ae8002c29875a226d11ec57a42b5b3955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8002c29875a226d11ec57a42b5b3955">&#9670;&nbsp;</a></span>vec_xfer_vui64t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui64t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned long long to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned long long value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="a047b7dc5b55b2d13e2fd826c63872ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047b7dc5b55b2d13e2fd826c63872ea9">&#9670;&nbsp;</a></span>vec_xfer_vui8t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui8t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned char to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned char value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="af95c675ceebc0627c777d2c7e2daef0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95c675ceebc0627c777d2c7e2daef0b">&#9670;&nbsp;</a></span>vec_xsiexpqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xsiexpqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar Insert Exponent Quad-Precision. </p>
<p>Merge the sign (bit 0) and significand (bits 16:127) from sig with the 15-bit exponent from exp (bits 49:63). The exponent is moved to bits 1:15 of the final result. The result is returned as a Quad_precision floating point value.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xsiexpqp instruction, This instruction requires a POWER9-enabled compiler targeting -mcpu=power9 and is not available for older compilers nor POWER8 and earlier. We can't use the built-in scalar_insert_exp because it requires scalar (GPR) inputs and vec_insert_exp is not defined for Quad-Precision. We expect (in context) inputs will be in VRs. This operation provides implementations for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>vector __int128 containing the Sign Bit and 112-bit significand. </td></tr>
    <tr><td class="paramname">exp</td><td>vector unsigned long long element 0 containing the 15-bit exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value where the exponent bits (1:15) of sig are replaced from bits 49:63 of exp. </dd></dl>

</div>
</div>
<a id="a3d78e42d9cc58491fa46149bf5798167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d78e42d9cc58491fa46149bf5798167">&#9670;&nbsp;</a></span>vec_xsxexpqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xsxexpqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar Extract Exponent Quad-Precision. </p>
<p>Extract the quad-precision exponent (bits 1:15) and right justify it to (bits 49:63 of) doubleword 0 of the result vector. The result is returned as vector long long integer value.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xsxexpqp instruction. This instruction requires a POWER9-enabled compiler targeting -mcpu=power9 and is not available for older compilers nor POWER8 and earlier. We can't use the built-in scalar_extract_exp because it returns scalar (GPR) results and vec_extract_exp is not defined for Quad-Precision. We expect (in context) results are needed in VRs. This operation provides implementations for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-13 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>__binary128 scalar value in a vector register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long long element 0 containing the 15-bit exponent </dd></dl>

</div>
</div>
<a id="ab1eb10beac182e936d7e49d491c34fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1eb10beac182e936d7e49d491c34fe0">&#9670;&nbsp;</a></span>vec_xsxsigqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_xsxsigqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar Extract Significand Quad-Precision. </p>
<p>Extract the quad-precision significand (bits 16:127) and restore the implied (hidden) bit (bit 15) if the quad-precition value is normal (not zero, subnormal, Infinity or NaN). The result is returned as vector __int128 integer value with up to 113 bits of significance.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xsxsigqp instruction. This instruction requires a POWER9-enabled compiler targeting -mcpu=power9 and is not available for older compilers nor POWER8 and earlier. We can't use the built-in scalar_extract_sig because it returns scalar (GPR) results and vec_extract_sig is not defined for Quad-Precision. We expect (in context) results are needed in VRs. This operation provides implementations for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>__binary128 scalar value in a vector register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector __int128 containing the significand. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="avec__int128__ppc_8h_html_a7f9ebc5ad32b151a3e08136d51aad4dc"><div class="ttname"><a href="vec__int128__ppc_8h.html#a7f9ebc5ad32b151a3e08136d51aad4dc">vec_cmpltuq</a></div><div class="ttdeci">static vb128_t vec_cmpltuq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare Less Than Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2872</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_ad4ce43dcbc14fb34623d5ece8073b86e"><div class="ttname"><a href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a></div><div class="ttdeci">static vb128_t vec_cmpgtuq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare Greater Than Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2749</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a6bafb410404d4f1e10a99263b57d1df0"><div class="ttname"><a href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a></div><div class="ttdeci">static vui128_t vec_subuqm(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Subtract Unsigned Quadword Modulo.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6451</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a3975205947785b1745a791ef12256e9a"><div class="ttname"><a href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a></div><div class="ttdeci">#define VEC_BYTE_H</div><div class="ttdoc">Element index for highest order byte.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:350</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a16cdf519bbbf190c311bd27d3e254208"><div class="ttname"><a href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div><div class="ttdeci">__vector __bool __int128 vb128_t</div><div class="ttdoc">vector of one 128-bit bool __int128 element.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:240</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_ae4520a89b9b5a292a3e647a6d5b712ad"><div class="ttname"><a href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a></div><div class="ttdeci">#define CONST_VINT128_W(__w0, __w1, __w2, __w3)</div><div class="ttdoc">Arrange word elements of a unsigned int initializer in high-&gt;low order. May require an explicit cast.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:304</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a3b2bbf9f23490ccca3bdc08bc1dc7831"><div class="ttname"><a href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a></div><div class="ttdeci">__vector __int128 vi128_t</div><div class="ttdoc">vector of one 128-bit signed __int128 element.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:235</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a11c410994f958a6b4ac9583878a55a72"><div class="ttname"><a href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">vec_isnanf128</a></div><div class="ttdeci">static vb128_t vec_isnanf128(__binary128 f128)</div><div class="ttdoc">Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2145</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a946ffd501b32f3ec96563ab101afbfad"><div class="ttname"><a href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">vec_all_isfinitef128</a></div><div class="ttdeci">static int vec_all_isfinitef128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is Finite (Not NaN nor Inf).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:1299</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a443a43ae34ab3b78564d2a8277503cac"><div class="ttname"><a href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div><div class="ttdeci">vf128_t __binary128</div><div class="ttdoc">Define __binary128 if not defined by the compiler. Same as __float128 for PPC.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:713</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a52a773b6353c69a546bdc2e8686a50ec"><div class="ttname"><a href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div><div class="ttdeci">__vector unsigned long long vui64_t</div><div class="ttdoc">vector of 64-bit unsigned long long elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:208</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_aed458e4755a6589049b936cf9f24f6f8"><div class="ttname"><a href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a></div><div class="ttdeci">__vector unsigned char vui8_t</div><div class="ttdoc">vector of 8-bit unsigned char elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:202</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_aaf7a8e92d8ba681dac3d2ec3259c0820"><div class="ttname"><a href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a></div><div class="ttdeci">__vector unsigned __int128 vui128_t</div><div class="ttdoc">vector of one 128-bit unsigned __int128 element.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:237</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a82d83d78ff2330205a8d74741b34a1be"><div class="ttname"><a href="vec__int128__ppc_8h.html#a82d83d78ff2330205a8d74741b34a1be">vec_cmpltsq</a></div><div class="ttdeci">static vb128_t vec_cmpltsq(vi128_t vra, vi128_t vrb)</div><div class="ttdoc">Vector Compare Less Than Signed Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2837</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a66fc4e7c94d0b30bb3515931aaf723da"><div class="ttname"><a href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a></div><div class="ttdeci">static int vec_all_isinff128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is infinity.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:1331</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_aedfcf3adea80e0407b40c6ec0e851aab"><div class="ttname"><a href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a></div><div class="ttdeci">static vui32_t vec_andc_bin128_2_vui32t(__binary128 f128, vui32_t mask)</div><div class="ttdoc">Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:861</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a7197cd5c6e946211f2718b5e8464cdc0"><div class="ttname"><a href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0">vec_cmpequq</a></div><div class="ttdeci">static vb128_t vec_cmpequq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare Equal Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2613</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a2ff4a776536870e01b7c9e454586544b"><div class="ttname"><a href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div><div class="ttdeci">__vector unsigned int vui32_t</div><div class="ttdoc">vector of 32-bit unsigned int elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:206</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_aae0e62b9910ec833dfc20719d09e526e"><div class="ttname"><a href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a></div><div class="ttdeci">static vui32_t vec_and_bin128_2_vui32t(__binary128 f128, vui32_t mask)</div><div class="ttdoc">Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:816</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a3d78e42d9cc58491fa46149bf5798167"><div class="ttname"><a href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a></div><div class="ttdeci">static vui64_t vec_xsxexpqp(__binary128 f128)</div><div class="ttdoc">Scalar Extract Exponent Quad-Precision.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2466</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_afc830b382bd45dc0ff815024c1bfb26d"><div class="ttname"><a href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">vec_all_isnormalf128</a></div><div class="ttdeci">static int vec_all_isnormalf128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:1409</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_af7fb1013dfcf633156cd7f855a11fb56"><div class="ttname"><a href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a></div><div class="ttdeci">static __binary128 vec_const_nanf128()</div><div class="ttdoc">return a quiet NaN.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:1564</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_af06b73ac57985011c558670adc283e89"><div class="ttname"><a href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a></div><div class="ttdeci">static int vec_all_isnanf128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is Not a Number (NaN).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:1365</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_ac554a9d0d12fca036772aaaee5908414"><div class="ttname"><a href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">vec_all_iszerof128</a></div><div class="ttdeci">static int vec_all_iszerof128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is +-0.0.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:1481</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 21 2021 17:24:16 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
