<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_f128_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_f128_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over Quad-Precision floating point elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__common__ppc_8h_source.html">pveclib/vec_common_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__int128__ppc_8h_source.html">pveclib/vec_int128_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__f64__ppc_8h_source.html">pveclib/vec_f64_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__f128__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union____VF__128.html">__VF_128</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union used to transfer 128-bit data between vector and __float128 types.  <a href="union____VF__128.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5c0751a2b64a9a560e9a964294f63166"><td class="memItemLeft" align="right" valign="top"><a id="a5c0751a2b64a9a560e9a964294f63166"></a>
typedef <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a></td></tr>
<tr class="memdesc:a5c0751a2b64a9a560e9a964294f63166"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 128-bit binary128 element. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a5c0751a2b64a9a560e9a964294f63166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="memItemLeft" align="right" valign="top"><a id="a5f89d266b82d1a8f300348cf99b9ae3f"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5f89d266b82d1a8f300348cf99b9ae3f">__Float128</a></td></tr>
<tr class="memdesc:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __Float128 if not defined by the compiler. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443a43ae34ab3b78564d2a8277503cac"><td class="memItemLeft" align="right" valign="top"><a id="a443a43ae34ab3b78564d2a8277503cac"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></td></tr>
<tr class="memdesc:a443a43ae34ab3b78564d2a8277503cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __binary128 if not defined by the compiler. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a443a43ae34ab3b78564d2a8277503cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af2270bedc312f7d99c0605358cd28c"><td class="memItemLeft" align="right" valign="top"><a id="a4af2270bedc312f7d99c0605358cd28c"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4af2270bedc312f7d99c0605358cd28c">__float128</a></td></tr>
<tr class="memdesc:a4af2270bedc312f7d99c0605358cd28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __float128 if not defined by the compiler. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a4af2270bedc312f7d99c0605358cd28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55019fe6dc8271e91613db7b1ae96721"><td class="memItemLeft" align="right" valign="top"><a id="a55019fe6dc8271e91613db7b1ae96721"></a>
typedef long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a55019fe6dc8271e91613db7b1ae96721">__IBM128</a></td></tr>
<tr class="memdesc:a55019fe6dc8271e91613db7b1ae96721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __IBM128 if not defined by the compiler. Same as old long double for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a55019fe6dc8271e91613db7b1ae96721"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a380ba36beb77c11beb7050698a62fd23"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a380ba36beb77c11beb7050698a62fd23">vec_const64_f128_128</a> (void)</td></tr>
<tr class="memdesc:a380ba36beb77c11beb7050698a62fd23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate doubleword splat constant 128.  <a href="vec__f128__ppc_8h.html#a380ba36beb77c11beb7050698a62fd23">More...</a><br /></td></tr>
<tr class="separator:a380ba36beb77c11beb7050698a62fd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173efeafba080313d50e8b018c26c611"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a173efeafba080313d50e8b018c26c611">vec_const128_f128_128</a> (void)</td></tr>
<tr class="memdesc:a173efeafba080313d50e8b018c26c611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Quadword constant 128.  <a href="vec__f128__ppc_8h.html#a173efeafba080313d50e8b018c26c611">More...</a><br /></td></tr>
<tr class="separator:a173efeafba080313d50e8b018c26c611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ef1a77f575bd319d6cf90e1b81765b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b">vec_mask64_f128exp</a> (void)</td></tr>
<tr class="memdesc:ae1ef1a77f575bd319d6cf90e1b81765b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Doubleword Quad-Precision exponent mask.  <a href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b">More...</a><br /></td></tr>
<tr class="separator:ae1ef1a77f575bd319d6cf90e1b81765b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553edc28189515110f96a6ab6531927f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a553edc28189515110f96a6ab6531927f">vec_mask128_f128exp</a> (void)</td></tr>
<tr class="memdesc:a553edc28189515110f96a6ab6531927f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Quadword Quad-Precision exponent mask.  <a href="vec__f128__ppc_8h.html#a553edc28189515110f96a6ab6531927f">More...</a><br /></td></tr>
<tr class="separator:a553edc28189515110f96a6ab6531927f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5751b5c36a7a3d73c81abd7759e51594"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5751b5c36a7a3d73c81abd7759e51594">vec_mask128_f128mag</a> (void)</td></tr>
<tr class="memdesc:a5751b5c36a7a3d73c81abd7759e51594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Quadword Quad-Precision magnitude mask.  <a href="vec__f128__ppc_8h.html#a5751b5c36a7a3d73c81abd7759e51594">More...</a><br /></td></tr>
<tr class="separator:a5751b5c36a7a3d73c81abd7759e51594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ca6322cc3885264ca350a66b4e1bff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a42ca6322cc3885264ca350a66b4e1bff">vec_mask128_f128sig</a> (void)</td></tr>
<tr class="memdesc:a42ca6322cc3885264ca350a66b4e1bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Quadword Quad-Precision significand mask.  <a href="vec__f128__ppc_8h.html#a42ca6322cc3885264ca350a66b4e1bff">More...</a><br /></td></tr>
<tr class="separator:a42ca6322cc3885264ca350a66b4e1bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94c7ddb75a8fc5f543e65e31e03f1c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ac94c7ddb75a8fc5f543e65e31e03f1c1">vec_mask128_f128sign</a> (void)</td></tr>
<tr class="memdesc:ac94c7ddb75a8fc5f543e65e31e03f1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Quadword Quad-Precision Sign-bit mask.  <a href="vec__f128__ppc_8h.html#ac94c7ddb75a8fc5f543e65e31e03f1c1">More...</a><br /></td></tr>
<tr class="separator:ac94c7ddb75a8fc5f543e65e31e03f1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba9852d8733f6861d799a10027e1e95"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a2ba9852d8733f6861d799a10027e1e95">vec_mask128_f128Cbit</a> (void)</td></tr>
<tr class="memdesc:a2ba9852d8733f6861d799a10027e1e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Quadword C-bit mask Immediate.  <a href="vec__f128__ppc_8h.html#a2ba9852d8733f6861d799a10027e1e95">More...</a><br /></td></tr>
<tr class="separator:a2ba9852d8733f6861d799a10027e1e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29201a75ecd86b135dbb013dbd2ced75"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a29201a75ecd86b135dbb013dbd2ced75">vec_mask128_f128Lbit</a> (void)</td></tr>
<tr class="memdesc:a29201a75ecd86b135dbb013dbd2ced75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Quadword L-bit mask Immediate.  <a href="vec__f128__ppc_8h.html#a29201a75ecd86b135dbb013dbd2ced75">More...</a><br /></td></tr>
<tr class="separator:a29201a75ecd86b135dbb013dbd2ced75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619b1beb77d75c62ea9913e527bb0cf1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a619b1beb77d75c62ea9913e527bb0cf1">vec_mask128_f128Qbit</a> (void)</td></tr>
<tr class="memdesc:a619b1beb77d75c62ea9913e527bb0cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Quadword QNaN-bit mask Immediate.  <a href="vec__f128__ppc_8h.html#a619b1beb77d75c62ea9913e527bb0cf1">More...</a><br /></td></tr>
<tr class="separator:a619b1beb77d75c62ea9913e527bb0cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2843ee28bf45b6e7589f2b1d073a2187"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a2843ee28bf45b6e7589f2b1d073a2187">vec_sel_bin128_2_bin128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb, <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> mask)</td></tr>
<tr class="memdesc:a2843ee28bf45b6e7589f2b1d073a2187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value.  <a href="vec__f128__ppc_8h.html#a2843ee28bf45b6e7589f2b1d073a2187">More...</a><br /></td></tr>
<tr class="separator:a2843ee28bf45b6e7589f2b1d073a2187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e62b9910ec833dfc20719d09e526e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mask)</td></tr>
<tr class="memdesc:aae0e62b9910ec833dfc20719d09e526e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask.  <a href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">More...</a><br /></td></tr>
<tr class="separator:aae0e62b9910ec833dfc20719d09e526e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfcf3adea80e0407b40c6ec0e851aab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mask)</td></tr>
<tr class="memdesc:aedfcf3adea80e0407b40c6ec0e851aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask.  <a href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">More...</a><br /></td></tr>
<tr class="separator:aedfcf3adea80e0407b40c6ec0e851aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3612e915d9043c23eeaac6eb5e129312"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3612e915d9043c23eeaac6eb5e129312">vec_or_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mask)</td></tr>
<tr class="memdesc:a3612e915d9043c23eeaac6eb5e129312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector int and logical OR with mask.  <a href="vec__f128__ppc_8h.html#a3612e915d9043c23eeaac6eb5e129312">More...</a><br /></td></tr>
<tr class="separator:a3612e915d9043c23eeaac6eb5e129312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de75d3d010fe5ac7310322e2abea122"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a7de75d3d010fe5ac7310322e2abea122">vec_xor_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mask)</td></tr>
<tr class="memdesc:a7de75d3d010fe5ac7310322e2abea122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector int and logical Exclusive OR with mask.  <a href="vec__f128__ppc_8h.html#a7de75d3d010fe5ac7310322e2abea122">More...</a><br /></td></tr>
<tr class="separator:a7de75d3d010fe5ac7310322e2abea122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796440333ee623aa782ef3eb5a021587"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a796440333ee623aa782ef3eb5a021587">vec_andc_bin128_2_vui128t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> mask)</td></tr>
<tr class="memdesc:a796440333ee623aa782ef3eb5a021587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector __int128 and logical AND Compliment with mask.  <a href="vec__f128__ppc_8h.html#a796440333ee623aa782ef3eb5a021587">More...</a><br /></td></tr>
<tr class="separator:a796440333ee623aa782ef3eb5a021587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a57dc5b9171d5ce3d49f0f12795659c1a">vec_xfer_bin128_2_vui8t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector char.  <a href="vec__f128__ppc_8h.html#a57dc5b9171d5ce3d49f0f12795659c1a">More...</a><br /></td></tr>
<tr class="separator:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0629194f4f63bb083c271844459072"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aff0629194f4f63bb083c271844459072">vec_xfer_bin128_2_vui16t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aff0629194f4f63bb083c271844459072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector short int.  <a href="vec__f128__ppc_8h.html#aff0629194f4f63bb083c271844459072">More...</a><br /></td></tr>
<tr class="separator:aff0629194f4f63bb083c271844459072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a8043c2c5ac35d2b0a8bd8f33779c91a6">vec_xfer_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector int.  <a href="vec__f128__ppc_8h.html#a8043c2c5ac35d2b0a8bd8f33779c91a6">More...</a><br /></td></tr>
<tr class="separator:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dff4f515dc0b37a4411401a44aa5157"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a1dff4f515dc0b37a4411401a44aa5157">vec_mrgh_bin128_2_vui64t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a1dff4f515dc0b37a4411401a44aa5157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge High and Transfer function from a pair of __binary128 scalars to a vector long long int.  <a href="vec__f128__ppc_8h.html#a1dff4f515dc0b37a4411401a44aa5157">More...</a><br /></td></tr>
<tr class="separator:a1dff4f515dc0b37a4411401a44aa5157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2ac713dcb43499b47410c02b6c854c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#afc2ac713dcb43499b47410c02b6c854c">vec_mrgl_bin128_2_vui64t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:afc2ac713dcb43499b47410c02b6c854c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge Low and Transfer function from a pair of __binary128 scalars to a vector long long int.  <a href="vec__f128__ppc_8h.html#afc2ac713dcb43499b47410c02b6c854c">More...</a><br /></td></tr>
<tr class="separator:afc2ac713dcb43499b47410c02b6c854c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac5809f5f651e45113de8410664f2c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#acac5809f5f651e45113de8410664f2c7">vec_xfer_bin128_2_vui64t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:acac5809f5f651e45113de8410664f2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector long long int.  <a href="vec__f128__ppc_8h.html#acac5809f5f651e45113de8410664f2c7">More...</a><br /></td></tr>
<tr class="separator:acac5809f5f651e45113de8410664f2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6e44a75847d3d3e5611b89eed71c0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aec6e44a75847d3d3e5611b89eed71c0a">vec_xfer_bin128_2_vui128t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aec6e44a75847d3d3e5611b89eed71c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector __int128.  <a href="vec__f128__ppc_8h.html#aec6e44a75847d3d3e5611b89eed71c0a">More...</a><br /></td></tr>
<tr class="separator:aec6e44a75847d3d3e5611b89eed71c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a047b7dc5b55b2d13e2fd826c63872ea9">vec_xfer_vui8t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> f128)</td></tr>
<tr class="memdesc:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned char to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#a047b7dc5b55b2d13e2fd826c63872ea9">More...</a><br /></td></tr>
<tr class="separator:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dec5c23a659b2fca1c219fe783f88eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3dec5c23a659b2fca1c219fe783f88eb">vec_xfer_vui16t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> f128)</td></tr>
<tr class="memdesc:a3dec5c23a659b2fca1c219fe783f88eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned short to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#a3dec5c23a659b2fca1c219fe783f88eb">More...</a><br /></td></tr>
<tr class="separator:a3dec5c23a659b2fca1c219fe783f88eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0596ab318ba6d1ec5e7ed40871255a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> f128)</td></tr>
<tr class="memdesc:af0596ab318ba6d1ec5e7ed40871255a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned int to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">More...</a><br /></td></tr>
<tr class="separator:af0596ab318ba6d1ec5e7ed40871255a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8002c29875a226d11ec57a42b5b3955"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ae8002c29875a226d11ec57a42b5b3955">vec_xfer_vui64t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> f128)</td></tr>
<tr class="memdesc:ae8002c29875a226d11ec57a42b5b3955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned long long to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#ae8002c29875a226d11ec57a42b5b3955">More...</a><br /></td></tr>
<tr class="separator:ae8002c29875a226d11ec57a42b5b3955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b99b632646aaca91de6834e2b1da26"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">vec_xfer_vui128t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> f128)</td></tr>
<tr class="memdesc:a91b99b632646aaca91de6834e2b1da26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned __int128 to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">More...</a><br /></td></tr>
<tr class="separator:a91b99b632646aaca91de6834e2b1da26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add641f5a217eff45f0e836fa98613584"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#add641f5a217eff45f0e836fa98613584">vec_absf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:add641f5a217eff45f0e836fa98613584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute Quad-Precision.  <a href="vec__f128__ppc_8h.html#add641f5a217eff45f0e836fa98613584">More...</a><br /></td></tr>
<tr class="separator:add641f5a217eff45f0e836fa98613584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946ffd501b32f3ec96563ab101afbfad"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">vec_all_isfinitef128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a946ffd501b32f3ec96563ab101afbfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is Finite (Not NaN nor Inf).  <a href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">More...</a><br /></td></tr>
<tr class="separator:a946ffd501b32f3ec96563ab101afbfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fc4e7c94d0b30bb3515931aaf723da"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a66fc4e7c94d0b30bb3515931aaf723da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is infinity.  <a href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">More...</a><br /></td></tr>
<tr class="separator:a66fc4e7c94d0b30bb3515931aaf723da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06b73ac57985011c558670adc283e89"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:af06b73ac57985011c558670adc283e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is Not a Number (NaN).  <a href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">More...</a><br /></td></tr>
<tr class="separator:af06b73ac57985011c558670adc283e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc830b382bd45dc0ff815024c1bfb26d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">vec_all_isnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:afc830b382bd45dc0ff815024c1bfb26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">More...</a><br /></td></tr>
<tr class="separator:afc830b382bd45dc0ff815024c1bfb26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1a94cccdb3f106a0e6399e2f034718"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#adf1a94cccdb3f106a0e6399e2f034718">vec_all_issubnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:adf1a94cccdb3f106a0e6399e2f034718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is subnormal (denormal).  <a href="vec__f128__ppc_8h.html#adf1a94cccdb3f106a0e6399e2f034718">More...</a><br /></td></tr>
<tr class="separator:adf1a94cccdb3f106a0e6399e2f034718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bee3fac5a163513bae170a54ac641ca"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a2bee3fac5a163513bae170a54ac641ca">vec_all_isunorderedf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a2bee3fac5a163513bae170a54ac641ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if either __float128 value (vra, vrb) is NaN.  <a href="vec__f128__ppc_8h.html#a2bee3fac5a163513bae170a54ac641ca">More...</a><br /></td></tr>
<tr class="separator:a2bee3fac5a163513bae170a54ac641ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac554a9d0d12fca036772aaaee5908414"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">vec_all_iszerof128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:ac554a9d0d12fca036772aaaee5908414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is +-0.0.  <a href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">More...</a><br /></td></tr>
<tr class="separator:ac554a9d0d12fca036772aaaee5908414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb73eac40698921735bad8ac4ce560e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e">vec_copysignf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128x, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128y)</td></tr>
<tr class="memdesc:adfb73eac40698921735bad8ac4ce560e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign bit from f128x and merge with the magnitude from f128y. The merged result is returned as a __float128 value.  <a href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e">More...</a><br /></td></tr>
<tr class="separator:adfb73eac40698921735bad8ac4ce560e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a0a30726ccfb216e4d2e1ede3854ab96b">vec_const_huge_valf128</a> ()</td></tr>
<tr class="memdesc:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a positive infinity.  <a href="vec__f128__ppc_8h.html#a0a30726ccfb216e4d2e1ede3854ab96b">More...</a><br /></td></tr>
<tr class="separator:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c68f73f69c4776bb054d42915e7103d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9c68f73f69c4776bb054d42915e7103d">vec_const_inff128</a> ()</td></tr>
<tr class="memdesc:a9c68f73f69c4776bb054d42915e7103d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a positive infinity.  <a href="vec__f128__ppc_8h.html#a9c68f73f69c4776bb054d42915e7103d">More...</a><br /></td></tr>
<tr class="separator:a9c68f73f69c4776bb054d42915e7103d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fb1013dfcf633156cd7f855a11fb56"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ()</td></tr>
<tr class="memdesc:af7fb1013dfcf633156cd7f855a11fb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a quiet NaN.  <a href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">More...</a><br /></td></tr>
<tr class="separator:af7fb1013dfcf633156cd7f855a11fb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac806c62ebaae6ab8faca87794cb917c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aac806c62ebaae6ab8faca87794cb917c">vec_const_nansf128</a> ()</td></tr>
<tr class="memdesc:aac806c62ebaae6ab8faca87794cb917c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a signaling NaN.  <a href="vec__f128__ppc_8h.html#aac806c62ebaae6ab8faca87794cb917c">More...</a><br /></td></tr>
<tr class="separator:aac806c62ebaae6ab8faca87794cb917c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec73dba497304699389a168256f32d29"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aec73dba497304699389a168256f32d29">vec_cmpeqtoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aec73dba497304699389a168256f32d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#aec73dba497304699389a168256f32d29">More...</a><br /></td></tr>
<tr class="separator:aec73dba497304699389a168256f32d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83177380e5feaacb1da72c99df1c6d82"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a83177380e5feaacb1da72c99df1c6d82">vec_cmpequzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a83177380e5feaacb1da72c99df1c6d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a83177380e5feaacb1da72c99df1c6d82">More...</a><br /></td></tr>
<tr class="separator:a83177380e5feaacb1da72c99df1c6d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3f85b4c3fe43ae58df0c72d1f29920"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a7e3f85b4c3fe43ae58df0c72d1f29920">vec_cmpequqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a7e3f85b4c3fe43ae58df0c72d1f29920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a7e3f85b4c3fe43ae58df0c72d1f29920">More...</a><br /></td></tr>
<tr class="separator:a7e3f85b4c3fe43ae58df0c72d1f29920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40f7a997a4c92eb55203444434c070e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aa40f7a997a4c92eb55203444434c070e">vec_cmpgetoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aa40f7a997a4c92eb55203444434c070e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than or Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#aa40f7a997a4c92eb55203444434c070e">More...</a><br /></td></tr>
<tr class="separator:aa40f7a997a4c92eb55203444434c070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b31351604fbca85ace1c1efc8bd6506"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a6b31351604fbca85ace1c1efc8bd6506">vec_cmpgeuzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a6b31351604fbca85ace1c1efc8bd6506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than Or Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a6b31351604fbca85ace1c1efc8bd6506">More...</a><br /></td></tr>
<tr class="separator:a6b31351604fbca85ace1c1efc8bd6506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870bc0f51bb3931039fec799a7c3605a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a870bc0f51bb3931039fec799a7c3605a">vec_cmpgeuqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a870bc0f51bb3931039fec799a7c3605a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than or Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a870bc0f51bb3931039fec799a7c3605a">More...</a><br /></td></tr>
<tr class="separator:a870bc0f51bb3931039fec799a7c3605a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320639a93f8bc42359d9214a5e9c17e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ae320639a93f8bc42359d9214a5e9c17e">vec_cmpgttoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ae320639a93f8bc42359d9214a5e9c17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ae320639a93f8bc42359d9214a5e9c17e">More...</a><br /></td></tr>
<tr class="separator:ae320639a93f8bc42359d9214a5e9c17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbd885123cdb812bf19d2758cde202f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a6fbd885123cdb812bf19d2758cde202f">vec_cmpgtuzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a6fbd885123cdb812bf19d2758cde202f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a6fbd885123cdb812bf19d2758cde202f">More...</a><br /></td></tr>
<tr class="separator:a6fbd885123cdb812bf19d2758cde202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd8774bd68a914ac0fe3f66d16a8965"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4bd8774bd68a914ac0fe3f66d16a8965">vec_cmpgtuqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a4bd8774bd68a914ac0fe3f66d16a8965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a4bd8774bd68a914ac0fe3f66d16a8965">More...</a><br /></td></tr>
<tr class="separator:a4bd8774bd68a914ac0fe3f66d16a8965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2034138934ee70e2ed25978ecb18ebc0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a2034138934ee70e2ed25978ecb18ebc0">vec_cmpletoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a2034138934ee70e2ed25978ecb18ebc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than or Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a2034138934ee70e2ed25978ecb18ebc0">More...</a><br /></td></tr>
<tr class="separator:a2034138934ee70e2ed25978ecb18ebc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae776b348d6c4c4a45966b451aa72072c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ae776b348d6c4c4a45966b451aa72072c">vec_cmpleuzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ae776b348d6c4c4a45966b451aa72072c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than or Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ae776b348d6c4c4a45966b451aa72072c">More...</a><br /></td></tr>
<tr class="separator:ae776b348d6c4c4a45966b451aa72072c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a72e3eb8f3d96e537e940cc7583b3c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4a72e3eb8f3d96e537e940cc7583b3c7">vec_cmpleuqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a4a72e3eb8f3d96e537e940cc7583b3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than or Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a4a72e3eb8f3d96e537e940cc7583b3c7">More...</a><br /></td></tr>
<tr class="separator:a4a72e3eb8f3d96e537e940cc7583b3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c672a1a0bcd3005acdfff33e70e782"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a82c672a1a0bcd3005acdfff33e70e782">vec_cmplttoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a82c672a1a0bcd3005acdfff33e70e782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a82c672a1a0bcd3005acdfff33e70e782">More...</a><br /></td></tr>
<tr class="separator:a82c672a1a0bcd3005acdfff33e70e782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3242d44d78984694295087f9f415e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a1e3242d44d78984694295087f9f415e8">vec_cmpltuzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a1e3242d44d78984694295087f9f415e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a1e3242d44d78984694295087f9f415e8">More...</a><br /></td></tr>
<tr class="separator:a1e3242d44d78984694295087f9f415e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388307f4693587b9e49148fbe95d8da5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a388307f4693587b9e49148fbe95d8da5">vec_cmpltuqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a388307f4693587b9e49148fbe95d8da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a388307f4693587b9e49148fbe95d8da5">More...</a><br /></td></tr>
<tr class="separator:a388307f4693587b9e49148fbe95d8da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a23cbeeb063d30316ab3e7bdd77fd7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aa2a23cbeeb063d30316ab3e7bdd77fd7">vec_cmpnetoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aa2a23cbeeb063d30316ab3e7bdd77fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Not Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#aa2a23cbeeb063d30316ab3e7bdd77fd7">More...</a><br /></td></tr>
<tr class="separator:aa2a23cbeeb063d30316ab3e7bdd77fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffa4be24c8714347ded9340de33e999"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4ffa4be24c8714347ded9340de33e999">vec_cmpneuzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a4ffa4be24c8714347ded9340de33e999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Not Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a4ffa4be24c8714347ded9340de33e999">More...</a><br /></td></tr>
<tr class="separator:a4ffa4be24c8714347ded9340de33e999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e270eb83aa8d90a2459b0097fec944"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ab3e270eb83aa8d90a2459b0097fec944">vec_cmpneuqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ab3e270eb83aa8d90a2459b0097fec944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Not Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ab3e270eb83aa8d90a2459b0097fec944">More...</a><br /></td></tr>
<tr class="separator:ab3e270eb83aa8d90a2459b0097fec944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c233f656fb0ef554dfbdfb23e66954"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a44c233f656fb0ef554dfbdfb23e66954">vec_cmpqp_all_toeq</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a44c233f656fb0ef554dfbdfb23e66954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a44c233f656fb0ef554dfbdfb23e66954">More...</a><br /></td></tr>
<tr class="separator:a44c233f656fb0ef554dfbdfb23e66954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7d9eb6f3ee5d504bddd9f4b9171bfd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4c7d9eb6f3ee5d504bddd9f4b9171bfd">vec_cmpqp_all_uzeq</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a4c7d9eb6f3ee5d504bddd9f4b9171bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a4c7d9eb6f3ee5d504bddd9f4b9171bfd">More...</a><br /></td></tr>
<tr class="separator:a4c7d9eb6f3ee5d504bddd9f4b9171bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50ec5ca14b23861c520e99f9b24a11f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ab50ec5ca14b23861c520e99f9b24a11f">vec_cmpqp_all_eq</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ab50ec5ca14b23861c520e99f9b24a11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ab50ec5ca14b23861c520e99f9b24a11f">More...</a><br /></td></tr>
<tr class="separator:ab50ec5ca14b23861c520e99f9b24a11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4f2f83695c9980679e8a2488ed2c55"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9a4f2f83695c9980679e8a2488ed2c55">vec_cmpqp_all_toge</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a9a4f2f83695c9980679e8a2488ed2c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than Or Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a9a4f2f83695c9980679e8a2488ed2c55">More...</a><br /></td></tr>
<tr class="separator:a9a4f2f83695c9980679e8a2488ed2c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a13069849f5ac559db634deab32d0e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a59a13069849f5ac559db634deab32d0e">vec_cmpqp_all_uzge</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a59a13069849f5ac559db634deab32d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than Or Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a59a13069849f5ac559db634deab32d0e">More...</a><br /></td></tr>
<tr class="separator:a59a13069849f5ac559db634deab32d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aef626eb6cd826f5874f3324dd7217"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a01aef626eb6cd826f5874f3324dd7217">vec_cmpqp_all_ge</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a01aef626eb6cd826f5874f3324dd7217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than Or Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a01aef626eb6cd826f5874f3324dd7217">More...</a><br /></td></tr>
<tr class="separator:a01aef626eb6cd826f5874f3324dd7217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926a5e7b9a23e7464d70d9fa6ae49dda"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a926a5e7b9a23e7464d70d9fa6ae49dda">vec_cmpqp_all_togt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a926a5e7b9a23e7464d70d9fa6ae49dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a926a5e7b9a23e7464d70d9fa6ae49dda">More...</a><br /></td></tr>
<tr class="separator:a926a5e7b9a23e7464d70d9fa6ae49dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dcb860a9015e36ade2d6a9fac55c62"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ab0dcb860a9015e36ade2d6a9fac55c62">vec_cmpqp_all_uzgt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ab0dcb860a9015e36ade2d6a9fac55c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ab0dcb860a9015e36ade2d6a9fac55c62">More...</a><br /></td></tr>
<tr class="separator:ab0dcb860a9015e36ade2d6a9fac55c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253c27dd7f4fe852a4f0c6dce45d886b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a253c27dd7f4fe852a4f0c6dce45d886b">vec_cmpqp_all_gt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a253c27dd7f4fe852a4f0c6dce45d886b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a253c27dd7f4fe852a4f0c6dce45d886b">More...</a><br /></td></tr>
<tr class="separator:a253c27dd7f4fe852a4f0c6dce45d886b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8171c3fa6a0ecdf7b19be3df8227cbf6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a8171c3fa6a0ecdf7b19be3df8227cbf6">vec_cmpqp_all_tole</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a8171c3fa6a0ecdf7b19be3df8227cbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare All Less Than Or Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a8171c3fa6a0ecdf7b19be3df8227cbf6">More...</a><br /></td></tr>
<tr class="separator:a8171c3fa6a0ecdf7b19be3df8227cbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d444218effcb971289efb1e02a3dc9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a75d444218effcb971289efb1e02a3dc9">vec_cmpqp_all_uzle</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a75d444218effcb971289efb1e02a3dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less Than Or Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a75d444218effcb971289efb1e02a3dc9">More...</a><br /></td></tr>
<tr class="separator:a75d444218effcb971289efb1e02a3dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dca4ec505a30c52361dff6300fdba7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a19dca4ec505a30c52361dff6300fdba7">vec_cmpqp_all_le</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a19dca4ec505a30c52361dff6300fdba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less Than Or Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a19dca4ec505a30c52361dff6300fdba7">More...</a><br /></td></tr>
<tr class="separator:a19dca4ec505a30c52361dff6300fdba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d466774a32ef558f6e3ea64dd6b3cdd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9d466774a32ef558f6e3ea64dd6b3cdd">vec_cmpqp_all_tolt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a9d466774a32ef558f6e3ea64dd6b3cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare All Less Than (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a9d466774a32ef558f6e3ea64dd6b3cdd">More...</a><br /></td></tr>
<tr class="separator:a9d466774a32ef558f6e3ea64dd6b3cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dde3d0847b947b1f422afef46fbfc6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a95dde3d0847b947b1f422afef46fbfc6">vec_cmpqp_all_uzlt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a95dde3d0847b947b1f422afef46fbfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less Than (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a95dde3d0847b947b1f422afef46fbfc6">More...</a><br /></td></tr>
<tr class="separator:a95dde3d0847b947b1f422afef46fbfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630f6cef8a6cdcc6dd22d3c1ece138b7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a630f6cef8a6cdcc6dd22d3c1ece138b7">vec_cmpqp_all_lt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a630f6cef8a6cdcc6dd22d3c1ece138b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less Than (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a630f6cef8a6cdcc6dd22d3c1ece138b7">More...</a><br /></td></tr>
<tr class="separator:a630f6cef8a6cdcc6dd22d3c1ece138b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d272e77ab3c69808ad3efac20afb36"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ad8d272e77ab3c69808ad3efac20afb36">vec_cmpqp_all_tone</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ad8d272e77ab3c69808ad3efac20afb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Not-Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ad8d272e77ab3c69808ad3efac20afb36">More...</a><br /></td></tr>
<tr class="separator:ad8d272e77ab3c69808ad3efac20afb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa147fd8c1d3da47a2786b6b745a9e1a6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aa147fd8c1d3da47a2786b6b745a9e1a6">vec_cmpqp_all_uzne</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aa147fd8c1d3da47a2786b6b745a9e1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Not-Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#aa147fd8c1d3da47a2786b6b745a9e1a6">More...</a><br /></td></tr>
<tr class="separator:aa147fd8c1d3da47a2786b6b745a9e1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d858ca0228e20b1e7f3bec686021fb6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3d858ca0228e20b1e7f3bec686021fb6">vec_cmpqp_all_ne</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a3d858ca0228e20b1e7f3bec686021fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Not-Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a3d858ca0228e20b1e7f3bec686021fb6">More...</a><br /></td></tr>
<tr class="separator:a3d858ca0228e20b1e7f3bec686021fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6c52eb3208f4d9ed851ee48f773d68"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a1e6c52eb3208f4d9ed851ee48f773d68">vec_cmpqp_exp_eq</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a1e6c52eb3208f4d9ed851ee48f773d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Quad-Precision Exponents for Equal.  <a href="vec__f128__ppc_8h.html#a1e6c52eb3208f4d9ed851ee48f773d68">More...</a><br /></td></tr>
<tr class="separator:a1e6c52eb3208f4d9ed851ee48f773d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2d90d67cb3f605fbc9598f133b0305"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#abf2d90d67cb3f605fbc9598f133b0305">vec_cmpqp_exp_gt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:abf2d90d67cb3f605fbc9598f133b0305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Exponents Quad-Precision for Greater Than.  <a href="vec__f128__ppc_8h.html#abf2d90d67cb3f605fbc9598f133b0305">More...</a><br /></td></tr>
<tr class="separator:abf2d90d67cb3f605fbc9598f133b0305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb9b92be998695424107de6a60890a8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3eb9b92be998695424107de6a60890a8">vec_cmpqp_exp_lt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a3eb9b92be998695424107de6a60890a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Exponents Quad-Precision for Less Than.  <a href="vec__f128__ppc_8h.html#a3eb9b92be998695424107de6a60890a8">More...</a><br /></td></tr>
<tr class="separator:a3eb9b92be998695424107de6a60890a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3014214c103453a34372cc52e6d79073"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3014214c103453a34372cc52e6d79073">vec_cmpqp_exp_unordered</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a3014214c103453a34372cc52e6d79073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Exponents Quad-Precision for Unordered.  <a href="vec__f128__ppc_8h.html#a3014214c103453a34372cc52e6d79073">More...</a><br /></td></tr>
<tr class="separator:a3014214c103453a34372cc52e6d79073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1668ff13922ca04059f1844a7a1464f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ad1668ff13922ca04059f1844a7a1464f">vec_isfinitef128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:ad1668ff13922ca04059f1844a7a1464f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is Finite (Not NaN nor Inf).  <a href="vec__f128__ppc_8h.html#ad1668ff13922ca04059f1844a7a1464f">More...</a><br /></td></tr>
<tr class="separator:ad1668ff13922ca04059f1844a7a1464f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd9706acb775392282cfe4d4e3a03aa"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aebd9706acb775392282cfe4d4e3a03aa">vec_isinf_signf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aebd9706acb775392282cfe4d4e3a03aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true (nonzero) value if the __float128 value is infinity. If infinity, indicate the sign as +1 for positive infinity and -1 for negative infinity.  <a href="vec__f128__ppc_8h.html#aebd9706acb775392282cfe4d4e3a03aa">More...</a><br /></td></tr>
<tr class="separator:aebd9706acb775392282cfe4d4e3a03aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a94f9c7429c2ebd9b9f32ad6e98689ebb">vec_isinff128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 128-bit vector boolean true if the __float128 value is infinity.  <a href="vec__f128__ppc_8h.html#a94f9c7429c2ebd9b9f32ad6e98689ebb">More...</a><br /></td></tr>
<tr class="separator:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c410994f958a6b4ac9583878a55a72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">vec_isnanf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a11c410994f958a6b4ac9583878a55a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN).  <a href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">More...</a><br /></td></tr>
<tr class="separator:a11c410994f958a6b4ac9583878a55a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25185c83b69f6af3f3d9399199c8a57"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aa25185c83b69f6af3f3d9399199c8a57">vec_isnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aa25185c83b69f6af3f3d9399199c8a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f128__ppc_8h.html#aa25185c83b69f6af3f3d9399199c8a57">More...</a><br /></td></tr>
<tr class="separator:aa25185c83b69f6af3f3d9399199c8a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9670e4655a9c7888c80343780cd7abf9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9670e4655a9c7888c80343780cd7abf9">vec_issubnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a9670e4655a9c7888c80343780cd7abf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true value, if the __float128 value is subnormal (denormal).  <a href="vec__f128__ppc_8h.html#a9670e4655a9c7888c80343780cd7abf9">More...</a><br /></td></tr>
<tr class="separator:a9670e4655a9c7888c80343780cd7abf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9148af78b075f253c9848945df6135"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aec9148af78b075f253c9848945df6135">vec_isunorderedf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aec9148af78b075f253c9848945df6135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true value, if either __float128 value (vra, vrb) is NaN.  <a href="vec__f128__ppc_8h.html#aec9148af78b075f253c9848945df6135">More...</a><br /></td></tr>
<tr class="separator:aec9148af78b075f253c9848945df6135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598a822d22b02ba0d2c2a1095a4e700d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a598a822d22b02ba0d2c2a1095a4e700d">vec_iszerof128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a598a822d22b02ba0d2c2a1095a4e700d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true value, if the value that is +-0.0.  <a href="vec__f128__ppc_8h.html#a598a822d22b02ba0d2c2a1095a4e700d">More...</a><br /></td></tr>
<tr class="separator:a598a822d22b02ba0d2c2a1095a4e700d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2297dc22a6a3120491e1721648c0e7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a7c2297dc22a6a3120491e1721648c0e7">vec_nabsf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a7c2297dc22a6a3120491e1721648c0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative Absolute value Quad-Precision.  <a href="vec__f128__ppc_8h.html#a7c2297dc22a6a3120491e1721648c0e7">More...</a><br /></td></tr>
<tr class="separator:a7c2297dc22a6a3120491e1721648c0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3323b6fb0b379a21f3dd70f7f204bd2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3323b6fb0b379a21f3dd70f7f204bd2a">vec_negf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a3323b6fb0b379a21f3dd70f7f204bd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate the sign bit of a __float128 input and return the resulting __float128 value.  <a href="vec__f128__ppc_8h.html#a3323b6fb0b379a21f3dd70f7f204bd2a">More...</a><br /></td></tr>
<tr class="separator:a3323b6fb0b379a21f3dd70f7f204bd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47637906e95a7c94cffc093bc2e57dbf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a47637906e95a7c94cffc093bc2e57dbf">vec_self128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb, <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> mask)</td></tr>
<tr class="memdesc:a47637906e95a7c94cffc093bc2e57dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value.  <a href="vec__f128__ppc_8h.html#a47637906e95a7c94cffc093bc2e57dbf">More...</a><br /></td></tr>
<tr class="separator:a47637906e95a7c94cffc093bc2e57dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73">vec_setb_qp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Set Bool from Quadword Floating-point.  <a href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73">More...</a><br /></td></tr>
<tr class="separator:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4ca7749d334c2a2c17a4d2a98b5bf755">vec_signbitf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return int boolean true if the __float128 value is negative (sign bit is '1').  <a href="vec__f128__ppc_8h.html#a4ca7749d334c2a2c17a4d2a98b5bf755">More...</a><br /></td></tr>
<tr class="separator:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bff7954c22b5d85f976f046290f37b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aa3bff7954c22b5d85f976f046290f37b">vec_xsaddqpo</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aa3bff7954c22b5d85f976f046290f37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSX Scalar Add Quad-Precision using round to Odd.  <a href="vec__f128__ppc_8h.html#aa3bff7954c22b5d85f976f046290f37b">More...</a><br /></td></tr>
<tr class="separator:aa3bff7954c22b5d85f976f046290f37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8e71a4362e87704c5172b751ecbc6f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5f8e71a4362e87704c5172b751ecbc6f">vec_xssubqpo</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a5f8e71a4362e87704c5172b751ecbc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSX Scalar Subtract Quad-Precision using round to Odd.  <a href="vec__f128__ppc_8h.html#a5f8e71a4362e87704c5172b751ecbc6f">More...</a><br /></td></tr>
<tr class="separator:a5f8e71a4362e87704c5172b751ecbc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8ceb0eb2c47892371a12502d14f170"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a1a8ceb0eb2c47892371a12502d14f170">vec_xscvdpqp</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> f64)</td></tr>
<tr class="memdesc:a1a8ceb0eb2c47892371a12502d14f170"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSX Scalar Convert Double-Precision to Quad-Precision format.  <a href="vec__f128__ppc_8h.html#a1a8ceb0eb2c47892371a12502d14f170">More...</a><br /></td></tr>
<tr class="separator:a1a8ceb0eb2c47892371a12502d14f170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3c778a7c90b6e6a2d89cd5a1012061"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5e3c778a7c90b6e6a2d89cd5a1012061">vec_xscvqpdpo</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a5e3c778a7c90b6e6a2d89cd5a1012061"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSX Scalar Convert with round Quad-Precision to Double-Precision (using round to odd).  <a href="vec__f128__ppc_8h.html#a5e3c778a7c90b6e6a2d89cd5a1012061">More...</a><br /></td></tr>
<tr class="separator:a5e3c778a7c90b6e6a2d89cd5a1012061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ad56c509ea22f26fb2d47217bc5e51"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a73ad56c509ea22f26fb2d47217bc5e51">vec_xscvqpudz</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a73ad56c509ea22f26fb2d47217bc5e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSX Scalar Convert with round to zero Quad-Precision to Unsigned doubleword.  <a href="vec__f128__ppc_8h.html#a73ad56c509ea22f26fb2d47217bc5e51">More...</a><br /></td></tr>
<tr class="separator:a73ad56c509ea22f26fb2d47217bc5e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9d4ad5a60e9ffaa0ca16d29f90c092"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aaf9d4ad5a60e9ffaa0ca16d29f90c092">vec_xscvqpuqz</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aaf9d4ad5a60e9ffaa0ca16d29f90c092"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSX Scalar Convert with round to zero Quad-Precision to Unsigned Quadword.  <a href="vec__f128__ppc_8h.html#aaf9d4ad5a60e9ffaa0ca16d29f90c092">More...</a><br /></td></tr>
<tr class="separator:aaf9d4ad5a60e9ffaa0ca16d29f90c092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc58cb3be351ea2bf163aeb8dbb5709c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#acc58cb3be351ea2bf163aeb8dbb5709c">vec_xscvsdqp</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> int64)</td></tr>
<tr class="memdesc:acc58cb3be351ea2bf163aeb8dbb5709c"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSX Scalar Convert Signed-Doubleword to Quad-Precision format.  <a href="vec__f128__ppc_8h.html#acc58cb3be351ea2bf163aeb8dbb5709c">More...</a><br /></td></tr>
<tr class="separator:acc58cb3be351ea2bf163aeb8dbb5709c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eadadc05fe1873deadaef16926f6c86"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a1eadadc05fe1873deadaef16926f6c86">vec_xscvudqp</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> int64)</td></tr>
<tr class="memdesc:a1eadadc05fe1873deadaef16926f6c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSX Scalar Convert Unsigned-Doubleword to Quad-Precision format.  <a href="vec__f128__ppc_8h.html#a1eadadc05fe1873deadaef16926f6c86">More...</a><br /></td></tr>
<tr class="separator:a1eadadc05fe1873deadaef16926f6c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bfd64d7eefd8e84619950f19f827ba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a27bfd64d7eefd8e84619950f19f827ba">vec_xscvsqqp</a> (<a class="el" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> int128)</td></tr>
<tr class="memdesc:a27bfd64d7eefd8e84619950f19f827ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSX Scalar Convert Signed-Quadword to Quad-Precision format.  <a href="vec__f128__ppc_8h.html#a27bfd64d7eefd8e84619950f19f827ba">More...</a><br /></td></tr>
<tr class="separator:a27bfd64d7eefd8e84619950f19f827ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b1f22552fd177d10af1dbc0f43d5f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8">vec_xscvuqqp</a> (<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> int128)</td></tr>
<tr class="memdesc:a24b1f22552fd177d10af1dbc0f43d5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSX Scalar Convert Unsigned-Quadword to Quad-Precision format.  <a href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8">More...</a><br /></td></tr>
<tr class="separator:a24b1f22552fd177d10af1dbc0f43d5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62c779fc5de06a954a55d9c0ddd3baf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af62c779fc5de06a954a55d9c0ddd3baf">vec_xsmulqpo</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:af62c779fc5de06a954a55d9c0ddd3baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSX Scalar Multiply Quad-Precision using round to Odd.  <a href="vec__f128__ppc_8h.html#af62c779fc5de06a954a55d9c0ddd3baf">More...</a><br /></td></tr>
<tr class="separator:af62c779fc5de06a954a55d9c0ddd3baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95c675ceebc0627c777d2c7e2daef0b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> sig, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp)</td></tr>
<tr class="memdesc:af95c675ceebc0627c777d2c7e2daef0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Insert Exponent Quad-Precision.  <a href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">More...</a><br /></td></tr>
<tr class="separator:af95c675ceebc0627c777d2c7e2daef0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d78e42d9cc58491fa46149bf5798167"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a3d78e42d9cc58491fa46149bf5798167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Extract Exponent Quad-Precision.  <a href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">More...</a><br /></td></tr>
<tr class="separator:a3d78e42d9cc58491fa46149bf5798167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eb10beac182e936d7e49d491c34fe0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">vec_xsxsigqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:ab1eb10beac182e936d7e49d491c34fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Extract Significand Quad-Precision.  <a href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">More...</a><br /></td></tr>
<tr class="separator:ab1eb10beac182e936d7e49d491c34fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a77b974dcb698d916828f5986ea9cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a93a77b974dcb698d916828f5986ea9cd">vec_xxxexpqpp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a93a77b974dcb698d916828f5986ea9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Extract Exponent Quad-Precision Pair.  <a href="vec__f128__ppc_8h.html#a93a77b974dcb698d916828f5986ea9cd">More...</a><br /></td></tr>
<tr class="separator:a93a77b974dcb698d916828f5986ea9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over Quad-Precision floating point elements. </p>
<p>PowerISA 3.0B added Quad-Precision floating point type and operations to the Vector-Scalar Extension (VSX) facility. The first hardware implementation is available in POWER9.</p>
<p>PowerISA 3.1 added new min/max/compare Quad-Precision operations. Also added new quadword (128-bit) integer operations including converts between quadword integer and Quad-Precision floating point. The first hardware implementation is available in POWER10.</p>
<p>While all Quad-Precision operations are on 128-bit vector registers, they are defined as scalars in the PowerISA. The OpenPOWER ABI also treats the __float128 type as scalar that just happens to use vector registers for parameter passing and operations. As such no operations using __float128 (_Float128, or __ieee128) as parameter or return value are defined as vector built-ins in the ABI or &lt;altivec.h&gt;.</p>
<dl class="section note"><dt>Note</dt><dd>GCC 8.2 does document some built-ins, using the <em>scalar</em> prefix (scalar_extract_exp, scalar_extract_sig, scalar_test_data_class), that do accept the __ieee128 type. This work seems to be incomplete as scalar_exp_cmp_* for the __ieee128 type are not present. GCC 7.3 defines vector and scalar forms of the extract/insert_exp for float and double but not for __ieee128. These built-ins are not defined in GCC 6.4. See <a href="https://gcc.gnu.org/onlinedocs/">compiler documentation</a>. These are useful operations and can be implemented in a few vector logical instructions for earlier machines. So it seems reasonable to add these to pveclib for both vector and scalar forms.</dd></dl>
<p>Quad-Precision is not supported in hardware until POWER9. However the compiler and runtime supports the __float128 type and arithmetic operations via soft-float emulation for earlier processors. The soft-float implementation follows the ABI and passes __float128 parameters and return values in vector registers.</p>
<dl class="section note"><dt>Note</dt><dd>The performance of the libgcc soft-float (KF Mode) runtime for __float128 varies between releases of GCC. Some GCC versions introduced a bug that miss-compiled the transfer of __float128 parameters to GPR pairs as required for generic soft-float implementation. For POWER8 this results in a significant performance hit.</dd></dl>
<p>The PowerISA 3.0 also defines a number of useful quad-precision operations using the "round-to-odd" override. This is useful when the results of quad-precision arithmetic must be rounded to a shorter precision while avoiding double rounding. Recent GCC compilers support these operations as built-ins for the POWER9 target, but they not supported by the C language or GCC runtime library. This means that round-to-odd is not easily available to libraries that need to support IEEE-128 on POWER8. Again it may be reasonable to add these to pveclib.</p>
<dl class="section note"><dt>Note</dt><dd>See <a href="https://www.exploringbinary.com/gcc-avoids-double-rounding-errors-with-round-to-odd/">GCC Avoids Double Rounding Errors With Round-To-Odd</a></dd></dl>
<p>Another issue is the performance of GCC soft-float runtime for IEEE-128 (KF mode). There seem to be a number of issues with code generation for transfers from __float128 to 64-bit integer GPRs. This is required to match the ABI (vector) parameters to the soft-float runtime using integer scalars. For POWER8 targets the GCC compiler generates store vector followed by two load doubleword instructions. This generates high frequencies of load-hit-store rejects at runtime. It also looks like there is significant instruction latency associated with the XER carry bit required for extended (128-bit) integer arithmetic. </p><dl class="section note"><dt>Note</dt><dd>The first issue (parameter store reload) is a compiler bug. The second issue is an attribute of the hardware implementation and associate trade-offs. Both of these issues can be avoided by providing a soft-float implementation for __float128 using VSX vector 128-bit arithmetic and logical operations.</dd></dl>
<p>For the QP operations that have libgcc implementations and we have corresponding PVECLIB implementations we can do direct performance comparisons. So far micro-benchmarks show a significant performance gain for the PVECLIB vector implementations vs the GCC KF mode runtime.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Power8 QP </th><th class="markdownTableHeadCenter">cmpqp </th><th class="markdownTableHeadCenter">cvtdpqp </th><th class="markdownTableHeadCenter">cvtqpdp </th><th class="markdownTableHeadCenter">cvtuqqp </th><th class="markdownTableHeadCenter">cvtqpuq </th><th class="markdownTableHeadCenter">mulqp </th><th class="markdownTableHeadLeft">addqp  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">%improvement </td><td class="markdownTableBodyCenter">22.4 </td><td class="markdownTableBodyCenter">60.7 </td><td class="markdownTableBodyCenter">46.2* </td><td class="markdownTableBodyCenter">28.9 </td><td class="markdownTableBodyCenter">72.4 </td><td class="markdownTableBodyCenter">1.8* </td><td class="markdownTableBodyLeft">10.1*  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>These micro-benchmarks and others are included in src/testsuite. Specifically files vec_perf_f128.c and vec_f128_dummy.c. Make check will compile the appropriate files and link them into the pveclib_perf executable. Items marked with "*" compare the pveclib round-to-odd implementation to the soft-float default rounding mode. The libgcc soft-float runtime does not implement round-to-odd.</dd></dl>
<p>There are number of __float128 operations that should generate a single instruction for POWER9 and few (less than 10) instructions for POWER8. This includes all of the __float128 classification functions (isnormal/subnormal/finite/inf/nan/zero). Unfortunately for POWER8 the compilers will generate calls to the GCC runtime (__unordkf2, __gekf2, ...) for these functions. In many cases the code size generated for the runtime calls far exceeds any in-line VSX code PVECLIB will generate.</p>
<p>So it is not unreasonable for this header to provide vector forms of the __float128 classification functions (isnormal/subnormal/finite/inf/nan/zero). It is little additional effort to include the sign bit manipulation operations (copysign, abs, nabs, and neg).</p>
<p>These functions can be implemented directly using (one or more) POWER9 instructions, or a few vector logical and integer compare instructions for POWER7/8. Each is comfortably small enough to be in-lined and inherently faster than the equivalent POSIX or compiler built-in runtime functions. Performing these operations in-line and directly in vector registers (VRs) avoids call/return and VR &lt;-&gt; GPR transfer overhead. It also seems reasonable to provide Quad-Precision extract/insert exponent/significand and compare exponent operations for POWER7/8.</p>
<p>The PVECLIB implementations for quad-precision arithmetic and conversion operations are large enough that most applications will want to call a library. PVECLIB will build and release the appropriate CPU tuned libraries. This will follow the general design used for multiple quadword integer multiply functions (<a class="el" href="vec__int512__ppc_8h.html" title="Header package containing a collection of multiple precision quadword integer computation functions i...">vec_int512_ppc.h</a>).</p>
<dl class="section note"><dt>Note</dt><dd>At this time, PVECLIB does not intend to replace existing GCC/libm IEEE-128 runtime APIs and will maintain it own unique name-space. However if the maintainers of these projects want to leverage PVECLIB they are allowed under the terms of the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0.</a></dd></dl>
<p>These PVECLIB operations should be useful for applications using Quad-Precision while needing to still support POWER8 but also build for POWER9/10. An important goal is to allow applications and libraries to safely substitute PVECLIB operations for C language and math.h __float128 operators and functions as point optimizations. The largest gains will be seen for builds targeting POWER8 without degrading performance when targeting POWER9/10. They should also be useful and improve performance of soft-float implementations of Quad-Precision math library functions.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power8</b>, Quad-Precision floating-point built-ins operations useful for floating point classification are not defined. This header provides the appropriate substitutions, will generate the minimum code, appropriate for the target, and produce correct results.</dd>
<dd>
Most ppc64le compilers will default to <b>-mcpu=</b><em>power8</em> if <b>-mcpu</b> is not specified.</dd></dl>
<p>This header covers operations that are any of the following:</p>
<ul>
<li>Implemented in hardware instructions in newer processors, but useful to programmers on slightly older processors (even if the equivalent function requires more instructions).</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.h&gt; provided by available compilers in common use. Examples include scalar_test_neg, scalar_test_data_class, etc.</li>
<li>Defined for POWER9 (as built-ins) but not supported in the soft-float runtime implementation provided for POWER8. Examples include the arithmetic/conversion operations supporting the <em>round-to-odd</em> override.</li>
<li>Providing vector float tests for special conditions without generating extraneous floating-point exceptions. This is important for implementing __float128 forms of ISO C99 Math functions. Examples include vector isnan, isinf, etc.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious.</li>
</ul>
<h1><a class="anchor" id="f128_softfloat_0_0"></a>
Vector implementation of Quad-Precision Soft-float</h1>
<p>The discussion above raises a interesting question. If we can provide useful implementations of Quad-Precision; classification, extract/insert, and compare exponent operations, why not continue with Quad-Precision compare, convert to/from integer, and arithmetic operations?</p>
<p>This raises the stakes in complexity and size of implementation. Providing a vector soft-float implementation equivalent to the GCC run-time libgcc <b>__addkf3/__divkf3/__mulkf3/__subkf3</b> would be a substantial effort. The IEEE standard is exacting about rounding and exception handling. Comparisons require special handling of; signed zero, infinities, and NaNs. Even float/integer conversions require correct rounding and return special values for overflow. Also it is not clear how such an effort would be accepted.</p>
<p>The good news is PVECLIB already provides a strong quadword integer operations set. Integer Add, subtract, and multiply are covered with the usual compare/shift/rotate operations (See <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a> and <a class="el" href="vec__int64__ppc_8h.html" title="Header package containing a collection of 128-bit SIMD operations over 64-bit integer elements.">vec_int64_ppc.h</a>). The weak spot is general quadword integer divide. Until recently, integer divide has not been part of the vector ISA. But the introduction of Vector Divide Signed/Unsigned Quadword in POWER10 raises the priority of vector integer divide for PVECLIB.</p>
<p>For now we propose a phased approach, starting with enablers and infrastructure, building up layers, starting simple and adding complexity.</p>
<ul>
<li>Basic enablers; classification, extract/insert exponent, compare exponent.</li>
<li>Quad-Precision comparison operators.<ul>
<li>Initially ignore special cases and exceptions</li>
<li>Add Signed Zero, Infinity. and NaN special cases</li>
<li>Exceptions (FPSCR) when someone asks</li>
</ul>
</li>
<li>Quad-Precision from/to integer word/doubleword/quadword.<ul>
<li>Cases that don't require rounding (i.e truncate and DW to QP).</li>
<li>Cases that require rounding<ul>
<li>Round to odd.</li>
<li>Round to Nearest/Even</li>
<li>Others if asked</li>
</ul>
</li>
</ul>
</li>
<li>Quad-Precision arithmetic<ul>
<li>Add/Sub/Mul<ul>
<li>Round-to-Odd first</li>
</ul>
</li>
<li>Fused Multiply-Add<ul>
<li>Round-to-Odd first</li>
</ul>
</li>
<li>Divide<ul>
<li>Round-to-Odd first</li>
<li>Will need <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a> implementation of vec_divuq()</li>
</ul>
</li>
<li>Signed Zero, Infinity. and NaN special cases</li>
<li>Other rounding modes</li>
<li>Exceptions (FPSCR) when someone asks</li>
</ul>
</li>
</ul>
<p>The intent is that such PVECLIB operations can be mixed in with or substituted for C Language _FLoat128 expressions or functions. The in-lined operations should have performance advantages over equivalent library functions on both POWER8/9.</p>
<p>This is a big list. It is TBD how far I will get given my current limited resources.</p>
<dl class="section note"><dt>Note</dt><dd>We are focusing on POWER8 here because the implementation gets a lot harder for POWER7 and earlier. POWER7 is missing:<ul>
<li>Vector Quadword integer add/sub with carry extend.</li>
<li>Vector Doubleword integer arithmetic, compares. and count-leading zeros.</li>
<li>Vector Word integer multiply.</li>
<li>Direct transfer between VRs and GPRs.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="f128_softfloat_0_0_0"></a>
Quad-Precision data class and exponent access for POWER8</h2>
<p>Most math library functions need to test the data class (normal, infinity, NaN, etc) and or range of input values. This usually involves separating the sign, exponent, and significand out from __float128 values, and comparing one or more of these parts, to special integer values.</p>
<p>PowerISA 3.0B (POWER9) provides instructions for these in addition to a comprehensive set of arithmetic and compare instructions. These operations are also useful for the soft-float implementation of __float128 for POWER8 and earlier. The OpenPOWER ABI specifies __float128 parameters are in VRs and are immediately accessible to VMX/VSR instructions. This is important as the cost of transferring values between VRs and GPRs is quite high on POWER8 and even higher for POWER7 and earlier (which requires store to temporaries and reload).</p>
<p>Fortunately these operations only require logical (and/or/xor), shift and integer compare operations to implement. These are available as vector intrinsics or provides by PVECLIB (see <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>).</p>
<p>The operations in this group include:</p><ul>
<li>Altivec like predicates; <a class="el" href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad" title="Return true if the __float128 value is Finite (Not NaN nor Inf).">vec_all_isfinitef128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da" title="Return true if the __float128 value is infinity.">vec_all_isinff128()</a>, <a class="el" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89" title="Return true if the __float128 value is Not a Number (NaN).">vec_all_isnanf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d" title="Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).">vec_all_isnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#adf1a94cccdb3f106a0e6399e2f034718" title="Return true if the __float128 value is subnormal (denormal).">vec_all_issubnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414" title="Return true if the __float128 value is +-0.0.">vec_all_iszerof128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a4ca7749d334c2a2c17a4d2a98b5bf755" title="Return int boolean true if the __float128 value is negative (sign bit is &#39;1&#39;).">vec_signbitf128()</a>.</li>
<li>Vector boolean predicates; <a class="el" href="vec__f128__ppc_8h.html#ad1668ff13922ca04059f1844a7a1464f" title="Return 128-bit vector boolean true if the __float128 value is Finite (Not NaN nor Inf).">vec_isfinitef128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a94f9c7429c2ebd9b9f32ad6e98689ebb" title="Return a 128-bit vector boolean true if the __float128 value is infinity.">vec_isinff128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72" title="Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN).">vec_isnanf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#aa25185c83b69f6af3f3d9399199c8a57" title="Return 128-bit vector boolean true if the __float128 value is normal (Not NaN, Inf,...">vec_isnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a9670e4655a9c7888c80343780cd7abf9" title="Return 128-bit vector boolean true value, if the __float128 value is subnormal (denormal).">vec_issubnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a598a822d22b02ba0d2c2a1095a4e700d" title="Return 128-bit vector boolean true value, if the value that is +-0.0.">vec_iszerof128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73" title="Vector Set Bool from Quadword Floating-point.">vec_setb_qp()</a>.</li>
<li>Sign bit manipulation; <a class="el" href="vec__f128__ppc_8h.html#add641f5a217eff45f0e836fa98613584" title="Absolute Quad-Precision.">vec_absf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a7c2297dc22a6a3120491e1721648c0e7" title="Negative Absolute value Quad-Precision.">vec_nabsf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a3323b6fb0b379a21f3dd70f7f204bd2a" title="Negate the sign bit of a __float128 input and return the resulting __float128 value.">vec_negf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e" title="Copy the sign bit from f128x and merge with the magnitude from f128y. The merged result is returned a...">vec_copysignf128()</a>.</li>
<li>Data manipulation; <a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b" title="Scalar Insert Exponent Quad-Precision.">vec_xsiexpqp()</a>, <a class="el" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167" title="Scalar Extract Exponent Quad-Precision.">vec_xsxexpqp()</a>, <a class="el" href="vec__f128__ppc_8h.html#a93a77b974dcb698d916828f5986ea9cd" title="Vector Extract Exponent Quad-Precision Pair.">vec_xxxexpqpp()</a>, <a class="el" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0" title="Scalar Extract Significand Quad-Precision.">vec_xsxsigqp()</a>.</li>
<li>Exponent Compare; <a class="el" href="vec__f128__ppc_8h.html#a1e6c52eb3208f4d9ed851ee48f773d68" title="Vector Compare Quad-Precision Exponents for Equal.">vec_cmpqp_exp_eq()</a>, <a class="el" href="vec__f128__ppc_8h.html#abf2d90d67cb3f605fbc9598f133b0305" title="Vector Compare Exponents Quad-Precision for Greater Than.">vec_cmpqp_exp_gt()</a>, <a class="el" href="vec__f128__ppc_8h.html#a3eb9b92be998695424107de6a60890a8" title="Vector Compare Exponents Quad-Precision for Less Than.">vec_cmpqp_exp_lt()</a>, <a class="el" href="vec__f128__ppc_8h.html#a3014214c103453a34372cc52e6d79073" title="Vector Compare Exponents Quad-Precision for Unordered.">vec_cmpqp_exp_unordered()</a>.</li>
</ul>
<p>For example the data class test isnan: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line"><a class="code" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">vec_isnanf128</a> (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR9) &amp;&amp; defined (scalar_test_data_class) &amp;&amp; \</span></div>
<div class="line"><span class="preprocessor">  defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> result = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (scalar_test_data_class (f128, 0x40))</div>
<div class="line">    result = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (-1, -1, -1, -1);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>)result;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> tmp;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x80000000, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x7fff0000, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line">  tmp = <a class="code" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (f128, signmask);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>)tmp , (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>)expmask);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">}</span></div>
</div><!-- fragment --><p> Which has implementations for POWER9 (and later) and POWER8 (and earlier).</p>
<p>For POWER9 it generates: </p><div class="fragment"><div class="line">xststdcqp cr0,v2,64</div>
<div class="line">bne     .+12</div>
<div class="line">xxspltib vs34,255</div>
<div class="line">b       .+8</div>
<div class="line">xxspltib vs34,0</div>
</div><!-- fragment --><p> Which uses the intrinsic scalar_test_data_class() to generate the VSX Scalar Test Data Class Quad-Precision instruction with "data class mask" of <em>class.NaN</em> to set the condition code. If the condition is <em>match</em>, load the 128-bit bool value of all 1's (true). Otherwise load all 0's (false).</p>
<p>For POWER8 it generates </p><div class="fragment"><div class="line">addis   r9,r2,@ha.rodata.cst16+0x30</div>
<div class="line">vspltisw v1,-1</div>
<div class="line">vspltisw v12,0</div>
<div class="line">addi    r9,r9,@l.rodata.cst16+0x30</div>
<div class="line">vslw    v1,v1,v1</div>
<div class="line">lvx     v0,0,r9</div>
<div class="line">vsldoi  v1,v1,v12,12</div>
<div class="line"> </div>
<div class="line">xxlandc vs33,vs34,vs33</div>
<div class="line">vsubcuq v0,v0,v1</div>
<div class="line">xxspltw vs32,vs32,3</div>
<div class="line">vcmpequw v2,v0,v12</div>
</div><!-- fragment --><p> The first 7 instructions above, load the constant vectors needed by the logic. These constants only need to be generated once per function and can be shared across operations.</p>
<p>In the C code we use a special transfer function combined with logical AND complement (<a class="el" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab" title="Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask.">vec_andc_bin128_2_vui32t()</a>). This is required because while __float128 values are held in VRs, the compiler considers them to be scalars and will not allow simple casts to (any) vector type. So the PVECLIB implementation provides <em>xfer</em> function using a union to transfer the __float128 value to a vector type. In most case this logical transfer simply serves to make the compiler happy and does not need to generate any code. In this case the <em>xfer</em> function combines the transfer with a vector and complement to mask off the sign bit.</p>
<p>Then compare the masked result as a 128-bit integer value greater than infinity (expmask). Here we use the <a class="el" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e" title="Vector Compare Greater Than Unsigned Quadword.">vec_cmpgtuq()</a> operation from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>. For POWER8, <a class="el" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e" title="Vector Compare Greater Than Unsigned Quadword.">vec_cmpgtuq()</a> generates the Vector Subtract and Write Carry Unsigned Quadword instruction for 128-bit unsigned compares. A '0' carry indicates greater than. The next two instructions (from <a class="el" href="vec__int128__ppc_8h.html#a921647d5b67f0de5006ee32fb3d9c4f1" title="Vector Set Bool from Quadword not Carry.">vec_setb_ncq()</a>) convert the carry bit to the required 128-bit bool value.</p>
<p>While the POWER8 sequence requires more instructions (including the const vector set up) than POWER9, it is not significantly larger. And as mentioned above, the set-up code can be optimized across operations sharing the same constants. The code (less the setup) is only 10 cycles for POWER8 vs 6 for POWER9. Also the code is not any larger than the function call overhead for the libgcc runtime equivalent <b>__unordkf2</b>. And is much faster then the generic soft-float implementation.</p>
<p>Another example, Scalar Extract Exponent Quad-Precision:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div>
<div class="line"><a class="code" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR9) &amp;&amp; defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xsxexpqp %0,%1&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (f128)</div>
<div class="line">      : );</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> tmp;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x7fff0000, 0, 0, 0)</div>
<div class="line"> </div>
<div class="line">  tmp = <a class="code" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (f128, expmask);</div>
<div class="line">  result = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) vec_sld (tmp, tmp, 10);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Which has implementations for POWER9 (and later) and POWER8 (and earlier).</p>
<p>For POWER9 it generates the VSX Scalar Extract Exponent Quad-Precision instruction. </p><div class="fragment"><div class="line">xsxexpqp v2,v2</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Would like to use the intrinsic scalar_extract_exp() here but this is not available until GCC 11 (or later). Also GCC defines these scalar built-ins to return integer scalar values in GPRs. This would defeat the purpose of an all vector implementation.</dd></dl>
<p>For POWER8 we generate </p><div class="fragment"><div class="line">addis   r9,r2,.rodata.cst16+0xc0@ha</div>
<div class="line">addi    r9,r9,.rodata.cst16+0xc0@l</div>
<div class="line">lvx     v13,0,r9</div>
<div class="line"> </div>
<div class="line">xxland  vs34,vs34,vs45</div>
<div class="line">vsldoi  v2,v2,v2,10</div>
</div><!-- fragment --><p> The first 3 instructions above load the constant vector needed by the logic. This constant only needs to be generated once per function and can be shared across operations.</p>
<p>Again we use a special transfer function combined with logical AND (<a class="el" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e" title="Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask.">vec_and_bin128_2_vui32t()</a>) to transfer the__float128 to a vector type and mask off all bits except for the 15-bit exponent. Then we rotate the exponent logically right 48-bit to right justify the exponent in vector doubleword 0. This matches the results of the xsxexpqp instruction.</p>
<h2><a class="anchor" id="f128_softfloat_IRRN_0_0"></a>
Intermediate results and Rounding for Quad-Precision</h2>
<p>The IEEE-128 floating-point storage (external) format fits neatly in 128-bits. But this compact format needs to be expanded internally during QP operations. The sign and exponent are normally manipulated separately from the significand. And for finite values the Leading-bit (implied but not included in the storage format) must be restored to take part in arithmetic/rounding/normalization operations.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>Leading</em>, <em>Hidden</em>, and <em>Implicit</em> bits are different names for the most significant bit of the significand. This bit is Hidden or Implicit only for the external or storage format of floating-point numbers. But it needs to be explicitly represented in the internal <em>Intermediate Results (<b>IR</b>)</em>. See Also: PowerISA 3.0 7.3.3 VSX Floating-Point Execution Models.</dd></dl>
<p>For a soft-float implementation of IEEE-128 on POWER8 we want to extract these components into 128-bit vector registers and operate on them using vector instructions. This allows direct use of 128-bit arithmetic/shift/rotate operations (see <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>), while avoiding expensive transfers between VRs and GPRs.</p>
<p>To extract the sign-bit we can either AND with a 128-bit mask or use a set-bool operation (<a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73" title="Vector Set Bool from Quadword Floating-point.">vec_setb_qp()</a> or <a class="el" href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802" title="Vector Set Bool from Signed Quadword.">vec_setb_sq()</a>). The masked sign-bit can be ORed with the final IEEE-128 vector result to set the appropriate sign. The 128-bit vector bool can be used with vec_sel() (<a class="el" href="vec__f128__ppc_8h.html#a47637906e95a7c94cffc093bc2e57dbf" title="Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binar...">vec_self128()</a>, <a class="el" href="vec__int128__ppc_8h.html#a9d388d607e331ffb7cecd6dcbdd0d18b" title="Vector Select Signed Quadword.">vec_selsq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd" title="Vector Select Unsigned Quadword.">vec_seluq()</a>) to select results based on the sign-bit while avoiding branch logic.</p>
<p>We use <a class="el" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167" title="Scalar Extract Exponent Quad-Precision.">vec_xsxexpqp()</a> to extract the 15-bit exponent into a vector doubleword integer element. The biased exponent is returned in the high doubleword (matching the POWER9 instruction). Depending on the operation, the exponent (or derived values) may need to be transfered/replicated to the low doubleword element. This is easily accomplished using <a class="el" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c" title="Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of ...">vec_splatd()</a>. Operations requiring two Quad-precision operands can combine the extracted exponents into a single vector doubleword using <a class="el" href="vec__int64__ppc_8h.html#acd5bafec6c1c15b0336551e82d1169d4" title="Vector Merge Algebraic High Doublewords.">vec_mrgahd()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Operations requiring two Quad-precision operands have an opportunity to vectorize the exponent extraction and comparisons (all/any) for finite vs NaN/Infinity. See <a class="el" href="vec__f128__ppc_8h.html#a93a77b974dcb698d916828f5986ea9cd" title="Vector Extract Exponent Quad-Precision Pair.">vec_xxxexpqpp()</a>.</dd></dl>
<p>We use <a class="el" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0" title="Scalar Extract Significand Quad-Precision.">vec_xsxsigqp()</a> to extract the 113-bit significand into a vector quadword integer. This operation restores the leading-bit for normal (not NaN, Infinity, denormal or zero) values. The significand is returned right-justified in the quadword.</p>
<p>At the end of the operation we can use vec_or() and <a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b" title="Scalar Insert Exponent Quad-Precision.">vec_xsiexpqp()</a> to combine these (sign, exponent, and significand) components into a IEEE-128 result.</p>
<h3><a class="anchor" id="f128_softfloat_IRRN_0_1"></a>
Representing Intermediate results for Quad-Precision</h3>
<p>Internal IEEE floating-point operations will need/generate additional bits to support normalization and rounding. The PowerISA describes a <b>VSX Execution Model for IEEE Operations</b> </p><dl class="section see"><dt>See also</dt><dd>PowerISA 3.0B, Book I, Section 7.3.3 VSX Floating-Point Execution Models.</dd></dl>
<p>IEEE quad-precision execution model </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter">0 </th><th class="markdownTableHeadCenter">1 --------------------------&mdash; 112 </th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadRight"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">S </td><td class="markdownTableBodyCenter">C </td><td class="markdownTableBodyCenter">L </td><td class="markdownTableBodyCenter">FRACTION </td><td class="markdownTableBodyCenter">G </td><td class="markdownTableBodyCenter">R </td><td class="markdownTableBodyRight">X  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft" colspan="7">- Sign bit  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft" colspan="7">- Carry bit  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft" colspan="7">- Leading bit, also called the implicit or hidden bit  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft" colspan="7">- Fraction (112-bits)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft" colspan="7">- Guard bit  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft" colspan="7">- Round bit  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft" colspan="7">- (X) AKA Sticky bit, logical OR of remaining bits  </td></tr>
</table>
<p>This model is a guide for processor design and soft-float implementors. This is also described as the <em>Intermediate result Representation (<b>IR</b>)</em>. As such the implementation may arrange these bits into different registers as dictated by design and performance.</p>
<p>The GRX bits extend the low order bits of the fraction and are required for rounding. Basically these bits encode how <em>near</em> the intermediate result is to a representable result. The GR bits are required for post-normalization of the result and participate in shifts during normalization. For right shifts, bits shift out of the R-bit are logically ORed into the X-bit. For left shifts, 0 bits shifted into the R-bit (the X-bit is ignored).</p>
<p>As mentioned before, it is convenient to keep the sign-bit in a separate vector quadword. This not an extension of the significand but is needed to select results for arithmetic and some rounding modes. The remaining (C through X) bits can be represented in a vector quadword register or a vector register pair.</p>
<h4><a class="anchor" id="f128_softfloat_IRRN_0_1_1"></a>
IR for conversion</h4>
<p>For example integer to QP conversions can be represented in a vector quadword by left justifying the magnitude before normalization and rounding. For example from <a class="el" href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8" title="VSX Scalar Convert Unsigned-Quadword to Quad-Precision format.">vec_xscvuqqp()</a>: </p><div class="fragment"><div class="line">{ <span class="comment">// We need to produce a normal QP, so we treat the integer like a</span></div>
<div class="line">  <span class="comment">// denormal, then normalize it.</span></div>
<div class="line">  <span class="comment">// Start with the quad exponent bias + 127 then subtract the count of</span></div>
<div class="line">  <span class="comment">// leading &#39;0&#39;s. The 128-bit significand can have 0-127 leading &#39;0&#39;s.</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_expm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> (0, (0x3fff + 127));</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> i64_clz = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49">vec_clzq</a> (q_sig);</div>
<div class="line">  q_sig = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) i64_clz);</div>
<div class="line">  q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_expm, i64_clz);</div>
<div class="line">  <span class="comment">// This is the part that might require rounding.</span></div>
<div class="line">  <span class="comment">// The Significand (including the L-bit) is right justified in</span></div>
<div class="line">  <span class="comment">// in the high-order 113-bits of q_sig.</span></div>
<div class="line">  <span class="comment">// The guard, round, and sticky (GRX) bits are in the low-order</span></div>
<div class="line">  <span class="comment">// 15 bits.</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>See <a class="el" href="vec__f128__ppc_8h.html#f128_softfloat_IRRN_0_2_1">Examples for Round to Nearest Even</a> and <a class="el" href="vec__f128__ppc_8h.html#f128_softfloat_IRRN_0_2_2">Examples for Round toward Zero</a>.</p>
<p>The <em>Round to Nearest Even</em> case may increment the significand and that may generate a carry from the <b>L-bit</b>. One option is to use <a class="el" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3" title="Vector Add &amp; write Carry Unsigned Quadword.">vec_addcuq()</a> to capture the carry. For example: </p><div class="fragment"><div class="line">...</div>
<div class="line"><span class="comment">// We add 0x3fff to GRX-bits which may carry into low order sig-bit</span></div>
<div class="line"><span class="comment">// This may result in a carry out from the L-bit into C-bit.</span></div>
<div class="line">q_carry = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) RXmask);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) RXmask);</div>
<div class="line"><span class="comment">// Generate a bool mask from the carry to use in the vsel</span></div>
<div class="line">qcmask = <a class="code" href="vec__int128__ppc_8h.html#af74036e39e72e0f3c29706d30fbb96d1">vec_setb_cyq</a> (q_carry);</div>
<div class="line"><span class="comment">// Two cases; 1) We did carry so shift (double) left 112 bits</span></div>
<div class="line">q_sigc = <a class="code" href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a> (q_carry, q_sig, 112);</div>
<div class="line"><span class="comment">// 2) no carry so shift right 15 bits</span></div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
<div class="line"><span class="comment">// Select which based on carry</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sigc, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) qcmask);</div>
<div class="line"><span class="comment">// Increment the exponent based on the carry</span></div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (q_exp, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) q_carry);</div>
</div><!-- fragment --><p> In this case having the carry as a separate vector simplifies adjusting the exponent.</p>
<h4><a class="anchor" id="f128_softfloat_IRRN_0_1_2"></a>
IR for addition</h4>
<p>Quad-precision addition and subtraction is a case where right justifying the <b>IR</b> is helpful. For addition/subtraction the <b>IR</b> only needs 117-bits which can be accommodated in a single 128-vector. Significands (which includes the leading/implicit bit) can be converted to <b>IR</b> form by shifting left 3-bits. This still leaves room on the left for the carry-bit. For example: </p><div class="fragment"><div class="line"><span class="comment">// Precondition the significands before add so the GRX bits</span></div>
<div class="line"><span class="comment">// are in the least significant 3 bit.</span></div>
<div class="line">a_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (a_sig, 3);</div>
<div class="line">b_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (b_sig, 3);</div>
</div><!-- fragment --><p> In this case we need to insure that any right shifts of the <b>IR</b> collect any bits shifted-away into the X-bit. For example: </p><div class="fragment"><div class="line"><span class="comment">// At this point we can assume that:</span></div>
<div class="line"><span class="comment">// 1) The magnitude (vfa) &gt;= magnitude (vfb)</span></div>
<div class="line"><span class="comment">// 1a) Exponents (a_exp, b_exp) in the range E_min -&gt; E_max</span></div>
<div class="line"><span class="comment">// 1b) The GRX-bits of a_sig/b_sig are still 0b000.</span></div>
<div class="line"><span class="comment">// 2) a_exp &gt;= b_exp</span></div>
<div class="line"><span class="comment">// 2a) If a_exp == b_exp then a_sig &gt;= b_sig</span></div>
<div class="line"><span class="comment">// 2b) If a_exp &gt; b_exp then</span></div>
<div class="line"><span class="comment">//     shift (b_sig) right by (a_exp - b_exp) bits</span></div>
<div class="line"><span class="comment">//     any bits shifted out of b_sig are ORed into the X-bit</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a> (b_exp, a_exp))</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d_exp, l_exp;</div>
<div class="line">    <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> t_sig;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_128 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 128, 128 );</div>
<div class="line"> </div>
<div class="line">    d_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (a_exp, b_exp);</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a> (d_exp, exp_128))</div>
<div class="line">      {</div>
<div class="line">        l_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (exp_128, d_exp);</div>
<div class="line">        t_sig = <a class="code" href="vec__int128__ppc_8h.html#a0edd172a5656b842d6586c5078284942">vec_srq</a> (b_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_exp);</div>
<div class="line">        x_bits = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (b_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) l_exp);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">        x_bits = b_sig;</div>
<div class="line">        t_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero;</div>
<div class="line">      }</div>
<div class="line">    <span class="comment">// Collect any bits shifted-away, into a single carry bit</span></div>
<div class="line">    p_odd = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (x_bits, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_ones);</div>
<div class="line">    <span class="comment">// OR this into the X-bit</span></div>
<div class="line">    b_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) t_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_odd);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> In this case, condition-1 means that, only b_sig needs right shifting before significand addition. The a_sig can be used directly as it had previously been left shifted 3-bits where the GRX-bits were set to 0b000.</p>
<p>A simpler case occurs when addition generates a carry. Here we need to shift right 1-bit while preserving any nonzero X-bit. For example: </p><div class="fragment"><div class="line"><span class="comment">// Check for carry and adjust</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#ac93dc5ed8bb3501470cf70c5cb5796a9">vec_cmpuq_all_gt</a> (s_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) sigov))</div>
<div class="line">  {</div>
<div class="line">    p_odd = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) s_sig, xbitmask);</div>
<div class="line">    s_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (s_sig, 1);</div>
<div class="line">    s_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) s_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_odd);</div>
<div class="line">    q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (q_exp, q_one);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> These two sequences preserve the X-bit going into the rounding stage. See <a class="el" href="vec__f128__ppc_8h.html#f128_softfloat_IRRN_0_2_1">Examples for Round to Nearest Even</a> and <a class="el" href="vec__f128__ppc_8h.html#f128_softfloat_IRRN_0_2_6">Examples for Round to Odd</a>.</p>
<h4><a class="anchor" id="f128_softfloat_IRRN_0_1_3"></a>
IR for multiply</h4>
<p>Quad-precision Multiply and Multiply-Add require quadword register pairs to hold the <b>IR</b> product. The product of two 113-bit significands requires 226-bits. This includes the product C-/L-bits but we will need at least 3 additional bits for GRX.</p>
<p>We can use operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a> to produce the double quadword product. By pre-adjusting the inputs before the multiply we can align the split between the high 114-bits (right justified) and low 112-bits (left justified) of the product to align with the high and low quadword registers. For example: </p><div class="fragment"><div class="line"><span class="comment">// Pre-align the multiply inputs so that the product is split</span></div>
<div class="line"><span class="comment">// with the CL-Fraction-bits in high_sig, and GRX-bits in low_sig.</span></div>
<div class="line">a_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (a_sig, 8);</div>
<div class="line">b_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (b_sig, 8);</div>
<div class="line">low_sig = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;high_sig, a_sig, b_sig);</div>
</div><!-- fragment --><p> The high_sig includes the C-/L-bits and high-order 112-bits of product fraction. The low_sig includes the low order 112-bits of the fraction followed by 16-bits of zero.</p>
<p>Most of the low-order fraction bits contribute to the X-bit. So we can normally delay collecting x-bits until the rounding stage. Only the most extreme denormals will result in a right shift large enough to require intervention to preserve bits that would otherwise be shifted away.</p>
<p>After normalization the high-order bits of low_sig become the GRX-bits. Actually we can treat the low order 126-bits as uncollected x-bits. We use this to simplify the rounding process. For this case we can manipulate low_sig to generate a carry for rounding up/down/odd and then add/subtract/or this carry to high_sig to produce the rounded product significand. See <a class="el" href="vec__f128__ppc_8h.html#f128_softfloat_IRRN_0_2_1">Examples for Round to Nearest Even</a> and <a class="el" href="vec__f128__ppc_8h.html#f128_softfloat_IRRN_0_2_6">Examples for Round to Odd</a>.</p>
<h3><a class="anchor" id="f128_softfloat_IRRN_0_2"></a>
Rounding for Quad-Precision</h3>
<p>The PowerISA support 6 rounding modes for Quad-Precision</p>
<ul>
<li>Round to Nearest Even</li>
<li>Round towards Zero</li>
<li>Round towards +Infinity</li>
<li>Round towards -Infinity</li>
<li>Round to Nearest Away</li>
<li>Round to Odd</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>See <a href="https://www.exploringbinary.com/gcc-avoids-double-rounding-errors-with-round-to-odd/">GCC Avoids Double Rounding Errors With Round-To-Odd</a></dd></dl>
<p>The first four modes are encoded in the <b>FPSCR<sub>RN</sub></b> rounding mode bits. The last two are encoded in instructions as instruction local overrides. The VSX Scalar Round to Quad-Precision Integer instruction can override the RN and encode any of the six rounding modes.</p>
<p>The rounding mode results are defined in terms of the intermediate result (IR), and how close it is to the <em>representable result</em>, based on the GRX-bits. The IR is either; exact, closer to the next lower (NL) representable result, Midway between, or closer to the next Higher (NH) representable result,</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">G </th><th class="markdownTableHeadCenter">R </th><th class="markdownTableHeadCenter">X </th><th class="markdownTableHeadLeft">interpretation  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyLeft">IR is exact  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyLeft">IR is closer to NL  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyLeft">IR is closer to NL  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyLeft">IR is closer to NL  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyLeft">IR is midway between NL and NH  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyLeft">IR is closer to NH  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyLeft">IR is closer to NH  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyLeft">IR is closer to NH  </td></tr>
</table>
<p>Next lower is effectively truncating the IR (setting GRX = 0b000), while next higher will increment the significand by one.</p>
<ul>
<li>Round to Nearest Even<ul>
<li>If exact chose IR</li>
<li>Otherwise if IR is closer to NL, choose NL</li>
<li>Otherwise if IR is closer to NH, choose NH</li>
<li>Otherwise if IR in midway, choose whichever makes the result even.</li>
</ul>
</li>
<li>Round towards Zero<ul>
<li>If exact chose IR</li>
<li>Otherwise, choose NL</li>
</ul>
</li>
<li>Round towards +Infinity<ul>
<li>If exact chose IR</li>
<li>Otherwise if positive, choose NH</li>
<li>Otherwise if negative, choose NL</li>
</ul>
</li>
<li>Round towards -Infinity<ul>
<li>If exact chose IR</li>
<li>Otherwise if positive, choose NL</li>
<li>Otherwise if negative, choose NH</li>
</ul>
</li>
<li>Round to Nearest Away<ul>
<li>If exact chose IR</li>
<li>Otherwise if G = 0, choose NL</li>
<li>Otherwise if G = 1, choose NH</li>
</ul>
</li>
<li>Round to Odd<ul>
<li>If exact chose IR</li>
<li>Otherwise, choose NL, and if G=1, or R=1, or X=1, set the least significant bit to 1.</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The coding examples that follow are incomplete. More examples will be provided are more operation are completed and tested.</dd></dl>
<p>The exact coding for rounding modes depends on how the <b>IR</b> is represented in vector registers and this may differ by operation. Conversions, addition, and subtraction tend to use a single vector register where the GRX resides in the low-order bits. While Multiplies generate double quadword results and so use vector register pairs. Here the CL and Fraction bits are right justified in a high_sig vector. While the low-order fraction/GRX bits are left justified in a low_sig vector.</p>
<h4><a class="anchor" id="f128_softfloat_IRRN_0_2_1"></a>
Examples for Round to Nearest Even</h4>
<p>Example for Convert to Quad-precision: </p><div class="fragment"><div class="line">...</div>
<div class="line"><span class="comment">// We add 0x3fff to GRX-bits which may carry into low order sig-bit</span></div>
<div class="line"><span class="comment">// This may result in a carry out from the L-bit into C-bit.</span></div>
<div class="line">q_carry = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) RXmask);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) RXmask);</div>
<div class="line"><span class="comment">// Generate a bool mask from the carry to use in the vsel</span></div>
<div class="line">qcmask = <a class="code" href="vec__int128__ppc_8h.html#af74036e39e72e0f3c29706d30fbb96d1">vec_setb_cyq</a> (q_carry);</div>
<div class="line"><span class="comment">// Two cases; 1) We did carry so shift (double) left 112 bits</span></div>
<div class="line">q_sigc = <a class="code" href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a> (q_carry, q_sig, 112);</div>
<div class="line"><span class="comment">// 2) no carry so shift right 15 bits</span></div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
<div class="line"><span class="comment">// Select which based on carry</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sigc, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) qcmask);</div>
<div class="line"><span class="comment">// Increment the exponent based on the carry</span></div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (q_exp, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) q_carry);</div>
</div><!-- fragment --><p> This code runs about 16 instructions.</p>
<p>Example for Add/Subtract Quad-precision: </p><div class="fragment"><div class="line"><span class="comment">// Round to nearest even from low_sig bits</span></div>
<div class="line"><span class="comment">// For &quot;round to Nearest, ties to even&quot;.</span></div>
<div class="line"><span class="comment">// GRX = 0b001 - 0b011; truncate</span></div>
<div class="line"><span class="comment">// GRX = 0b100 and bit-127 is odd; round up, otherwise truncate</span></div>
<div class="line"><span class="comment">// GRX = 0b100 - 0b111; round up</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> rmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0, 0, 0, 3);</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> p_rnd;</div>
<div class="line"><span class="comment">// We can simplify by copying the low order fraction bit (p_odd)</span></div>
<div class="line"><span class="comment">// and ADD it to the bit-X. This forces a tie into rounding up</span></div>
<div class="line"><span class="comment">// if the current fraction is odd, making it even.</span></div>
<div class="line"><span class="comment">// This simplifies to (s_sig + rmask + p_odd)</span></div>
<div class="line"><span class="comment">// Rounding will generate a carry into the low order fraction bit</span></div>
<div class="line"><span class="comment">// if and only if GRX &gt; 0b100 or (GRX == 0b100) &amp;&amp; (bit-127 == 1)</span></div>
<div class="line"> </div>
<div class="line">p_tmp = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (s_sig, 3);</div>
<div class="line">p_odd = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_tmp, onemask);</div>
<div class="line">s_sig = <a class="code" href="vec__int128__ppc_8h.html#af18b98d2d73f1afbc439e1407c78f305">vec_addecuq</a> (s_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) rmask, p_odd);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (s_sig, 3);</div>
</div><!-- fragment --><p> Adding 3 plus the fraction odd bit to thex GRX-bits generates a carry into the low-order fraction bit for rounding. In this case we use the extend form of add quadword to effect a 3 way add. After rounding convert the <b>IR</b> into a significand by shifting right 3 bits.</p>
<p>Example for Multiply Quad-precision: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> rmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x7fffffff, -1, -1, -1);</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> p_rnd;</div>
<div class="line"><span class="comment">// We can simplify by copying the low order bit (p_odd) of high_sig</span></div>
<div class="line"><span class="comment">// and OR it with the bit-X. This forces a tie into rounding up</span></div>
<div class="line"><span class="comment">// if the current fraction is odd, making it even.</span></div>
<div class="line"><span class="comment">// This simplifies to the carry from (low_sig + rmask + p_odd)</span></div>
<div class="line"><span class="comment">// Rounding will generate a carry into p_rnd.</span></div>
<div class="line"><span class="comment">// if and only if GRX &gt; 0b100 or (GRX == 0b100) &amp;&amp; (bit-127 == 1)</span></div>
<div class="line">p_odd = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) high_sig, onemask);</div>
<div class="line">p_rnd = <a class="code" href="vec__int128__ppc_8h.html#af18b98d2d73f1afbc439e1407c78f305">vec_addecuq</a> (low_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) rmask, p_odd);</div>
<div class="line">q_sig =  <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (high_sig, p_rnd);</div>
</div><!-- fragment --><p> Here we take advantage of <em>uncollected x-bits</em> in low_sig. Until we add the rmask and generate the carry, we can OR/ADD p_odd to any bit in low_sig except the Guard or Round bits. In this case we use the extend/carry form of add quadword to effect a 3 way add and generate the carry/round bit.</p>
<dl class="section note"><dt>Note</dt><dd>In the specific examples above the <b>and</b> with the <em>onemask</em> is not required before use as the VRC operand of <a class="el" href="vec__int128__ppc_8h.html#af18b98d2d73f1afbc439e1407c78f305" title="Vector Add Extended &amp; write Carry Unsigned Quadword.">vec_addecuq()</a>. The instruction internally uses only bit[127] for the carry-in on the extended quadword add.</dd></dl>
<h4><a class="anchor" id="f128_softfloat_IRRN_0_2_2"></a>
Examples for Round toward Zero</h4>
<p>Example for Convert Quadword to Quad-precision: </p><div class="fragment"><div class="line"><span class="comment">// Simplest case, shift right 15 bits</span></div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
</div><!-- fragment --><p> This code runs about 3 instructions.</p>
<h4><a class="anchor" id="f128_softfloat_IRRN_0_2_6"></a>
Examples for Round to Odd</h4>
<p>Example for Convert to Quad-precision. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> RXmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> ( 0, 0, 0, 0x7fff);</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_odd;</div>
<div class="line"><span class="comment">// For &quot;Round to Odd&quot;.</span></div>
<div class="line"><span class="comment">// If if G=1, or R=1, or X=1, Set least significant bit to 1.</span></div>
<div class="line"><span class="comment">// Isolate GRX bit then add the mask.</span></div>
<div class="line">q_odd = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_siq, RXmask);</div>
<div class="line"><span class="comment">// The add will generate a carry into bit 112, for non-zero GRX</span></div>
<div class="line">q_odd = vec_add (q_odd, RXmask);</div>
<div class="line"><span class="comment">// Or this into bit 112 of the q_sig.</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_odd);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
</div><!-- fragment --><p> This code runs about 6 instructions to load the mask and round=odd.</p>
<p>Example for Add/Subtract Quad-precision: </p><div class="fragment"><div class="line"><span class="comment">// Round to odd from low order GRX-bits</span></div>
<div class="line">p_tmp = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (s_sig, 125);</div>
<div class="line">p_odd = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (p_tmp, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_ones);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (s_sig, 3);</div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_odd);</div>
</div><!-- fragment --><p>Examples for Multiply Quad-precision. For this case we can manipulate low_sig to generate a carry for rounding up/down/odd and then add/subtract/or this carry to high_sig to produce the rounded product significand. For example round-to-odd: </p><div class="fragment"><div class="line"><span class="comment">// Round to odd from low_sig bits</span></div>
<div class="line">p_odd = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (low_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_ones);</div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>)  vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) high_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_odd);</div>
</div><!-- fragment --><h2><a class="anchor" id="f128_softfloat_0_0_1"></a>
Quad-Precision compares for POWER8</h2>
<p>IEEE floating-point compare is a bit more complicated than binary integer compare operations. The two main complications are; Not-a-Number (NaN) which IEEE insists are <em>unordered</em>, and signed 0.0 where IEEE insists that -0.0 is equal to +0.0. If you ignore the NaN and signed 0.0 cases you can treat floating-point values as signed magnitude binary integers, and use integer compares and boolean logic. Which looks like this:</p>
<ul>
<li>a =<sup>f</sup> b == (a =<sup>s</sup> b)</li>
<li>a &lt;<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;<sup>s</sup> b) | (a &lt;<sup>s</sup> 0 &amp; a &gt;<sup>u</sup> b)</li>
<li>a &lt;=<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;=<sup>s</sup> b) | (a &lt;<sup>s</sup> 0 &amp; a &gt;=<sup>u</sup> b)</li>
</ul>
<p>Where; =<sup>f</sup>, &lt;<sup>f</sup>, and &lt;=<sup>f</sup> are the desired floating-point compares, =<sup>s</sup>, &lt;<sup>s</sup>, &lt;=<sup>s</sup>, &gt;<sup>s</sup> and &gt;=<sup>s</sup>, are signed integer compares, and =<sup>u</sup>, &gt;<sup>u</sup>, and &gt;=<sup>u</sup> are unsigned integer compares.</p>
<dl class="section see"><dt>See also</dt><dd>"Hacker's Delight, 2nd Edition," Henry S. Warren, Jr, Addison Wesley, 2013. Chapter 17, Floating-point, Section 17-3 Comparing Floating-Point Numbers Using Integer Operations.</dd></dl>
<p>One key implication of this is that we will need signed and unsigned 128-bit compare operations. Instructions for 128-bit integer compares was added for PowerISA 3.1 (POWER10) but we also need to support POWER8/9. The good news is that PowerISA 2.07B (POWER8) includes Vector Add/Subtract Modulo/Carry/Extend Quadword instructions. Specifically Vector Subtract &amp; write Carry Unsigned Quadword can implement all the unsigned ordered (&lt;. &lt;=, &gt;, &gt;=) compares by manipulating the comparand order and evaluating the carry for 0 or 1.</p>
<p>POWER8 also includes vector doubleword integer compare instructions. And the Vector Compare Equal To Unsigned Doubleword instruction can be used with a few additional logical operations to implement 128-bit equal and not equal operations. These operations are already provided by <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<p>Some additional observations:</p><ul>
<li>The unsigned compare equal can be used for unsigned or signed integers.</li>
<li>(a &gt;=<sup>s</sup> 0) == ~(a &lt;<sup>s</sup> 0).<ul>
<li>So we only need one compare boolean and the binary NOT.</li>
<li>((a &gt;=<sup>s</sup> 0) &amp; a &lt;<sup>s</sup> b) | (~(a &gt;=<sup>s</sup> 0) &amp; a &gt;<sup>u</sup> b).</li>
<li>Now this starts to look like a vector select operation.</li>
<li>(src1 &amp; ~mask) | (src2 &amp; mask)</li>
</ul>
</li>
<li>(a &gt;=<sup>s</sup> 0) is a special case that only depends on the sign-bit.<ul>
<li>A unsigned compare can be used with a slight change,</li>
<li>Propagating the sign-bit across the (quad)word generates the same boolean. This is the <a class="el" href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802" title="Vector Set Bool from Signed Quadword.">vec_setb_sq()</a> operation. The __float128 variant is <a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73" title="Vector Set Bool from Quadword Floating-point.">vec_setb_qp()</a></li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The examples that follow, use vector __int128 parameters instead of __binary128 to avoid the hassles of cast incompatibility between scalar __binary128's and vector types. The actual implementations use the xfer functions.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line">test_cmpltf128_v1c (<a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfa128, <a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfb128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> altb, agtb;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> signbool;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Replace (vfa &gt;= 0) with (vfa &lt; 0) == vec_setb_qp (vfa)</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> shift = vec_splat_u8 (7);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> splat = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfa128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  signbool = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (splat, shift);</div>
<div class="line"> </div>
<div class="line">  altb = <a class="code" href="vec__int128__ppc_8h.html#a82d83d78ff2330205a8d74741b34a1be">vec_cmpltsq</a> (vfa128, vfb128);</div>
<div class="line">  agtb = <a class="code" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfa128, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfb128);</div>
<div class="line">  result = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)altb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)agtb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)signbool);</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we can tackle the pesky signed 0.0 case. The simplest method is to add another term that test for either a or b is -0.0. This simplifies to just logical a OR b and unsigned compare to -0.0. Which looks like this:</p>
<ul>
<li>a =<sup>f</sup> b == (a =<sup>s</sup> b) | ((a | b) == 0x80000000...0)</li>
<li>a &lt;<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;<sup>s</sup> b) | ((a &lt;<sup>s</sup> 0 &amp; a &gt;<sup>u</sup> b) &amp; ((a | b) != 0x80000000...0))</li>
<li>a &lt;=<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;=<sup>s</sup> b) | ((a &lt;<sup>s</sup> 0 &amp; a &gt;=<sup>u</sup> b) | ((a | b) == 0x80000000...0))</li>
</ul>
<p>Again we can replace signed compares (a &gt;= 0) and (a &lt; 0) with a single <a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73" title="Vector Set Bool from Quadword Floating-point.">vec_setb_qp()</a> and simplify the boolean logic by using vec_sel(). For the ((a | b) != 0x80000000...0) term we can save an instruction by replacing <a class="el" href="vec__int128__ppc_8h.html#a186d0b94bbc652e700ab4e1733b9524c" title="Vector Compare Not Equal Unsigned Quadword.">vec_cmpneuq()</a> with <a class="el" href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0" title="Vector Compare Equal Unsigned Quadword.">vec_cmpequq()</a> and replacing the AND operation with AND compliment. </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line">test_cmpltf128_v2c (<a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfa128, <a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfb128)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x80000000, 0, 0, 0);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> altb, agtb, nesm;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> or_ab;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> signbool;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Replace (vfa &gt;= 0) with (vfa &lt; 0) == vec_setb_qp (vfa)</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> shift = vec_splat_u8 (7);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> splat = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfa128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  signbool = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (splat, shift);</div>
<div class="line"> </div>
<div class="line">  altb = <a class="code" href="vec__int128__ppc_8h.html#a82d83d78ff2330205a8d74741b34a1be">vec_cmpltsq</a> (vfa128, vfb128);</div>
<div class="line">  agtb = <a class="code" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfa128, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfb128);</div>
<div class="line"> </div>
<div class="line">  or_ab = vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfa128, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfb128 );</div>
<div class="line">  <span class="comment">// For ne compare eq and and compliment</span></div>
<div class="line">  nesm = <a class="code" href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0">vec_cmpequq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) or_ab, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) signmask);</div>
<div class="line">  agtb = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_andc ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) agtb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) nesm);</div>
<div class="line">  <span class="comment">// select altb for 0&#39;s and agtb for 1&#39;s</span></div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)altb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)agtb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)signbool);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This sequence runs 27 instructions when you include the constant loads.</p>
<p>An alternative compare method converts both floating-point values in a way that a single (unsigned) integer compare can be used.</p>
<div class="fragment"><div class="line"><span class="comment">// for each comparand</span></div>
<div class="line"> <span class="keywordflow">if</span> (n &gt;= 0)</div>
<div class="line">   n = n + 0x80000000;</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">   n = -n;</div>
<div class="line"><span class="comment">// Use unsigned integer comparison</span></div>
</div><!-- fragment --><p> An interesting feature of this method is that +0.0 becomes (0x00000000 + 0x80000000 = 0x80000000) and -0.0 becomes (0x80000000 - 0x80000000 = 0x80000000) which effectively converts any -0.0 into +0.0 for comparison. Signed 0.0 solved.</p>
<p>Another optimization converts (n = n + 0x80000000) to (n = n XOR 0x80000000). Gives the same result and for POWER8 a vec_xor() is 2 cycles latency vs 4 cycles for _vec_adduqm().</p>
<div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line">test_cmpltf128_v3d (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vfa128, <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vfb128)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x80000000, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> shift = vec_splat_u8 (7);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> result;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> age0, bge0;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vra, vrap, vran;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vrb, vrbp, vrbn;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> splta, spltb;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// signbool = vec_setb_qp;</span></div>
<div class="line">  splta = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfa128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  age0 = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (splta, shift);</div>
<div class="line"> </div>
<div class="line">  vrap = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_xor ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfa128, signmask);</div>
<div class="line">  vran = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) zero, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfa128);</div>
<div class="line">  vra  = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrap, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vran, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)age0);</div>
<div class="line"> </div>
<div class="line">  spltb = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfb128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  bge0 = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (spltb, shift);</div>
<div class="line"> </div>
<div class="line">  vrbp = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_xor ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfb128, signmask);</div>
<div class="line">  vrbn = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) zero, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfb128);</div>
<div class="line">  vrb  = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrbp, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrbn, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)bge0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int128__ppc_8h.html#a7f9ebc5ad32b151a3e08136d51aad4dc">vec_cmpltuq</a> (vra, vrb);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This sequence runs (approximately) 20 instructions when you include loading the required constants. It also manages to use only splat-immediate forms to load constants and so does not need to establish the TOC pointer nor any address calculations to access constants via load instructions.</p>
<p>The next IEEE issue is detecting NaNs and returning <em>unordered</em> status. Adding the following code to a compare operation insures that if either comparand is NaN; false (unordered) is returned for compares (eq, lt, gt).</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (vfa) || <a class="code" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (vfb))</div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_splat_u32 (0);</div>
</div><!-- fragment --><p> The pair of <a class="el" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89" title="Return true if the __float128 value is Not a Number (NaN).">vec_all_isnanf128()</a> operations add significant overhead both in code size (39 instructions) and cycles. This form should only be used if is required for correct results and has not been tested by prior logic in this code path. </p><dl class="section see"><dt>See also</dt><dd>The combined operation <a class="el" href="vec__f128__ppc_8h.html#a2bee3fac5a163513bae170a54ac641ca" title="Return true if either __float128 value (vra, vrb) is NaN.">vec_all_isunorderedf128()</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>At this point we are not trying to comply with PowerISA by setting any FPSCR bits associated with Quad-Precision compare. If such is required, VXSNAN and/or VXVC can be set using the Move To FPSCR Bit 1 (mtfsb1) instruction.</dd></dl>
<h2><a class="anchor" id="f128_softfloat_0_0_2"></a>
Quad-Precision converts for POWER8</h2>
<p>IEEE floating-point conversions are also a bit complicated. Dealing with Not-a-Number (NaN), Infinities and subnormal is part of it. But the conversion may also require normalization and rounding depending on element size and types involved. Some examples:</p><ul>
<li>Double precision floats and long long integers can be represented exactly in Quad precision float. But:</li>
<li>Down conversions (to doubleword) from Quad-Precision may require rounding/truncation.<ul>
<li>Conversions to integer that overflow are given special values.</li>
</ul>
</li>
<li>Conversions between QP and quadword integer may also require rounding/truncation.<ul>
<li>128-bit integer values may not fit into the QPs 113-bit significand.</li>
</ul>
</li>
</ul>
<p>For PowerISA 3.0 (POWER9) includes full hardware instruction support for Quad-Precision, Including:</p><ul>
<li>Conversions between Quad-Precison and Double floating-point (xscvdpqp, xscvqpdp[o]).</li>
<li>Conversions between Quad-Precison and doubleword and word integer (xscvqpsdz, xscvqpswz, xscvqpudz, xscvqpuwz, xscvsdqp, xscvudqp).</li>
</ul>
<p>PowerISA 3.1 (POWER10) includes:</p><ul>
<li>Conversions between Quad-Precison and quadword integer (xscvqpsqz, xscvqpuqz, xscvsqqp, xscvuqqp).</li>
</ul>
<p>For POWER8 (and earlier) we need to do a little more work The general plan for conversion starts by disassembling the input value into its parts and analyze. For signed integer values disassemble usually means sign and unsigned magnitude. Analysis might be a range check or counting leading zeros. For floating point values this is usually sign, exponent, and significand. Analysis usually means determining the data class (NaN, infinity, normal, subnormal, zero) as each requires special handling in the conversion.</p>
<p>Conversion involves adjusting the <em>parts</em> as needed to match the type of the result. This is normally only adds and shifts. Finally we need to reassemble the parts based on the result type. For integers this normally just converting the unsigned magnitude to a signed '2's complement value based on the sign of the input. For floating-point this requires merging the sign bit with the (adjusted) significand and merging that with the (adjusted) exponent.</p>
<p>The good news is that all of the required operations are already available in <b>altivec.h</b> or PVECLIB.</p>
<h3><a class="anchor" id="f128_softfloat_0_0_2_0"></a>
Convert Double-Precision to Quad-Precision</h3>
<p>This is one of the simpler conversions as the conversion is always exact (no rounding/truncation is required, and no overflow is possible). The process starts with disassembling the double-precision value. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x80000000, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line">f64[<a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>] = 0.0; <span class="comment">// clear the right most element to zero.</span></div>
<div class="line"><span class="comment">// Extract the exponent, significand, and sign bit.</span></div>
<div class="line">d_exp = <a class="code" href="vec__f64__ppc_8h.html#acb534c11a544d9e0b61acdecbb62adaa">vec_xvxexpdp</a> (f64);</div>
<div class="line">d_sig = <a class="code" href="vec__f64__ppc_8h.html#af8b42004c11b01c7606d8d6e299e8107">vec_xvxsigdp</a> (f64);</div>
<div class="line">q_sign = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) f64, signmask);</div>
</div><!-- fragment --><p> We insure that the low-order doubleword of the vector f64 is zeroed. This is necessary for then we normalize the 128-bit significand for the quad-precision result. The operations <a class="el" href="vec__f64__ppc_8h.html#acb534c11a544d9e0b61acdecbb62adaa" title="Vector Extract Exponent Double-Precision.">vec_xvxexpdp()</a> and <a class="el" href="vec__f64__ppc_8h.html#af8b42004c11b01c7606d8d6e299e8107" title="Vector Extract Significand Double-Precision.">vec_xvxsigdp()</a> are provided by <a class="el" href="vec__f64__ppc_8h.html" title="Header package containing a collection of 128-bit SIMD operations over 64-bit double-precision floati...">vec_f64_ppc.h</a> supporting both the POWER9 instruction and equivalent implementation for POWER8. And finally we extract the sign-bit. We can't use the copysign() here due to the difference in type.</p>
<p>Now we analyze the data class of the double-precision input. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#a6bdfdf013a97ccd6dc20b1447f81d498">vec_all_isfinitef64</a> (f64))</div>
<div class="line">  { <span class="comment">// Not NaN or Inf</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#ab63ac21e968bf199eadd72f94b653905">vec_all_isnormalf64</a> (vec_splat (f64, <a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>)))</div>
<div class="line">      {</div>
<div class="line">      <span class="comment">// ... adjust exponent and expand significand</span></div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      { <span class="comment">// Must be zero or subnormal</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#a27becc842e7270c96c54a00d4a292d54">vec_all_iszerof64</a> (f64))</div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// ... copy zero exponent and significand</span></div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          { <span class="comment">// Must be subnormal</span></div>
<div class="line">            <span class="comment">// ... normalize signifcand for QP and adjust exponent</span></div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  { <span class="comment">// isinf or isnan.</span></div>
<div class="line">    <span class="comment">// ... set exponent to QP max and expand significand</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p> This code is arranged with an eye to the most common cases and specifics of the conversion required by each data class. The operations <a class="el" href="vec__f64__ppc_8h.html#a6bdfdf013a97ccd6dc20b1447f81d498" title="Return true if all 2x64-bit vector double values are Finite (Not NaN nor Inf).">vec_all_isfinitef64()</a>, <a class="el" href="vec__f64__ppc_8h.html#ab63ac21e968bf199eadd72f94b653905" title="Return true if all 2x64-bit vector double values are normal (Not NaN, Inf, denormal,...">vec_all_isnormalf64()</a> and <a class="el" href="vec__f64__ppc_8h.html#a27becc842e7270c96c54a00d4a292d54" title="Return true if all 2x64-bit vector double values are +-0.0.">vec_all_iszerof64()</a> are provided by <a class="el" href="vec__f64__ppc_8h.html" title="Header package containing a collection of 128-bit SIMD operations over 64-bit double-precision floati...">vec_f64_ppc.h</a> supporting both the POWER9 instruction and equivalent implementation for POWER8.</p>
<p>The normal case requires shifting the significand and adjusting the exponent. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_delta = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ( (0x3fff - 0x3ff), 0 );</div>
<div class="line">        ...</div>
<div class="line">        q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 4);</div>
<div class="line">        q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (d_exp, exp_delta);</div>
</div><!-- fragment --><p> The double significand has the fraction bits starting a bit-12 and the implied '1' in bit-11. For quad-precision we need to shift this right 4-bits to align the fraction to start in bit-16. We need a quadword shift as the significand will now extend into the high order bits of the second (low order) doubleword. To adjust the exponent we need to convert the double biased exponent (1 to 2046) into unbiased (-1022 to +1023) by subtracting the exponent bias (+1023 or 0x3ff) value. Then we can add the quad-precision exponent bias (+16383 or 0x3fff) to compute the final exponent. We can combine the bias difference into a single constant (0x3fff - 0x3ff) and only need a single add at runtime.</p>
<p>The operations <a class="el" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c" title="Vector Shift Right Quadword Immediate.">vec_srqi()</a> is provided by <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a> and <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo.">vec_addudm()</a> is provided by <a class="el" href="vec__int64__ppc_8h.html" title="Header package containing a collection of 128-bit SIMD operations over 64-bit integer elements.">vec_int64_ppc.h</a>. We use PVECLIB operations here to insure that this code is safe to use with older compilers and pre-POWER8 processors.</p>
<p>The zero case requires setting the quad-precision significand and exponent to zero. </p><div class="fragment"><div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig;</div>
<div class="line">q_exp = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) d_exp;</div>
</div><!-- fragment --><p> We know that the double significand and exponent are zero, so just assign them to the quad-precision parts. The sign bit will applied later with the common insert exponent code.</p>
<p>The subnormal case is a bit more complicated. The tricky part is while the double-precision value is subnormal the equivalent quad-precision value is not. So we need to normalize the significand and compute a new exponent. </p><div class="fragment"><div class="line"><span class="comment">// Need to adjust the quad exponent by the f64 denormal exponent</span></div>
<div class="line"><span class="comment">// (-1023) knowing that the f64 sig will have at least 12 leading &#39;0&#39;s</span></div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_denorm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ( (16383 - (1023 -12)), 0 );</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> f64_clz;</div>
<div class="line">f64_clz = <a class="code" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a> (d_sig);</div>
<div class="line">d_sig = <a class="code" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a> (d_sig, f64_clz);</div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_denorm, f64_clz);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 15);</div>
</div><!-- fragment --><p> We use a doubleword count leading zeros (ctz) and shift left to normalize the significand so that the first '1'-bit moves to bit-0. Then we compute the quad-precision exponent by subtracting the ctz value from a constant (16383 - (1023 -12)). This represents the quad-precision exponent bias, minus the double-precsion exponent bias, minus the minimum leading zero count for the double-precision subnormal significand.</p>
<p>The NaN/Infinity case requires shifting the significand and setting the exponent to quad-precision max. </p><div class="fragment"><div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 4);</div>
<div class="line">q_exp = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> (0x7fff, 0);</div>
</div><!-- fragment --><p> We need this shift as NaN has a non-zero significand and it might be nonzero in one of the low order bits. Separating out the infinity case (where the significand is zero) is not worth the extra (isnan) test to avoid the shift.</p>
<p>Now that all the parts are converted to quad-precision, we are ready to reassemble the QP result. </p><div class="fragment"><div class="line"><span class="comment">// Copy Sign-bit to QP significand before insert.</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_sign);</div>
<div class="line"><span class="comment">// Insert exponent into significand to complete conversion to QP</span></div>
<div class="line">result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
</div><!-- fragment --><p>Putting this all together we get something like: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d_exp, d_sig, q_exp;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_sign;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_delta = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ( (0x3fff - 0x3ff), 0 );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x80000000, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line">f64[<a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>] = 0.0; <span class="comment">// clear the right most element to zero.</span></div>
<div class="line"><span class="comment">// Extract the exponent, significand, and sign bit.</span></div>
<div class="line">d_exp = <a class="code" href="vec__f64__ppc_8h.html#acb534c11a544d9e0b61acdecbb62adaa">vec_xvxexpdp</a> (f64);</div>
<div class="line">d_sig = <a class="code" href="vec__f64__ppc_8h.html#af8b42004c11b01c7606d8d6e299e8107">vec_xvxsigdp</a> (f64);</div>
<div class="line">q_sign = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) f64, signmask);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#a6bdfdf013a97ccd6dc20b1447f81d498">vec_all_isfinitef64</a> (f64))</div>
<div class="line">  { <span class="comment">// Not NaN or Inf</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#ab63ac21e968bf199eadd72f94b653905">vec_all_isnormalf64</a> (vec_splat (f64, <a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>)))</div>
<div class="line">      {</div>
<div class="line">        q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 4);</div>
<div class="line">        q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (d_exp, exp_delta);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      { <span class="comment">// zero or subnormal</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#a27becc842e7270c96c54a00d4a292d54">vec_all_iszerof64</a> (f64))</div>
<div class="line">          {</div>
<div class="line">            q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig;</div>
<div class="line">            q_exp = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) d_exp;</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          { <span class="comment">// Must be subnormal</span></div>
<div class="line">            <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_denorm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ( (0x3fff - 1023 -12), 0 );</div>
<div class="line">            <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> f64_clz;</div>
<div class="line">            f64_clz = <a class="code" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a> (d_sig);</div>
<div class="line">            d_sig = <a class="code" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a> (d_sig, f64_clz);</div>
<div class="line">            q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_denorm, f64_clz);</div>
<div class="line">            q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 15);</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  { <span class="comment">// isinf or isnan.</span></div>
<div class="line">    q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 4);</div>
<div class="line">    q_exp = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> (0x7fff, 0);</div>
<div class="line">  }</div>
<div class="line"><span class="comment">// Copy Sign-bit to QP significand before insert.</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_sign);</div>
<div class="line"><span class="comment">// Insert exponent into significand to complete conversion to QP</span></div>
<div class="line">result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
</div><!-- fragment --><p>At this stage we have a functionally correct implementation and now we can look for opportunities for optimization. One issue is the generated code is fairly large (~436 bytes and ~100 instructions). For POWER8 the data class predicates (vec_all_isfinitef64, etc) each require one or more vector constant loads and bit mask operations before the associated vector compares. Also the extract significand operation requires the equivalent of isnormal (with two vector compares) as preparation for conditionally restoring the implied (hidden) bit.</p>
<p>By testing the extracted (exponent and significand) parts directly we can simplify the compare logic and eliminate some (redundant) vector constant loads. For example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d_naninf = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ( 0x7ff, 0 );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d_denorm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ( 0, 0 );</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// The extract sig operation has already tested for finite/subnormal.</span></div>
<div class="line"><span class="comment">// So avoid testing isfinite/issubnormal again by simply testing</span></div>
<div class="line"><span class="comment">// the extracted exponent.</span></div>
<div class="line"><span class="keywordflow">if</span> (__builtin_expect (!<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (d_exp, d_naninf), 1))</div>
<div class="line">  { <span class="comment">// Not Nan or Inf</span></div>
<div class="line">    <span class="keywordflow">if</span> (__builtin_expect (!<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (d_exp, d_denorm), 1))</div>
<div class="line">      {</div>
<div class="line">      <span class="comment">// ... adjust exponent and expand significand</span></div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      { <span class="comment">// Must be zero or subnormal</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (d_sig, d_denorm))</div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// ... copy zero exponent and significand</span></div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          { <span class="comment">// Must be subnormal</span></div>
<div class="line">            <span class="comment">// ... normalize signifcand for QP and adjust exponent</span></div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  { <span class="comment">// isinf or isnan.</span></div>
<div class="line">    <span class="comment">// ... set exponent to QP max and expand significand</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p> The implementation based on this logic is smaller (~300 bytes and ~75 instructions). Performance results TBD.</p>
<h3><a class="anchor" id="f128_softfloat_0_0_2_1"></a>
Convert Doubleword integer to Quad-Precision</h3>
<p>Converting binary integers to floating point is simpler as there are fewer data classes to deal with. Basically zero and non-zero numbers (no signed 0s, infinities or NaNs). Also the conversion from 64-bit integers to 128-bit floating-point is always exact (there is no rounding).</p>
<p>Unsigned doubleword is the simplest case. We only need to test for binary zero. If zero just return a QP +0.0 constant. Otherwise we can treat the binary magnitude as a denormalized number and normalize it. The binary zero test and processing looks like this: </p><div class="fragment"><div class="line">int64[<a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>] = 0UL; <span class="comment">// clear the right most element to zero.</span></div>
<div class="line"><span class="comment">// Quick test for 0UL as this case requires a special exponent.</span></div>
<div class="line">d_sig = int64;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (int64, d_zero))</div>
<div class="line">  { <span class="comment">// Zero sign, exponent and significand.</span></div>
<div class="line">    result = <a class="code" href="vec__f128__ppc_8h.html#ae8002c29875a226d11ec57a42b5b3955">vec_xfer_vui64t_2_bin128</a> (d_zero);</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span> ...</div>
</div><!-- fragment --><p> For the non-zero case we assume the binary point follows the unit bit (bit-63) of the 64-bit magnitude. Then we use count leading zeros to find the first significant bit. This count is used to normalize/shift (left justify) the magnitude and adjust the QP exponent to reflect the binary point following the unit (original doubleword bit 63) bit. So far we are using only doubleword data and instructions. </p><div class="fragment"><div class="line">{ <span class="comment">// We need to produce a normalized QP, so we treat the integer</span></div>
<div class="line">  <span class="comment">// like a denormal, then normalize it.</span></div>
<div class="line">  <span class="comment">// Start with the quad exponent bias + 63 then subtract the count of</span></div>
<div class="line">  <span class="comment">// leading &#39;0&#39;s. The 64-bit sig can have 0-63 leading &#39;0&#39;s.</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_expm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ((0x3fff + 63), 0 );</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> i64_clz = <a class="code" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a> (int64);</div>
<div class="line">  d_sig = <a class="code" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a> (int64, i64_clz);</div>
<div class="line">  q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_expm, i64_clz);</div>
<div class="line">  q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 15);</div>
<div class="line">  result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
<div class="line">}</div>
</div><!-- fragment --><p> The high order bit (after normalization) will become the <em>implicit</em> (hidden) bit in QP format. So we shift the quadword right 15-bits to become the QP significand. This shift includes the low order 64-bits we zeroed out early on and zeros out the sign-bit as a bonus. Finally we use <a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b" title="Scalar Insert Exponent Quad-Precision.">vec_xsiexpqp()</a> to merge the adjusted exponent and significand.</p>
<p>The signed doubleword conversion is bit more complicated. We deal with zero case in the same way. Otherwise we need to separate the signed doubleword into a sign-bit and unsigned 64-bit magnitude. Which looks something like this: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d_zero = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ( 0, 0 );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x80000000, 0, 0, 0);</div>
<div class="line">...</div>
<div class="line">    <span class="comment">// Convert 2s complement to signed magnitude form.</span></div>
<div class="line">    q_sign = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) int64, signmask);</div>
<div class="line">    d_neg  = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (d_zero, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>)int64);</div>
<div class="line">    d_sign = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int64__ppc_8h.html#a560aef2acfdf1db1cf14848ec6cb0c1c">vec_cmpequd</a> ((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) q_sign, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) signmask);</div>
<div class="line">    <span class="comment">// Select the original int64 if positive otherwise the negated value.</span></div>
<div class="line">    d_sig = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) int64, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) d_neg, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) d_sign);</div>
</div><!-- fragment --><p> The normalization process is basically the same as unsigned but we merge the sign-bit into the significant before inserting the exponent. </p><div class="fragment"><div class="line"><span class="comment">// Count leading zeros and normalize.</span></div>
<div class="line">i64_clz = <a class="code" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a> (d_sig);</div>
<div class="line">d_sig = <a class="code" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a> (d_sig, i64_clz);</div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_expm, i64_clz);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 15);</div>
<div class="line"><span class="comment">// Copy Sign-bit to QP significand before insert.</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_sign);</div>
<div class="line"><span class="comment">// Insert exponent into significand to complete conversion to QP</span></div>
<div class="line">result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
</div><!-- fragment --><h3><a class="anchor" id="f128_softfloat_0_0_2_2"></a>
Convert Quad-Precision to Quadword integer</h3>
<p>Convertions between quad-precision and quadword integers is complicated by the fact that the QP significand is only 113-bits while the quadword integer magnitude can be 127/128 bits. It may not be possible to represent the quadword magnitude exactly. Conversions from quad-precision float to integer may have nonzero fractions which require rounding/truncation.</p>
<p>For POWER9 we have the <b>VSX Scalar Convert with round to zero Quad-Precision to Signed/Unsigned Doubleword <em>(xscvqpsdz/xscvqpudz)</em></b> instructions. For POWER10 we have the <b>VSX Scalar Convert with round to zero Quad-Precision to Signed/Unsigned Quadword <em>(xscvqpsqz/xscvqpuqz)</em></b> instructions. Conversion using other rounding modes require using <b>VSX Scalar Round to Quad-Precision Integer <em>(xsrqpi)</em></b> instruction.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>xsrqpi</em> instruction allows for overriding the rounding mode as an immediate operand. So a two instruction sequence can implement any of the four <b>FPSCR<sub>RN</sub></b> rounding modes plus the fifth (Round to Nearest Away) mode specific to floating point integer instructions.</dd></dl>
<p>For this example we will look at Convert with Round to Zero Quad-Precision to Unsigned Quadword. The POWER10 operation can be implemented as a single xscvqpuqz instruction. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a></div>
<div class="line"><a class="code" href="vec__f128__ppc_8h.html#aaf9d4ad5a60e9ffaa0ca16d29f90c092">vec_xscvqpuqz</a> (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR10)  &amp;&amp; (__GNUC__ &gt;= 10)</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xscvqpuqz %0,%1&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (f128)</div>
<div class="line">      : );</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">...</div>
<div class="line">#endif</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> We use in-line assembler here as there are no current or planed compiler intrinsics for this and the C language only supports conversions between __float128 and __int128 scalars. The scalar conversions returns the __int128 result in GPR pair, while we need the result in vector register.</p>
<dl class="section note"><dt>Note</dt><dd>We could try to implement the POWER9 convert to quadword operation using two xscvqpudz instructions (at 12-cycles each). But this also requires two QP-multiplies (at 24-cycles each), plus xscvudqp/xssubqp (at 12-cycles each). So far it looks like using the POWER8 implementation for POWER9 will actually perform better.</dd></dl>
<p>The POWER8 implementation looks like this: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_exp, q_delta, x_exp;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> b_sign;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_zero = { 0 };</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_ones = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_splat_s32 (-1);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_low = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ( 0x3fff, 0x3fff );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_high = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ( (0x3fff+128), (0x3fff+128) );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_127 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ( (0x3fff+127), (0x3fff+127) );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_naninf = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> ( 0x7fff, 0x7fff );</div>
<div class="line"> </div>
<div class="line">result = q_zero;</div>
<div class="line">q_exp = <a class="code" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (f128);</div>
<div class="line">q_sig = <a class="code" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">vec_xsxsigqp</a> (f128);</div>
<div class="line">x_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> (q_exp, <a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>);</div>
<div class="line">b_sign = <a class="code" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73">vec_setb_qp</a> (f128);</div>
<div class="line"><span class="keywordflow">if</span> (__builtin_expect (!<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (x_exp, q_naninf), 1))</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a6264e6ca42126726b0e490754dde0db7">vec_cmpud_all_ge</a> (x_exp, exp_low)</div>
<div class="line">     &amp;&amp; <a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> ((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>)b_sign, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>)q_zero))</div>
<div class="line">      { <span class="comment">// Greater than or equal to 1.0</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a> (x_exp, exp_high))</div>
<div class="line">          { <span class="comment">// Less than 2**128-1</span></div>
<div class="line">            q_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (q_sig, 15);</div>
<div class="line">            q_delta = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (exp_127, x_exp);</div>
<div class="line">            result = <a class="code" href="vec__int128__ppc_8h.html#a0edd172a5656b842d6586c5078284942">vec_srq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_delta);</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          { <span class="comment">// set result to 2**128-1</span></div>
<div class="line">            result = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_ones;</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      { <span class="comment">// less than 1.0 or negative</span></div>
<div class="line">        result = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  { <span class="comment">// isinf or isnan.</span></div>
<div class="line">    <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> is_inf;</div>
<div class="line">    <span class="comment">// Positive Inf returns all ones</span></div>
<div class="line">    <span class="comment">// else NaN or -Infinity returns zero</span></div>
<div class="line">    is_inf = <a class="code" href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0">vec_cmpequq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero);</div>
<div class="line">    <span class="comment">// result = ~NaN | (pos &amp; Inf) -&gt; Inf &amp; (pos &amp; Inf) -&gt; pos &amp; Inf</span></div>
<div class="line">    result = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_andc ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) is_inf, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) b_sign);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> As is the usual for floating-point conversions, we extract the sign, significand, and exponent then test for class and range. We compare the extracted exponent directly using vector doubleword compares. These are faster (on POWER8) than quadword compares but require doubleword splatting the QP exponent and compare constants for correct results. This only requires one additional instruction (xxpermdi) as the vector constants will be loaded as quadwords either way.</p>
<p>The outer test is for NaN/Infinity. These should be rare so we use __builtin_expect(). The implementation returns special values to match the instruction definition.</p>
<p>Once we know the value is finite, we check for greater than or equal to +1.0. Negative or fractional values return quadword zero. Then we check for less than 2<sup>128</sup>. If not we return all ones (2<sup>128</sup> -1).</p>
<p>If the input is in the valid range for unsigned quadword we left-justify the significand then shift the quadword right by (127 - <sub>unbiased</sub>exp). The right shift truncates (round toward zero) any fractional bits. See <a class="el" href="vec__f128__ppc_8h.html#aaf9d4ad5a60e9ffaa0ca16d29f90c092" title="VSX Scalar Convert with round to zero Quad-Precision to Unsigned Quadword.">vec_xscvqpuqz()</a>.</p>
<p>The signed operation follows similar logic with appropriate adjustments for negative values and reduced magnitude range. The doubleword versions of the convert operation follows the same outline with different range constants. See vec_xscvqpsqz(), <a class="el" href="vec__f128__ppc_8h.html#a73ad56c509ea22f26fb2d47217bc5e51" title="VSX Scalar Convert with round to zero Quad-Precision to Unsigned doubleword.">vec_xscvqpudz()</a> and vec_xscvqpsdz().</p>
<h3><a class="anchor" id="f128_softfloat_0_0_2_3"></a>
Convert Quadword integer to Quad-Precision</h3>
<p>Conversions from doubleword integer to quad-precision float can be represented exactly and do not require any rounding. But conversions from quadword integer to quad-precision float may overflow the 113-bit significand which does require rounding.</p>
<p>For POWER9 we have the <b>VSX Scalar Convert Signed/Unsigned Doubleword to Quad-Precision format <em>(xscvsdqp/xscvudqp)</em></b> instructions. For POWER10 we have the <b>VSX Scalar Convert with Round Signed/Unsigned Quadword to Quad-Precision format <em>(xscvsqqp/xscvuqqp)</em></b> instructions. One of four rounding modes is selected from the 2-bit <b>FPSCR.<sub>RN</sub></b> field. The default rounding mode is <em>Round to Nearest Even</em> which we will use in this example. Convert using other rounding modes by changing the <b>FPSCR.<sub>RN</sub></b> field.</p>
<p>For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8">vec_xscvuqqp</a> (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> int128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR10)  &amp;&amp; (__GNUC__ &gt;= 10)</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xscvuqqp %0,%1&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (int128)</div>
<div class="line">      : );</div>
<div class="line"><span class="preprocessor">#elif defined (_ARCH_PWR9) &amp;&amp; defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> int64 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) int128;</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> hi64, lo64;</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> two64 = 0x1.0p64;</div>
<div class="line">  hi64 = int64[<a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>];</div>
<div class="line">  lo64 = int64[<a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>];</div>
<div class="line">  result = (hi64 * two64) + lo64;</div>
<div class="line"><span class="preprocessor">#elif  defined (_ARCH_PWR8)</span></div>
<div class="line">...</div>
<div class="line">#endif</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The POWER10 implementation uses the <b>xscvuqqp</b> instruction. While POWER9 implementation uses <b>xscvudqp</b> instructions to convert the high/low 64-bit halves of the quadword integer. To complete the conversion we need to multiply the converted high 64-bits by 2**64 than add the lower converted 64-bits. The compiler should generate something like this: </p><div class="fragment"><div class="line">&lt;test_vec_xscvuqqp_PWR9&gt;:</div>
<div class="line">     addis   r9,r2,0 ## R_PPC64_TOC16_HA   .rodata.<span class="stringliteral">&quot;0x1.0p64&quot;</span></div>
<div class="line">     addi    r9,r9,0 ## R_PPC64_TOC16_LO   .rodata.<span class="stringliteral">&quot;0x1.0p64&quot;</span></div>
<div class="line">     xxspltd v0,v2,1</div>
<div class="line">     xscvudqp v2,v2</div>
<div class="line">     xscvudqp v0,v0</div>
<div class="line">     lxv     v1,0(r9)</div>
<div class="line">     xsmaddqp v2,v0,v1</div>
<div class="line">     blr</div>
</div><!-- fragment --><p>The POWER8 implementation looks like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#elif  defined (_ARCH_PWR8)</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_exp;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_zero = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) { 0 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> lowmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> ( 0, 0, 0, 1);</div>
<div class="line"> </div>
<div class="line">  q_sig = int128;</div>
<div class="line">  <span class="comment">// Quick test for 0UL as this case requires a special exponent.</span></div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a> (q_sig, q_zero))</div>
<div class="line">    {</div>
<div class="line">      result = <a class="code" href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">vec_xfer_vui128t_2_bin128</a> (q_zero);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    { <span class="comment">// We need to produce a normal QP, so we treat the QW integer</span></div>
<div class="line">      <span class="comment">// like a denormal, then normalize it.</span></div>
<div class="line">      <span class="comment">// Start with the quad exponent bias + 127 then subtract the count of</span></div>
<div class="line">      <span class="comment">// leading &#39;0&#39;s. The 128-bit sig can have 0-127 leading &#39;0&#39;s.</span></div>
<div class="line">      <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_expm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> (0, (0x3fff + 127));</div>
<div class="line">      <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> i64_clz = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49">vec_clzq</a> (q_sig);</div>
<div class="line">      q_sig = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) i64_clz);</div>
<div class="line">      q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_expm, i64_clz);</div>
<div class="line">      <span class="comment">// This is the part that might require rounding.</span></div>
<div class="line">      <span class="comment">// For example Round to Zero</span></div>
<div class="line">      <span class="comment">// Shift right 15-bits to normalize and truncate</span></div>
<div class="line">      q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
<div class="line">      <span class="comment">//...</span></div>
<div class="line">      q_exp = <a class="code" href="vec__int64__ppc_8h.html#a42d2b39711c06106097ef869a20420b6">vec_swapd</a> (q_exp);</div>
<div class="line">      result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> In this example the significand (including the L-bit) is right justified in the high-order 113-bits of q_sig. The guard, round, and sticky (GRX) bits are in the low-order 15 bits. The sticky-bits are the last 13 bits and are logically ORed (or added to 0x1fff) to produce the X-bit.</p>
<p>The signed quadword conversion is bit more complicated for both POWER9/8. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__f128__ppc_8h.html#a27bfd64d7eefd8e84619950f19f827ba">vec_xscvsqqp</a> (<a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> int128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR10)  &amp;&amp; (__GNUC__ &gt;= 10)</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xscvsqqp %0,%1&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (int128)</div>
<div class="line">      : );</div>
<div class="line"><span class="preprocessor">#elif defined (_ARCH_PWR9) &amp;&amp; defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> hi64, lo64, i_sign;</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> two64 = 0x1.0p64;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_sign;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_neg;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> b_sign;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x80000000, 0, 0, 0);</div>
<div class="line">  <span class="comment">// Collect the sign bit of the input value.</span></div>
<div class="line">  q_sign = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) int128, signmask);</div>
<div class="line">  <span class="comment">// Convert 2s complement to unsigned magnitude form.</span></div>
<div class="line">  q_neg  = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__int128__ppc_8h.html#ac263f88b177c2f3db909ca92e41e3ff9">vec_negsq</a> (int128);</div>
<div class="line">  b_sign = <a class="code" href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802">vec_setb_sq</a> (int128);</div>
<div class="line">  q_sig = <a class="code" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) int128, q_neg, b_sign);</div>
<div class="line">  <span class="comment">// generate a signed 0.0 to use with vec_copysignf128</span></div>
<div class="line">  i_sign = <a class="code" href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a> (q_sign);</div>
<div class="line">  <span class="comment">// Convert the unsigned int128 magnitude to __binary128</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> int64 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) q_sig;</div>
<div class="line">  hi64 = int64[<a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>];</div>
<div class="line">  lo64 = int64[<a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>];</div>
<div class="line">  result = (hi64 * two64) + lo64;</div>
<div class="line">  <span class="comment">// copy the __int128&#39;s sign into the __binary128 result</span></div>
<div class="line">  result = <a class="code" href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e">vec_copysignf128</a> (i_sign, result);</div>
<div class="line"><span class="preprocessor">#elif  defined (_ARCH_PWR8)</span></div>
<div class="line">...</div>
<div class="line">#endif</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> For POWER9 we can not just use the signed doubleword conversions for this case. First we split the signed quadword into a 128-bit boolean (representing the sign) and an unsigned quadword magnitude. Then perform the unsigned conversion to QP format as for <a class="el" href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8" title="VSX Scalar Convert Unsigned-Quadword to Quad-Precision format.">vec_xscvuqqp()</a>, And finally use <a class="el" href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e" title="Copy the sign bit from f128x and merge with the magnitude from f128y. The merged result is returned a...">vec_copysignf128()</a> to insert the original sign into the QP result.</p>
<p>Similarly for POWER8:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#elif  defined (_ARCH_PWR8)</span></div>
<div class="line"> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_exp;</div>
<div class="line"> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig;</div>
<div class="line"> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_neg;</div>
<div class="line"> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_sign;</div>
<div class="line"> <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> b_sign;</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_zero = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) { 0 };</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> lowmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> ( 0, 0, 0, 1);</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x80000000, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Quick test for 0UL as this case requires a special exponent.</span></div>
<div class="line"> <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) int128, q_zero))</div>
<div class="line">   {</div>
<div class="line">     result = <a class="code" href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">vec_xfer_vui128t_2_bin128</a> (q_zero);</div>
<div class="line">   }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">   { <span class="comment">// We need to produce a normal QP, so we treat the integer like a</span></div>
<div class="line">     <span class="comment">// denormal, then normalize it.</span></div>
<div class="line">     <span class="comment">// Collect the sign bit of the input value.</span></div>
<div class="line">     q_sign = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) int128, signmask);</div>
<div class="line">     <span class="comment">// Convert 2s complement to signed magnitude form.</span></div>
<div class="line">     q_neg  = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__int128__ppc_8h.html#ac263f88b177c2f3db909ca92e41e3ff9">vec_negsq</a> (int128);</div>
<div class="line">     b_sign = <a class="code" href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802">vec_setb_sq</a> (int128);</div>
<div class="line">     q_sig = <a class="code" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) int128, q_neg, b_sign);</div>
<div class="line">     <span class="comment">// Start with the quad exponent bias + 127 then subtract the count of</span></div>
<div class="line">     <span class="comment">// leading &#39;0&#39;s. The 128-bit sig can have 0-127 leading &#39;0&#39;s.</span></div>
<div class="line">     <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_expm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a> (0, (0x3fff + 127));</div>
<div class="line">     <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> i64_clz = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49">vec_clzq</a> (q_sig);</div>
<div class="line">     q_sig = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) i64_clz);</div>
<div class="line">     q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_expm, i64_clz);</div>
<div class="line">     <span class="comment">// This is the part that might require rounding.</span></div>
<div class="line">     <span class="comment">// For example Round to Zero</span></div>
<div class="line">     <span class="comment">// Shift right 15-bits to normalize and truncate</span></div>
<div class="line">     q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
<div class="line"> </div>
<div class="line">     q_exp = <a class="code" href="vec__int64__ppc_8h.html#a42d2b39711c06106097ef869a20420b6">vec_swapd</a> (q_exp);</div>
<div class="line">     <span class="comment">// Copy Sign-bit to QP significand before insert.</span></div>
<div class="line">     q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_sign);</div>
<div class="line">     result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
<div class="line">   }</div>
</div><!-- fragment --><h3><a class="anchor" id="f128_softfloat_0_0_2_x"></a>
Convert Quad-Precision to Double-Precision</h3>
<p>TBD</p>
<h3><a class="anchor" id="f128_softfloat_0_0_2_y"></a>
Round to Quad-Precision Integer</h3>
<p>TBD</p>
<h2><a class="anchor" id="f128_softfloat_0_0_3"></a>
Quad-Precision Arithmetic</h2>
<p>The POWER9 (PowerISA 3.0B) processor provides a full set of Quad-Precision arithmetic operations; add, divide, multiply, multiply-add/sub, and subtract. The compilers (that support IEEE128) provide normal C-language arithmetic operators for the __float128 (ISO _Float128) data type. The compiler will generate in-line quad-precision instructions for the (-mcpu=power9) target and calls to the (soft-float) runtime for earlier processor targets.</p>
<p>POWER9 also provides a round-to-odd override for these operations. This helps software avoid <em>double rounding</em> errors when rounding to smaller precision. These are supported with compile built-ins (or in-line assembler).</p>
<p>The compilers (that support IEEE128) provide a soft-float implementation for POWER8. However the runtime does not support round-to-odd as a rounding mode. Also the compiler built-ins for round-to-odd arithmetic are disabled for POWER8 and earlier.</p>
<p>As a minimum the PVECLIB implementation should implement POWER8 equivalents to the compiler built-ins supported for ISA 3.0. This would include the explicit round-to-odd operations.</p>
<dl class="section note"><dt>Note</dt><dd>PVECLIB supports 128-bit and 64-bit vector integer operations for POWER7 but is limited by the original VMX integer word (32-bit) element instructions. This will not provide any performance advantage over a Fixed-Point 64-bit implementation using GPRs.</dd></dl>
<h3><a class="anchor" id="f128_softfloat_0_0_3_1"></a>
Multiply Quad-Precision with Round-to-Odd.</h3>
<p>The PVECLIB implementation of <b>Multiply Quad-Precision with Round-to-Odd</b> will use the POWER9 xsmulqpo instruction if the compile target supports it. Otherwise provide a POWER8 VSX implementation using operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a> and vec_int64_ppc. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line">test_mulqpo_PWR9 (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR9) &amp;&amp; (__GNUC__ &gt; 6)</span></div>
<div class="line"><span class="preprocessor">#if defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line">  <span class="comment">// Earlier GCC versions may not support this built-in.</span></div>
<div class="line">  result = __builtin_mulf128_round_to_odd (vfa, vfb);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// If the compiler supports _ARCH_PWR9, must support mnemonics.</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xsmulqpo %0,%1,%2&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (vfa), <span class="stringliteral">&quot;v&quot;</span> (vfb)</div>
<div class="line">      : );</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// Soft-float implementation</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> We prefer the compiler built-in (if available) but can substitute in-line assembler if needed. The built-in is subject to additional compiler optimizations (like instruction scheduling) while in-line assembler is not.</p>
<p>The PVECLIB soft-float implementation can leverage the 128-bit vector registers and operations supported by POWER8. The implementation starts with the usual exponent and significand extraction and ends with merging the computed sign-bit with the significand and inserting the computed exponent. For example:</p>
<div class="fragment"><div class="line">  <span class="comment">// Working variables and constants</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_exp, a_exp, b_exp, x_exp;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig, a_sig, b_sig, p_sig_h, p_sig_l, p_odd;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_sign,  a_sign,  b_sign;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_zero = { 0, 0 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_ones = { -1, -1 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_bias = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0x3fff, 0x3fff );</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> exp_min = (<a class="code" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 1, 1 );</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_dnrm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0, 0 );</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_naninf = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0x7fff, 0x7fff );</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_max = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0x7ffe, 0x7ffe );</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> sigov = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x0001ffff, -1, -1, -1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Extract the exponent, significand, and sign-bit of each operand</span></div>
<div class="line">  a_exp = <a class="code" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (vfa);</div>
<div class="line">  a_sig = <a class="code" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">vec_xsxsigqp</a> (vfa);</div>
<div class="line">  a_sign = <a class="code" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (vfa, signmask);</div>
<div class="line">  b_exp = <a class="code" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (vfb);</div>
<div class="line">  b_sig = <a class="code" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">vec_xsxsigqp</a> (vfb);</div>
<div class="line">  b_sign = <a class="code" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (vfb, signmask);</div>
<div class="line">  <span class="comment">// Vectorize the DW biased exponents</span></div>
<div class="line">  x_exp = <a class="code" href="vec__int64__ppc_8h.html#acd5bafec6c1c15b0336551e82d1169d4">vec_mrgahd</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) a_exp, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) b_exp);</div>
<div class="line">  <span class="comment">// Generate the product sign-bit</span></div>
<div class="line">  q_sign = vec_xor (a_sign, b_sign);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// test for (vec_all_isfinitef128 (vfa) &amp;&amp; vec_all_isfinitef128 (vfb))</span></div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a> (x_exp, exp_naninf))</div>
<div class="line">    { <span class="comment">// Both operands are finite (normal, denormal, or zero)</span></div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    { <span class="comment">// One or both operands are NaN or Infinity</span></div>
<div class="line">    }</div>
<div class="line">  <span class="comment">// Merge sign, significand, and exponent into final result</span></div>
<div class="line">  q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_sign);</div>
<div class="line">  result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
</div><!-- fragment --><p> Finite operands should be to the most common case. So it may help the compiler to use __builtin_expect(). For example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (__builtin_expect (<a class="code" href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a> (x_exp, exp_naninf), 1))</div>
<div class="line">  { <span class="comment">// Both operands are finite (normal, denormal, or zero)</span></div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  { <span class="comment">// One or both operands are NaN or Infinity</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p>For finite operands we need to multiply the significands, sum the (unbiased) exponents, normalize the product, round, and check for exponent under/overflow. We can use <a class="el" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8" title="Vector Multiply Unsigned Double Quadword.">vec_muludq()</a> to multiply two 128-bit unsigned values returning 256-bit product in two (high/low) 128-bit vectors.</p>
<p>The product of two 113-bit significands is up to up to 226-bits (depending on inputs). From this we only need 117-bits (C-bit, L-bit, 112 Fraction bits, G-bit, R-bit, and X (sticky) bit. The X-bit is the logical OR of all 110-bits to the right of the R-bit. But we should not discard (or collapse) any sticky bits until after normalization.</p>
<p>We have some latitude on how we represent this product in vector registers. It is convenient for rounding if the high order 114-bits (C, L, Fraction -bits) are right justified in the high vector. While the low order 112-bit are left justified in in the low vector. One way to accomplish this is: </p><div class="fragment"><div class="line">a_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (a_sig, 8);</div>
<div class="line">b_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (b_sig, 8);</div>
<div class="line">p_sig_l = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;p_sig_h, a_sig, b_sig);</div>
</div><!-- fragment --><p>There are some special considerations for denormal and zero (+- 0.0) operands. Both have a biased exponent of 0x0000 but we can't use that to compute the product exponent. If the either significand is zero then the product is zero. We can short circuit this by returning the product sign-bit (A<sup>sign</sup> XOR B<sup>sign</sup>) followed by 127 0b0s.</p>
<p>Otherwise a denormal is <em>encoded</em> as a biased exponent of 0x0000 and a nonzero (112-bit) fraction. But the architecture defines a denormal as 2<sup>Emin</sup> x (0.fraction). For Quad-Precision, Emin is defined as -16382 which is a biased exponent of 0x0001. So which value (0x0000 or 0x0001) is used to compute the product exponent for the intermediate result?</p>
<p>For denormal values we use Emin to compute the product exponent before normalization. This requires a small fix-up before computing the exponent. We can optimize things by nesting the denormal fix-up under the zero check. </p><div class="fragment"><div class="line">      <span class="comment">// Splat exponents to both DWs</span></div>
<div class="line">      a_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> (a_exp, <a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>);</div>
<div class="line">      b_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> (b_exp, <a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>);</div>
<div class="line">      <span class="comment">// x_exp is the vectorized DW a_exp/b_exp</span></div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a440a601539df9f00dfe3669b06ea5766">vec_cmpud_any_eq</a> (x_exp, exp_dnrm))</div>
<div class="line">        { <span class="comment">// Involves zeros or denormals</span></div>
<div class="line">          <span class="comment">// check for zero significands in multiply</span></div>
<div class="line">          <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a> (a_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero)</div>
<div class="line">              || <a class="code" href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a> (b_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero))</div>
<div class="line">            { <span class="comment">// Multiply by zero, return QP signed zero</span></div>
<div class="line">              result = <a class="code" href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a> (q_sign);</div>
<div class="line">              <span class="keywordflow">return</span> result;</div>
<div class="line">            }</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            { <span class="comment">// Denormals present</span></div>
<div class="line">              <a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> exp_mask;</div>
<div class="line">              <span class="comment">// Convert zero encode to Emin for any denormal</span></div>
<div class="line">              exp_mask = <a class="code" href="vec__int64__ppc_8h.html#a560aef2acfdf1db1cf14848ec6cb0c1c">vec_cmpequd</a> (x_exp, exp_dnrm);</div>
<div class="line">              x_exp = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) vec_sel (x_exp, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) exp_min, exp_mask);</div>
<div class="line">              <span class="comment">// Propagate Emin back to a_exp/b_exp</span></div>
<div class="line">              a_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> (x_exp, <a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>);</div>
<div class="line">              b_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> (x_exp, <a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line">      <span class="comment">// sum biased exponents for multiply</span></div>
<div class="line">      q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (a_exp, b_exp);</div>
<div class="line">      q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_exp, exp_bias);</div>
</div><!-- fragment --><p> The exponent vector are splatted to both doublewords. We need the exponent in the high order doubleword for input to <a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b" title="Scalar Insert Exponent Quad-Precision.">vec_xsiexpqp()</a>. We need the exponent in the low order doubleword for computing shift amounts as input to <a class="el" href="vec__int128__ppc_8h.html#a8ba40be93339359793ef776e1d5d7577" title="Vector Shift Left Double Quadword.">vec_sldq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff" title="Vector Shift Left Quadword.">vec_slq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a0edd172a5656b842d6586c5078284942" title="Vector Shift Right Quadword.">vec_srq()</a>. Here we use biased exponents in the computation and result. The addition will double the bias so we need to correct it by subtracting the constant exp_bias.</p>
<p>Again the zero multiply case is rare, so we can help the compiler by using __builtin_expect(). Also we can replace the <b>else</b> block with boolean select logic set exponents to <b>Emin</b> for denormal operands. This also eliminates a redundant compare for <b>exp_dnrm</b>. </p><div class="fragment"><div class="line"><span class="comment">// check for zero significands in multiply</span></div>
<div class="line"><span class="keywordflow">if</span> (__builtin_expect (</div>
<div class="line">     (vec_all_eq ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) a_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_zero)</div>
<div class="line">   || vec_all_eq ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) b_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_zero)), 0))</div>
<div class="line">  { <span class="comment">// Multiply by zero, return QP signed zero</span></div>
<div class="line">    result = <a class="code" href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a> (q_sign);</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">  }</div>
<div class="line"><span class="comment">// Convert zero encode to Emin for any denormal</span></div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> exp_mask;</div>
<div class="line">  exp_mask = <a class="code" href="vec__int64__ppc_8h.html#a560aef2acfdf1db1cf14848ec6cb0c1c">vec_cmpequd</a> (x_exp, exp_dnrm);</div>
<div class="line">  x_exp = <a class="code" href="vec__int64__ppc_8h.html#a4390e79e503b741605914fe63d35c5bf">vec_selud</a> (x_exp, exp_min, (<a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>) exp_mask);</div>
<div class="line">  a_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> (x_exp, <a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>);</div>
<div class="line">  b_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> (x_exp, <a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// sum exponents</span></div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (a_exp, b_exp);</div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_exp, exp_bias);</div>
</div><!-- fragment --><p>The multiply may generate a carry in the intermediate result. This can occur when both operands are normal and sufficiently large. For example 1.5 x 1.5 = 2.25 (0x1.8 x 0x1.8 = 0x2.4). Any product with the C-bit set requires normalization by shifting one bit right and incrementing the exponent. For example: </p><div class="fragment"><div class="line"><span class="comment">// Check for carry and adjust</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#ac93dc5ed8bb3501470cf70c5cb5796a9">vec_cmpuq_all_gt</a> (p_sig_h, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) sigov))</div>
<div class="line">  {</div>
<div class="line">    p_tmp = <a class="code" href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a> (p_sig_h, p_sig_l, 120);</div>
<div class="line">    p_sig_h = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (p_sig_h, 1);</div>
<div class="line">    p_sig_l = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (p_tmp, 7);</div>
<div class="line">    q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (q_exp, q_one);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> The shift sequence above is optimized for the case of a 1 bit shift right double quadword for POWER8.</p>
<p>This case is not rare at all so __builtin_expect() is not helpful for this case. Also quadword compare is an expensive test and requires a load of the sigov constant value. We only need to compare the high order 16-bits of the significand to detect the Carry/Leading bits.</p>
<p>An alternative uses splat halfword to replicate the CL-bits across the vector and use splat immediate halfword for the compare value. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> carry_mask;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> sig_l_mask = vec_splat_u16 (1);</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> t_sig = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>) p_sig_h, <a class="code" href="vec__common__ppc_8h.html#a7a067a69e501014d68d003ac4e11d9fd">VEC_HW_H</a>);</div>
<div class="line"><span class="comment">// Detect Carry bit</span></div>
<div class="line">carry_mask =  (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_cmpgt (t_sig, sig_l_mask);</div>
</div><!-- fragment --><p> Then use boolean select logic to propagate the right shifted significand and incremented exponent if carry detected. For example: </p><div class="fragment"><div class="line"><span class="comment">// Shift double quadword right 1 bit</span></div>
<div class="line">p_tmp = <a class="code" href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a> (p_sig_h, p_sig_l, 120);</div>
<div class="line">sig_h = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (p_sig_h, 1);</div>
<div class="line">sig_l = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (p_tmp, 7);</div>
<div class="line"><span class="comment">// Increment the exponent</span></div>
<div class="line">x_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (q_exp, exp_one);</div>
<div class="line"><span class="comment">// Select original or normalized exp/sig</span></div>
<div class="line">p_sig_h = <a class="code" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a> (p_sig_h, sig_h, carry_mask);</div>
<div class="line">p_sig_l = <a class="code" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a> (p_sig_l, sig_l, carry_mask);</div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a4390e79e503b741605914fe63d35c5bf">vec_selud</a> (q_exp, x_exp, (<a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>) carry_mask);</div>
</div><!-- fragment --><p>Next we may need to deal with denormal results. A intermediate result is considered <em>tiny</em> if the exponent is less than Emin. If the result is still <em>tiny</em> after normalization and rounding the result is denormal and we can set the product exponent to 0x0000 before inserting it into the sign/significand for the final result.</p>
<p>The normalization of a <em>tiny</em> intermediate result is a little complicated. The PowerUSA states: </p><blockquote class="doxtable">
<p>If the intermediate result is Tiny (i.e., the unbiased exponent is less than -16382) and UE=0, the significand is shifted right N bits, where N is the difference between -16382 and the unbiased exponent of the intermediate result. The exponent of the intermediate result is set to the value -16382. </p>
</blockquote>
<p>This requires two tests. For example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a9ecd14e25b4de7ce7bb657e0e2f492bc">vec_cmpsd_all_lt</a> ((<a class="code" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>) q_exp, (<a class="code" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>) exp_min))</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Intermediate result is tiny, unbiased exponent &lt; -16382</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a2b7f505ebca731aa6fdc7433f82c0c6d">vec_cmpuq_all_le</a> (p_sig_h, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) sigovt))</div>
<div class="line">  { <span class="comment">// Not tiny but ...</span></div>
<div class="line">    <span class="comment">// Signicand is below normal range. This can happen when</span></div>
<div class="line">    <span class="comment">// multiplying a denormal by a normal.</span></div>
<div class="line">    <span class="comment">// So try to normalize the significand.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p> Again both cases are rare, so we can help the compiler by using __builtin_expect(). Also the second test is a quadword compare requiring another quadword constant. Both expensive compared the alternative.</p>
<p>We only need to compare the high order 16-bits of the significand to detect the a zero Leading bit. Again use splat halfword to replicate the CL-bits across the vector and compare to zero. For example: </p><div class="fragment"><div class="line"><span class="comment">// Isolate sig CL bits and compare</span></div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> t_sig = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>) p_sig_h, <a class="code" href="vec__common__ppc_8h.html#a7a067a69e501014d68d003ac4e11d9fd">VEC_HW_H</a>);</div>
<div class="line"><span class="keywordflow">if</span> (__builtin_expect ((vec_all_eq (t_sig, (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>) q_zero)), 0))</div>
</div><!-- fragment --><p>There are some issues that need to be addressed as we (attempt to) normalize tiny results. We need to assure as we shift bits right, any bits shifted out of the low order (112-bit) of the product, are (effectively) accumulated in the sticky-bit (X-bit). This is a consequence of deferred X-bit (accumulated) as we pass the whole 226-bit product (p_sig_h and p_sig_l) into the rounding step. This breaks down in to two cases:</p><ul>
<li>N is less than or equal to 116.</li>
<li>N is greater than 116.</li>
</ul>
<p>The first case may leave significant bits in the fraction and the GR-bits. But we must preserve any bits below GR in the sticky-bit. In this case we accumulate and clear the low-order 109-bits of the product and OR them into the X-bit. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> xmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x1fffffff, -1, -1, -1);</div>
<div class="line"><span class="comment">// Propagate low order bits into the sticky bit</span></div>
<div class="line"><span class="comment">// GRX is left adjusted in p_sig_l</span></div>
<div class="line"><span class="comment">// Isolate bits below GDX (bits 3-128).</span></div>
<div class="line">tmp = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_sig_l, xmask);</div>
<div class="line"><span class="comment">// generate a carry into bit-2 for any nonzero bits 3-127</span></div>
<div class="line">tmp = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) tmp, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) xmask);</div>
<div class="line"><span class="comment">// Or this with the X-bit to propagate any sticky bits into X</span></div>
<div class="line">p_sig_l = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_sig_l, tmp);</div>
<div class="line">p_sig_l = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_andc ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_sig_l, xmask);</div>
</div><!-- fragment --><p> Now we can perform a double quadword shift right of up to 116 bits without losing any bits from the intermediate representation. For example: </p><div class="fragment"><div class="line"><span class="comment">// Need a Double Quadword shift here, so convert right</span></div>
<div class="line"><span class="comment">// shift into shift left double quadword for p_sig_l.</span></div>
<div class="line">l_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (exp_128, x_exp);</div>
<div class="line">p_sig_l = <a class="code" href="vec__int128__ppc_8h.html#a8ba40be93339359793ef776e1d5d7577">vec_sldq</a> (p_sig_h, p_sig_l, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) l_exp);</div>
<div class="line"><span class="comment">// Complete right shift for p_sig_h</span></div>
<div class="line">p_sig_h = <a class="code" href="vec__int128__ppc_8h.html#a0edd172a5656b842d6586c5078284942">vec_srq</a> (p_sig_h, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) x_exp);</div>
<div class="line">q_sig = p_sig_h;</div>
</div><!-- fragment --><p>The second case implies that all bits of the intermediate representation (bits CL through GR) will be shifted away and can only be accumulated in the sticky (X) bit. </p><div class="fragment"><div class="line"><span class="comment">// Intermediate result is too tiny, the shift will</span></div>
<div class="line"><span class="comment">// zero the fraction and the GR-bit leaving only the</span></div>
<div class="line"><span class="comment">// Sticky bit. The X-bit needs to include all bits</span></div>
<div class="line"><span class="comment">// from p_sig_h and p_sig_l</span></div>
<div class="line">p_sig_l = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (p_sig_l, 8);</div>
<div class="line">p_sig_l = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_sig_l, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_sig_h);</div>
<div class="line"><span class="comment">// generate a carry into bit-2 for any nonzero bits 3-127</span></div>
<div class="line">p_sig_l = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (p_sig_l, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) xmask);</div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero;</div>
<div class="line">p_sig_l = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_andc ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_sig_l, xmask);</div>
</div><!-- fragment --><p>There is another special case where the product exponent is greater than or equal to <b>Emin</b> but the significand is not in normal range. Otherwise we can continue to the rounding process.</p>
<p>This case can happen if a normal value is multiplied by a denormal. The normalization process for this case is to: </p><blockquote class="doxtable">
<p>If the exponent is <b>Emin</b> then the result is denormal. Set the biased exponent to zero and continue to rounding.</p>
<p>Otherwise shift the significand left and decrement the exponent, until the exponent equals <b>Emin</b> or the significant is in normal range. </p>
</blockquote>
<p>For the second case we use count leading zeros to (<a class="el" href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49" title="Vector Count Leading Zeros Quadword for unsigned __int128 elements.">vec_clzq()</a>) to compute the number bits (<em>c_exp</em>) we need to shift left to get a normalized significand. We also compute the number of bits (<em>d_exp</em>) we need to decrement the exponent to <b>Emin</b>. Then we take the minimum (of <em>c_exp</em> and <em>d_exp</em>) as the shift count. For example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_15 = { 15, 15 };</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> c_exp, d_exp;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> c_sig;</div>
<div class="line">c_sig = <a class="code" href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49">vec_clzq</a> (p_sig_h);</div>
<div class="line">c_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> ((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) c_sig, <a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>);</div>
<div class="line"><span class="comment">// Adjust for leading bits before L-bit</span></div>
<div class="line">c_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (c_exp, exp_15);</div>
<div class="line">d_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_exp, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) exp_min);</div>
<div class="line">d_exp = <a class="code" href="vec__int64__ppc_8h.html#ad24220d787ac863b7911a303da17d1a0">vec_minud</a> (c_exp, d_exp);</div>
</div><!-- fragment --><p> We use the minimum value (<em>d_exp</em>) to shift the significand left. Then check if the result is still denormal. If so set the result biased exponent to zero. Otherwise compute the normalized exponent. </p><div class="fragment"><div class="line"><span class="comment">// Try to normalize the significand.</span></div>
<div class="line">p_sig_h = <a class="code" href="vec__int128__ppc_8h.html#a8ba40be93339359793ef776e1d5d7577">vec_sldq</a> (p_sig_h, p_sig_l, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_exp);</div>
<div class="line">p_sig_l = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (p_sig_l, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_exp);</div>
<div class="line"><span class="comment">// Compare computed exp to shift count to normalize.</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a871f91423e5154739ae225c82620d6b4">vec_cmpud_all_le</a> (q_exp, c_exp))</div>
<div class="line">  { <span class="comment">// exp less than shift count to normalize so</span></div>
<div class="line">    <span class="comment">// result is still denormal.</span></div>
<div class="line">    q_exp = q_zero;</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span> <span class="comment">// Adjust exp after normalize shift left.</span></div>
<div class="line">  q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_exp, d_exp);</div>
</div><!-- fragment --><p> Of course we can replace the exponent compare if-then-else with select logic. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> exp_mask;</div>
<div class="line">exp_mask = <a class="code" href="vec__int64__ppc_8h.html#aeb17e3bb401eff58cf827c9fc5f281bf">vec_cmpgtud</a> (q_exp, c_exp);</div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_exp, d_exp);</div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a4390e79e503b741605914fe63d35c5bf">vec_selud</a> (exp_dnrm, q_exp, exp_mask);</div>
</div><!-- fragment --><p>The round-to-odd case to has some special considerations.</p><ul>
<li>Round-to-odd will never generate a Carry, so we don't need to check.</li>
<li>Exponent overflow does not return infinity. Instead it returns <b>FLT128_MAX</b> of the appropriate sign.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Round to odd from lower product bits</span></div>
<div class="line">p_odd = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (p_sig_l, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_ones);</div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>)  vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_odd);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check for exponent overflow -&gt; __FLT128_MAX__</span></div>
<div class="line"><span class="keywordflow">if</span>  (<a class="code" href="vec__int64__ppc_8h.html#af13f19199e5872ecaf88742043f26642">vec_cmpud_all_gt</a> ( q_exp, exp_max))</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Intermediate result is huge, unbiased exponent &gt; 16383</span></div>
<div class="line">  <span class="comment">// so return __FLT128_MAX__</span></div>
<div class="line">  q_exp = exp_max;</div>
<div class="line">  q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) sigov;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Round-to-odd is a simple operation. We already have the significand in a separate vector register from the GRX-bits. So we use <a class="el" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3" title="Vector Add &amp; write Carry Unsigned Quadword.">vec_addcuq()</a> to generate a carry-bit if there are any non-zero bits in the extended fraction. This carry bit is simply ORed into the low order bit of the significand.</p>
<p>Returning <b>FLT128_MAX</b> for exponent overfloat is special case for round-to-odd. Other rounding modes would return infinity. Again this is a rare case and we can help the compiler by using __builtin_expect(). For example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (__builtin_expect ((<a class="code" href="vec__int64__ppc_8h.html#af13f19199e5872ecaf88742043f26642">vec_cmpud_all_gt</a> ( q_exp, exp_max)), 0))</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Intermediate result is huge, unbiased exponent &gt; 16383</span></div>
<div class="line">  <span class="comment">// so return __FLT128_MAX__ with the appropriate sign.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> f128_max = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x7ffeffff, -1, -1, -1);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> f128_smax = vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) f128_max, q_sign);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a> (f128_smax);</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="f128_softfloat_0_0_3_1_1"></a>
NaN and Infinity handling for Multiply</h4>
<p>When operands are not finite (infinite or Not-a-Number) we have to deal with a matrix of operand pairs and return specific result values.</p>
<dl class="section note"><dt>Note</dt><dd>The PowerISA provides a table with specified results for each combination of operands. See PowerISA 3.0B Table 82 Actions for xsmulqp[o].</dd></dl>
<p>Implementing this matrix of results does not require much computation, but does require conditional logic to separate all the cases. Another complication is that the matrix above specifies a <em>Default Quiet NaN</em> to be returned for any multiply of Infinity by zero (ignoring the operand's sign). In this case <a class="el" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56" title="return a quiet NaN.">vec_const_nanf128()</a> is returned while bypassing normal <a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b" title="Scalar Insert Exponent Quad-Precision.">vec_xsiexpqp()</a> exit sequence. All other cases must consider the operand's sign in the result. For example: </p><div class="fragment"><div class="line">{ <span class="comment">// One or both operands are NaN or Infinity</span></div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a> (a_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero)</div>
<div class="line">      &amp;&amp; <a class="code" href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a> (b_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero))</div>
<div class="line">    { <span class="comment">// Both operands either infinity or zero</span></div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a440a601539df9f00dfe3669b06ea5766">vec_cmpud_any_eq</a> (x_exp, q_zero))</div>
<div class="line">        { <span class="comment">// Infinity x Zero is Default Quiet NaN</span></div>
<div class="line">          <span class="keywordflow">return</span> <a class="code" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ();</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        { <span class="comment">// Infinity x Infinity == signed Infinity</span></div>
<div class="line">          q_sign = vec_xor (a_sign, b_sign);</div>
<div class="line">          q_exp = a_exp;</div>
<div class="line">          q_sig = a_sig;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    { <span class="comment">// One or both operands are NaN</span></div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_nan = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x00008000, 0, 0, 0);</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (vfa))</div>
<div class="line">        { <span class="comment">// vfa is NaN, return vfa as quiet NAN</span></div>
<div class="line">          q_sign = a_sign;</div>
<div class="line">          q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) a_sig, q_nan);</div>
<div class="line">          q_exp = a_exp;</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (vfb))</div>
<div class="line">        { <span class="comment">// vfb is NaN, return vfb as quiet NAN</span></div>
<div class="line">          q_sign = b_sign;</div>
<div class="line">          q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) b_sig, q_nan);</div>
<div class="line">          q_exp = b_exp;</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span>  <span class="comment">// Not NaN, so Infinity and a Nonzero finite number</span></div>
<div class="line">        { <span class="comment">// Return signed Infinity</span></div>
<div class="line">          q_sign = vec_xor (a_sign, b_sign);</div>
<div class="line">          q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero;</div>
<div class="line">          q_exp = exp_naninf;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="f128_softfloat_0_0_3_2"></a>
Add Quad-Precision with Round-to-Odd.</h3>
<p>The PVECLIB implementation of <b>Add Quad-Precision with Round-to-Odd</b> will use the POWER9 xsaddqpo instruction if the compile target supports it. Otherwise provide a POWER8 VSX implementation using operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a> and vec_int64_ppc. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line">test_addqpo (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR9) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line"><span class="preprocessor">#if defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 8)</span></div>
<div class="line">  <span class="comment">// earlier GCC versions generate extra data moves for this.</span></div>
<div class="line">  result = __builtin_addf128_round_to_odd (vfa, vfb);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// No extra data moves here.</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xsaddqpo %0,%1,%2&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (vfa), <span class="stringliteral">&quot;v&quot;</span> (vfb)</div>
<div class="line">      : );</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// Soft-float implementation</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> We prefer the compiler built-in (if available) but can substitute in-line assembler if needed. The built-in is subject to additional compiler optimizations (like instruction scheduling) while in-line assembler is not.</p>
<p>The PVECLIB soft-float implementation can leverage the 128-bit vector registers and operations supported by POWER8. The implementation starts with the usual sign-bit, exponent and significand extraction and ends with merging the computed sign-bit with the significand and inserting the computed exponent. For example: </p><div class="fragment"><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_exp, a_exp, b_exp, x_exp;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig, a_sig, b_sig, p_tmp, p_odd;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> a_mag, b_mag;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> s_sig, x_bits;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_sign,  a_sign,  b_sign;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> a_lt_b;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_zero = { 0, 0 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_ones = { -1, -1 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> exp_min = (<a class="code" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 1, 1 );</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_dnrm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0, 0 );</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_expnaninf = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0x7fff, 0x7fff );</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_expmax = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0x7ffe, 0x7ffe );</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> sigov = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x000fffff, -1, -1, -1);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> sigovt = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x0007ffff, -1, -1, -1);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> xbitmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0, 0, 0, 1);</div>
<div class="line"> </div>
<div class="line">  a_exp = <a class="code" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (vfa);</div>
<div class="line">  a_sig = <a class="code" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">vec_xsxsigqp</a> (vfa);</div>
<div class="line">  a_sign = <a class="code" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (vfa, signmask);</div>
<div class="line">  b_exp = <a class="code" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (vfb);</div>
<div class="line">  b_sig = <a class="code" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">vec_xsxsigqp</a> (vfb);</div>
<div class="line">  b_sign = <a class="code" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (vfb, signmask);</div>
<div class="line">  <span class="comment">// Vectorize the DW biased exponents</span></div>
<div class="line">  x_exp = <a class="code" href="vec__int64__ppc_8h.html#acd5bafec6c1c15b0336551e82d1169d4">vec_mrgahd</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) a_exp, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) b_exp);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//  if (vec_all_isfinitef128 (vfa) &amp;&amp; vec_all_isfinitef128 (vfb))</span></div>
<div class="line"><span class="comment">//  The above can be optimized to the following</span></div>
<div class="line">  <span class="keywordflow">if</span> (__builtin_expect (<a class="code" href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a> (x_exp, q_expnaninf), 1))</div>
<div class="line">    { <span class="comment">// Both operands are finite (normal, denormal, or zero)</span></div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    { <span class="comment">// One or both operands are NaN or Infinity</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Merge sign, significand, and exponent into final result</span></div>
<div class="line">  q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_sign);</div>
<div class="line">  result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
</div><!-- fragment --><p>Floating-point addition requires that operands are represented with the same exponent before the add operation. This means shifting the significand of the smaller magnitude right by the absolute difference between the exponents. To reduce the effect of round-off error this shift must preserve any low order bits (shifted away) as the Guard, Round and Sticky bits for internal <em>Intermediate Results (<b>IR</b>)</em>. For addition the <b>IR</b> only needs 117-bits which can be accommodated in a single 128-vector. Significands (which includes the leading/implicit bit) can be converted to <b>IR</b> form by shifting left 3-bits. This still leaves room on the left for the carry-bit. For example: </p><div class="fragment"><div class="line"><span class="comment">// Precondition the significands before add so the GRX bits</span></div>
<div class="line"><span class="comment">// are in the least significant 3 bit.</span></div>
<div class="line">a_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (a_sig, 3);</div>
<div class="line">b_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (b_sig, 3);</div>
</div><!-- fragment --><p> (See: <a class="el" href="vec__f128__ppc_8h.html#f128_softfloat_IRRN_0_1">Representing Intermediate results for Quad-Precision</a>) </p><dl class="section note"><dt>Note</dt><dd>The sign bits are maintained as separate local variables (a_sign, b_sign, q_sign) for the power8 VSX software implementation.</dd></dl>
<p>Floating-point addition will add or subtract magnitudes depending the signs of the operands. If the signs are the same, simply add (unsigned quadword) the two (<b>IR</b> format) operands. Otherwise if the signs differ, simply subtract (unsigned quadword) the smaller magnitude from the larger. In this case the sign of the result is the sign of the larger magnitude.</p>
<p>This discussion implies that knowing the relative absolute magnitude up front can simplify the implementation. As we saw in <a class="el" href="vec__f128__ppc_8h.html#f128_softfloat_0_0_1">Quad-Precision compares for POWER8</a> we can use quadword integer compares if we know that QP values are finite. By masking off sign-bit from the operands we can use unsigned quadword compare to determine relative magnitude. For example: </p><div class="fragment"><div class="line"><span class="comment">// Mask off sign bits so can use integers for magnitude compare.</span></div>
<div class="line">a_mag = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (vfa, signmask);</div>
<div class="line">b_mag = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (vfb, signmask);</div>
<div class="line"><span class="comment">// If magnitude(b) &gt;  magnitude(a) will need to swap a/b, later</span></div>
<div class="line">a_lt_b = <a class="code" href="vec__int128__ppc_8h.html#a7f9ebc5ad32b151a3e08136d51aad4dc">vec_cmpltuq</a> (a_mag, b_mag);</div>
</div><!-- fragment --><p> We can also generate a sign difference mask we can use later. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> diff_sign;</div>
<div class="line"><span class="comment">// If sign(vfa) != sign(vfb) will need to:</span></div>
<div class="line"><span class="comment">// 1) Subtract instead of add significands</span></div>
<div class="line"><span class="comment">// 2) Generate signed zeros</span></div>
<div class="line">q_sign = vec_xor (a_sign, b_sign);</div>
<div class="line">diff_sign = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) <a class="code" href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802">vec_setb_sq</a> ((<a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a>) q_sign);</div>
</div><!-- fragment --><p> Again a denormal is <em>encoded</em> as a biased exponent of 0x0000 and a nonzero (112-bit) fraction. But the architecture defines a denormal as 2<sup>Emin</sup> x (0.fraction). For Quad-Precision, Emin is defined as -16382 which is a biased exponent of 0x0001. We need to use Emin in the <b>IR</b> to to compute shift values. This requires a small fix-up before computing the <b>IR</b>. It is simpler at this point to apply Emin to both denormal and QP 0.0 values. </p><div class="fragment"><div class="line"><span class="comment">// Vectorize the DW biased exponents</span></div>
<div class="line">x_exp = <a class="code" href="vec__int64__ppc_8h.html#acd5bafec6c1c15b0336551e82d1169d4">vec_mrgahd</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) a_exp, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) b_exp);</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line">    <span class="comment">// Correct exponent for zeros or denormals to E_min</span></div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> exp_mask;</div>
<div class="line">        exp_mask = <a class="code" href="vec__int64__ppc_8h.html#a560aef2acfdf1db1cf14848ec6cb0c1c">vec_cmpequd</a> (x_exp, exp_dnrm);</div>
<div class="line">        x_exp = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) vec_sel (x_exp, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) exp_min, exp_mask);</div>
<div class="line">      }</div>
</div><!-- fragment --><p> We vectorize this fixup by merging a_exp/b_exp into a vector doubleword x_exp and applying compare/select.</p>
<p>Before diving into the add operation we simplify the code that follows by swapping the internal representation of vfa/vfb if if absolute magnitude of vfa is less than vfb. </p><div class="fragment"><div class="line"><span class="comment">// Now swap operands a/b if necessary so a has greater magnitude.</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> a_tmp = a_sig;</div>
<div class="line">    <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> b_tmp = b_sig;</div>
<div class="line">    <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> x_tmp = <a class="code" href="vec__int64__ppc_8h.html#a42d2b39711c06106097ef869a20420b6">vec_swapd</a> (x_exp);</div>
<div class="line"> </div>
<div class="line">    q_sign = vec_sel (a_sign, b_sign, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) a_lt_b);</div>
<div class="line"> </div>
<div class="line">    x_exp = vec_sel (x_exp, x_tmp, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) a_lt_b);</div>
<div class="line">    a_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> (x_exp, <a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>);</div>
<div class="line">    b_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> (x_exp, <a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>);</div>
<div class="line">    q_exp = a_exp;</div>
<div class="line"> </div>
<div class="line">    a_sig = <a class="code" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a> (a_tmp, b_tmp, (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) a_lt_b);</div>
<div class="line">    b_sig = <a class="code" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a> (b_tmp, a_tmp, (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) a_lt_b);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>At this point we can assume that:</p><ul>
<li>Exponents (a_exp, b_exp) are in the range E_min -&gt; E_max</li>
<li>And a_exp &gt;= b_exp<ul>
<li>If a_exp == b_exp then a_sig &gt;= b_sig</li>
<li>If a_exp &gt; b_exp then<ul>
<li>shift (b_sig) right by (a_exp - b_exp)</li>
<li>any bits shifted out of b_sig are ORed into the X-bit</li>
</ul>
</li>
</ul>
</li>
<li>The result exponent is usually a_exp +/-1</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a> (b_exp, a_exp))</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d_exp, l_exp;</div>
<div class="line">    <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> t_sig;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_128 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 128, 128 );</div>
<div class="line">    <span class="comment">// d_exp = a_exp - b_exp</span></div>
<div class="line">    d_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (a_exp, b_exp);</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a> (d_exp, exp_128))</div>
<div class="line">      { <span class="comment">// if (d_exp &lt; 128) then shift b_sig right</span></div>
<div class="line">        t_sig = <a class="code" href="vec__int128__ppc_8h.html#a0edd172a5656b842d6586c5078284942">vec_srq</a> (b_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_exp);</div>
<div class="line">        <span class="comment">// retain bits shifted way for X-bits</span></div>
<div class="line">        l_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (exp_128, d_exp);</div>
<div class="line">        x_bits = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (b_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) l_exp);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      { <span class="comment">// else all significant bits shifted away</span></div>
<div class="line">        t_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero;</div>
<div class="line">        <span class="comment">// retain original b_sig for X-bits</span></div>
<div class="line">        x_bits = b_sig;</div>
<div class="line">      }</div>
<div class="line">    <span class="comment">// reduce and X-bits for X-bit in IR</span></div>
<div class="line">    p_odd = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (x_bits, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_ones);</div>
<div class="line">    <span class="comment">// merge shifted b_sig with accumlated X-bit</span></div>
<div class="line">    b_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) t_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_odd);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> The inner if/then/else can be replaced with select logic. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> exp_mask = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) <a class="code" href="vec__int64__ppc_8h.html#ac23cdb84882a03083962b1679b622ea4">vec_cmpltud</a> (d_exp, exp_128);</div>
<div class="line">l_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (exp_128, d_exp);</div>
<div class="line">t_sig = <a class="code" href="vec__int128__ppc_8h.html#a0edd172a5656b842d6586c5078284942">vec_srq</a> (b_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_exp);</div>
<div class="line">x_bits = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (b_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) l_exp);</div>
<div class="line">t_sig = <a class="code" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero, t_sig, exp_mask);</div>
<div class="line">x_bits = <a class="code" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a> (b_sig, x_bits, exp_mask);</div>
</div><!-- fragment --><p>Now we are ready to compute the significand. For example: </p><div class="fragment"><div class="line"><span class="comment">// If operands have the same sign then s_sig = a_sig + b_sig</span></div>
<div class="line"><span class="comment">// Otherwise s_sig = a_sig - b_sig</span></div>
<div class="line">add_sig = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (a_sig, b_sig);</div>
<div class="line">sub_sig = <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> (a_sig, b_sig);</div>
<div class="line">s_sig = <a class="code" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a> (add_sig, sub_sig, (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) diff_sign);</div>
</div><!-- fragment --><p> Now handle the special case of a zero (0.0) result. Either added two zero operands or a subtraction (equal operands with different signs) produced an exact zero result. Exact zero results always have an positive sign, otherwise return return the result with same sign as vfa. For example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a> (s_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero))</div>
<div class="line">  { <span class="comment">// Special case of both zero with different sign</span></div>
<div class="line">    q_sign = vec_sel (a_sign, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_zero, diff_sign);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a> (q_sign);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Next check for overflow/carry. In this case we need to shift the significand right one bit and increment the exponent by one. Also insure that and X-bit is not lost (shifted away) before we get to the rounding stage. For example: </p><div class="fragment"><div class="line"><span class="comment">// Check for carry and adjust</span></div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#ac93dc5ed8bb3501470cf70c5cb5796a9">vec_cmpuq_all_gt</a> (s_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) sigov))</div>
<div class="line">  {</div>
<div class="line">    p_odd = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) s_sig, xbitmask);</div>
<div class="line">    s_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (s_sig, 1);</div>
<div class="line">    s_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) s_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_odd);</div>
<div class="line">    q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (q_exp, q_one);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Otherwise check for underflow (C- and L-bits are 0b0) which requires normalization and may result in a denormal value. Use count leading zeros to estimate the required normalizing left shift. The <b>IR</b> internal representation with normally have 12 leading zeros and so we need to adjust for that. Also we need to prevent shifting beyond denormal range (q_exp &lt;= E_min), so use the minimum of leading zero count and the delta between the current (q_exp) exponent and E_min. For example: </p><div class="fragment"><div class="line"><span class="comment">// Or the significand is below normal range.</span></div>
<div class="line"><span class="comment">// This can happen with subtraction (different signs).</span></div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a2b7f505ebca731aa6fdc7433f82c0c6d">vec_cmpuq_all_le</a> (s_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) sigovt))</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_12 = { 12, 12 };</div>
<div class="line">    <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> c_exp, d_exp;</div>
<div class="line">    <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> c_sig;</div>
<div class="line"> </div>
<div class="line">    c_sig = <a class="code" href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49">vec_clzq</a> (s_sig);</div>
<div class="line">    c_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> ((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) c_sig, <a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>);</div>
<div class="line">    c_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (c_exp, exp_12);</div>
<div class="line">    d_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_exp, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) exp_min);</div>
<div class="line">    d_exp = <a class="code" href="vec__int64__ppc_8h.html#ad24220d787ac863b7911a303da17d1a0">vec_minud</a> (c_exp, d_exp);</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p> The overflow/underflow test above are expensive quadword integer compares and quadword constants. However all that is required is testing the C/L-bits. We can convert these tests into byte compares. For example: </p><div class="fragment"><div class="line">      <span class="comment">// The C/L-bits are shifted 3-bit left like the significand</span></div>
<div class="line">      <span class="comment">// So the C/L-bits would be constants 16 and 8.</span></div>
<div class="line">      <span class="comment">// But splat-immediate can&#39;t generate a +16, so we subtract 1</span></div>
<div class="line">      <span class="comment">// from each and adjust the compares to compensate.</span></div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> t_sig_L = vec_splat_u8 (7);</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> t_sig_C = vec_splat_u8 (15);</div>
<div class="line">      <span class="comment">// ...</span></div>
<div class="line">      <span class="comment">// Issolate CL bits from significand too simplify the compare</span></div>
<div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div>
<div class="line">      <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> t_sig = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) s_sig, 14);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">      <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> t_sig = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) s_sig, 1);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        <span class="comment">// Check for carry and adjust</span></div>
<div class="line">        <span class="keywordflow">if</span> (vec_all_gt (t_sig, t_sig_C))</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// ...</span></div>
<div class="line">        }</div>
<div class="line">      <span class="comment">// else check for underflow</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vec_all_le (t_sig, t_sig_L))</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// ...</span></div>
<div class="line">        }</div>
</div><!-- fragment --><p>If the current exponent is greater then E_min then we can safely use the minimum shift count to:</p><ul>
<li>Normalize the significand by left shift and adjust the exponent.</li>
<li>If the adjusted exponent is &lt;= E_min then return denormal by setting the biased exponent to zero (q_zero).</li>
</ul>
<p>For example: </p><div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a1fffe85d6f314f935fcd1fabf0ebe389">vec_cmpsd_all_gt</a> ((<a class="code" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>) q_exp, exp_min))</div>
<div class="line">      {</div>
<div class="line">        s_sig = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (s_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_exp);</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a871f91423e5154739ae225c82620d6b4">vec_cmpud_all_le</a> (q_exp, c_exp))</div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// Exponent is less than the required normalization</span></div>
<div class="line">            <span class="comment">// so return denormal result</span></div>
<div class="line">            q_exp = q_zero;</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_exp, d_exp);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Exponent is less than or equal to E_min</span></div>
<div class="line">        <span class="comment">// so return denormal result</span></div>
<div class="line">        q_exp = q_zero;</div>
<div class="line">      }</div>
</div><!-- fragment --><p> This can be simplified using boolean select logic. Here we replace <a class="el" href="vec__int64__ppc_8h.html#a871f91423e5154739ae225c82620d6b4" title="Vector Compare all Less than equal Unsigned Doubleword.">vec_cmpud_all_le()</a> with <a class="el" href="vec__int64__ppc_8h.html#aeb17e3bb401eff58cf827c9fc5f281bf" title="Vector Compare Greater Than Unsigned Doubleword.">vec_cmpgtud()</a> and vec_sel() which generates smaller faster code. For example: </p><div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a1fffe85d6f314f935fcd1fabf0ebe389">vec_cmpsd_all_gt</a> ((<a class="code" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>) q_exp, exp_min))</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> exp_mask = <a class="code" href="vec__int64__ppc_8h.html#aeb17e3bb401eff58cf827c9fc5f281bf">vec_cmpgtud</a> (q_exp, c_exp);</div>
<div class="line"> </div>
<div class="line">        s_sig = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (s_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_exp);</div>
<div class="line">        q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_exp, d_exp);</div>
<div class="line">        q_exp = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) vec_sel (q_zero, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) q_exp, exp_mask);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="comment">// ...</span></div>
</div><!-- fragment --><p> After normalization we are ready to round the <b>IR</b>, where round-to-odd is the simplest case. For example: </p><div class="fragment"><div class="line"><span class="comment">// Round to odd from low order GRX-bits</span></div>
<div class="line">p_tmp = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) s_sig, grx_mask);</div>
<div class="line">p_odd = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (p_tmp, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_ones);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (s_sig, 3);</div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) p_odd);</div>
</div><!-- fragment --><p> After rounding we need one more check for overflow. For round-to-odd we will not see an significand overflow (none-zero C-bit) but we may have overflowed the exponent range.</p>
<p>For normal rounding modes, exponent overflow would generate an infinity. However round-to-odd is a special case that returns the maximum finite value <b>__FLT128_MAX__</b>. For example: </p><div class="fragment"><div class="line"><span class="comment">// Check for exponent overflow -&gt; __FLT128_MAX__</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#af13f19199e5872ecaf88742043f26642">vec_cmpud_all_gt</a> (q_exp, q_expmax))</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// return maximum finite exponent and significand</span></div>
<div class="line">    q_exp = q_expmax;</div>
<div class="line">    q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) sigov;</div>
<div class="line">  }</div>
</div><!-- fragment --><p> This ends the overall path for finite operands. the last step will merge the sign bit with the significand then insert the exponent. For example: </p><div class="fragment"><div class="line"><span class="comment">// Merge sign, significand, and exponent into final result</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_sign);</div>
<div class="line">result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
</div><!-- fragment --><h4><a class="anchor" id="f128_softfloat_0_0_3_2_1"></a>
NaN and Infinity handling for Add</h4>
<p>If either operand is a NaN or infinity special handling is required. See PowerISA 3.0B Table 53 Actions for xsaddqp[o].</p>
<p>The PowerISA specifies that the xsaddqpo operation returns a quiet NaN if either operand is a NaN:</p><ul>
<li><b>src1</b> is a NaN, convert <b>src1</b> to a quiet NaN and return that value.</li>
<li><b>src1</b> is not a NaN, convert <b>src2</b> to a quiet NaN and return that value.</li>
</ul>
<p>For example: </p><div class="fragment"><div class="line"><span class="comment">// One or both operands are NaN</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_nan = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x00008000, 0, 0, 0);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (vfa))</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// vfa is NaN</span></div>
<div class="line">    q_sign = a_sign;</div>
<div class="line">    q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) a_sig, q_nan);</div>
<div class="line">    q_exp = a_exp;</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (vfb))</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// vfb is NaN</span></div>
<div class="line">    q_sign = b_sign;</div>
<div class="line">    q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) b_sig, q_nan);</div>
<div class="line">    q_exp = b_exp;</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span>  <span class="comment">//</span></div>
</div><!-- fragment --><p> The sign. significand, and exponent are combined into a __float128 quiet NaN and returned.</p>
<p>Otherwise one or both operands are infinity. Addition of an infinity and a finite or two infinities (of the same sign) returns infinity. But subtraction of infinities (additional of different signs) returns a default quiet NaN. For example: </p><div class="fragment"><div class="line"><span class="comment">// else one or both operands are Infinity</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (x_exp, q_expnaninf)</div>
<div class="line">        &amp;&amp; <a class="code" href="vec__int64__ppc_8h.html#aa03d831ec09612229357e2ea34383eaf">vec_cmpud_any_ne</a> ((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) a_sign, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) b_sign))</div>
<div class="line">      { <span class="comment">// Both operands infinity and opposite sign</span></div>
<div class="line">        <span class="comment">// Inifinty + Infinity (opposite sign) is Default Quiet NaN</span></div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ();</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      { <span class="comment">// Either both operands infinity and same sign</span></div>
<div class="line">        <span class="comment">// Or one infinity and one finite</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a440a601539df9f00dfe3669b06ea5766">vec_cmpud_any_eq</a> (a_exp, q_expnaninf))</div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// return infinity</span></div>
<div class="line">            <span class="keywordflow">return</span> vfa;</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// return infinity</span></div>
<div class="line">            <span class="keywordflow">return</span> vfb;</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">  }</div>
</div><!-- fragment --><h3><a class="anchor" id="f128_softfloat_0_0_3_3"></a>
Subtract Quad-Precision with Round-to-Odd.</h3>
<p>The PVECLIB implementation of <b>Subtract Quad-Precision with Round-to-Odd</b> will use the POWER9 xssubqpo instruction if the compile target supports it. Otherwise provide a POWER8 VSX implementation based on the PVECLIB <b>Add Quad-Precision</b> implementation. This is based on the observation that;</p><ul>
<li>floating-point addition becomes subtraction if the signs differ, and</li>
<li>negation of the second operand allows use of the existing add operation to perform subtraction.</li>
</ul>
<p>For example: </p><div class="fragment"><div class="line"> <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line">test_vec_subqpo_V0 (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> src1, <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> src2)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR9) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line"><span class="preprocessor">#if defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 8)</span></div>
<div class="line">  <span class="comment">// earlier GCC versions generate extra data moves for this.</span></div>
<div class="line">  result = __builtin_subf128_round_to_odd (src1, src2);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// No extra data moves here.</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xssubqpo %0,%1,%2&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (src1), <span class="stringliteral">&quot;v&quot;</span> (src2)</div>
<div class="line">      : );</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#else  // defined (_ARCH_PWR8)</span></div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> nsrc2 = <a class="code" href="vec__f128__ppc_8h.html#a3323b6fb0b379a21f3dd70f7f204bd2a">vec_negf128</a> (src2);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__f128__ppc_8h.html#aa3bff7954c22b5d85f976f046290f37b">vec_xsaddqpo</a> (src1, nsrc2);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Unfortunately it is not that simple. The PowerISA specifies that the xssubqpo operation must return the original <b>src2</b> operand as a quiet NaN if:</p><ul>
<li><b>src2</b> is a NaN, and</li>
<li><b>src1</b> is not a NaN.</li>
</ul>
<p>See PowerISA 3.0B Table 95 Actions for xssubqp[o].</p>
<p>To insure compatible results for POWER8 and POWER9 implementations we need to avoid negation if <b>src2</b> is a NaN. For example: </p><div class="fragment"><div class="line"> <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line">test_vec_subqpo_V1 (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> src1, <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> src2)</div>
<div class="line">{</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="preprocessor">#else  // defined (_ARCH_PWR8)</span></div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> nsrc2;</div>
<div class="line"> </div>
<div class="line">  nsrc2 = <a class="code" href="vec__f128__ppc_8h.html#a47637906e95a7c94cffc093bc2e57dbf">vec_self128</a> (<a class="code" href="vec__f128__ppc_8h.html#a3323b6fb0b379a21f3dd70f7f204bd2a">vec_negf128</a> (src2), src2, <a class="code" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">vec_isnanf128</a>(src2));</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__f128__ppc_8h.html#aa3bff7954c22b5d85f976f046290f37b">vec_xsaddqpo</a> (src1, nsrc2);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This requires a relatively expensive (~14 cycle) <a class="el" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72" title="Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN).">vec_isnanf128()</a> test and adds ~12 instructions to the <a class="el" href="vec__f128__ppc_8h.html#a5f8e71a4362e87704c5172b751ecbc6f" title="VSX Scalar Subtract Quad-Precision using round to Odd.">vec_xssubqpo()</a> operation. But this does product correct results for all operand combinations.</p>
<dl class="section note"><dt>Note</dt><dd>This assumes that <a class="el" href="vec__f128__ppc_8h.html#aa3bff7954c22b5d85f976f046290f37b" title="VSX Scalar Add Quad-Precision using round to Odd.">vec_xsaddqpo()</a> is fully inlined into <a class="el" href="vec__f128__ppc_8h.html#a5f8e71a4362e87704c5172b751ecbc6f" title="VSX Scalar Subtract Quad-Precision using round to Odd.">vec_xssubqpo()</a>.</dd></dl>
<p>To get POWER8 an implementation of <b>Subtract Quad-Precision with Round-to-Odd</b> with better performance we need to inject the <b>src2</b> sign negation strategically into a copy of the <b>Add Quad-Precision</b> implementation. This should be after;</p><ul>
<li>extracting the sign, exponent and significand from the <b>Quad-Precision</b> source operands, and</li>
<li>testing for finite, NaN, and infinity</li>
</ul>
<p>Once we know that neither operand is NaN we can simply flip the sign bit for source operand 2. For example once we know that both operands are finite: </p><div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line"><span class="comment">//  if (vec_all_isfinitef128 (vfa) &amp;&amp; vec_all_isfinitef128 (vfb))</span></div>
<div class="line"><span class="comment">//  The above can be optimized to the following</span></div>
<div class="line">  <span class="keywordflow">if</span> (__builtin_expect (<a class="code" href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a> (x_exp, q_expnaninf), 1))</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Negate sign for subtract, then use add logic</span></div>
<div class="line">      b_sign = vec_xor (signmask, b_sign);</div>
<div class="line">      <span class="comment">// ...</span></div>
</div><!-- fragment --><h4><a class="anchor" id="f128_softfloat_0_0_3_3_1"></a>
NaN and Infinity handling for Subtract</h4>
<p>The other case is the <b>else</b> leg of the finite case where at least one of the operands is NaN or infinity. For example once we know the none of the operands are NaN: </p><div class="fragment"><div class="line"><span class="comment">// ... NaNs</span></div>
<div class="line"><span class="keywordflow">else</span>  <span class="comment">// Or one or both operands are Infinity</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (x_exp, q_expnaninf)</div>
<div class="line">        &amp;&amp; <a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> ((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) a_sign, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) b_sign))</div>
<div class="line">      { <span class="comment">// Both operands infinity and same sign</span></div>
<div class="line">        <span class="comment">// Inifinty - Infinity (same sign) is Default Quiet NaN</span></div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ();</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      { <span class="comment">// Either both operands infinity and different sign</span></div>
<div class="line">        <span class="comment">// Or one infinity and one finite</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a440a601539df9f00dfe3669b06ea5766">vec_cmpud_any_eq</a> (a_exp, q_expnaninf))</div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// return infinity</span></div>
<div class="line">            <span class="keywordflow">return</span> src1;</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// return -src2 (infinity)</span></div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="vec__f128__ppc_8h.html#a3323b6fb0b379a21f3dd70f7f204bd2a">vec_negf128</a>(src2);</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">  }</div>
</div><!-- fragment --><p> The changes for <a class="el" href="vec__f128__ppc_8h.html#a5f8e71a4362e87704c5172b751ecbc6f" title="VSX Scalar Subtract Quad-Precision using round to Odd.">vec_xssubqpo()</a> from <a class="el" href="vec__f128__ppc_8h.html#aa3bff7954c22b5d85f976f046290f37b" title="VSX Scalar Add Quad-Precision using round to Odd.">vec_xsaddqpo()</a> are:</p><ul>
<li>When both operands are infinity and the same sign, then return the default quiet NaN. For <a class="el" href="vec__f128__ppc_8h.html#aa3bff7954c22b5d85f976f046290f37b" title="VSX Scalar Add Quad-Precision using round to Odd.">vec_xsaddqpo()</a> this tests for signs not equal via <a class="el" href="vec__int64__ppc_8h.html#aa03d831ec09612229357e2ea34383eaf" title="Vector Compare any Not Equal Unsigned Doubleword.">vec_cmpud_any_ne()</a>.</li>
<li>Otherwise if <b>src1</b> is finite and <b>src2</b> is infinity then return negative <b>src2</b>.</li>
</ul>
<h2><a class="anchor" id="f128_softfloat_0_0_4"></a>
Constants and Masks for Quad-Precision Soft-float</h2>
<p>The implementation examples above require a number of __binary128, vector __int128, and vector long long constants. These are used as (special) return values, binary masks, and integer constants for comparison and arithmetic.</p>
<p>In this case finite __float128 (AKA __binary128) constants are provided by the compiler (via -mfloat128) if supported. Literal constants can be defined using the <b>'q'/'Q'</b> suffix. The compile also provides macros for the IEEE range values; __FLT128_MAX__, __FLT128_MIN__, __FLT128_EPSILON__, and __FLT128_DENORM_MIN__. These macros define the appropriate literal constant using the 'Q' suffix.</p>
<p>The compiler also provides build-in functions for some special constant values; __builtin_infq (), __builtin_huge_valq (), _builtin_nanq (), and __builtin_nansq (). This assumes that you are using a compiler that supports __float128 types and operations and is enabled (via -mfloat128).</p>
<p>PVECLIB has to operated in an environment where the compiler's support for IEEE Float128 is disabled, missing, or incomplete. So this implementation may construct any __binary128 values it may need as vector constants then use the appropriate <em>xfer</em> function to create the required scalar value. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line"><a class="code" href="vec__f128__ppc_8h.html#a9c68f73f69c4776bb054d42915e7103d">vec_const_inff128</a> ()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> posinf = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x7fff0000, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a> (posinf);</div>
<div class="line">}</div>
</div><!-- fragment --><p>PVECLIB provides splat operations <a class="el" href="vec__int64__ppc_8h.html#a19a32c33468aa6da229f4712d9e1adc0" title="Vector Splat Immediate Signed Doubleword. Duplicate the signed integer constant across doubleword ele...">vec_splat_s64()</a> and <a class="el" href="vec__int128__ppc_8h.html#a6373310baef2083fb42fd30bbdc6a618" title="Vector Splat Immediate Signed Quadword. Extend a signed integer constant across the quadword element ...">vec_splat_s128()</a> for small integer constants. For integers in the range -16 &lt;-&gt; 15 the implementation can use vec_splat_s32() then sign extent word elements to doubleword or quadword integer elements. This has the advantage of shorter instruction latency and avoids a vector load from storage. Any vector load has a chance of cache miss and associated cache reload latencies.</p>
<p>For constants outside of this range the implementation uses vec_splats() for which the compiler is expected to load a vector constant from storage. See: <a class="el" href="vec__int64__ppc_8h.html#i64_missing_ops_0_2_0">Loading small Doubleword constants</a> and <a class="el" href="vec__int128__ppc_8h.html#int128_const_0_0_3">Loading small Quadword constants</a></p>
<h3><a class="anchor" id="f128_softfloat_0_0_4_1"></a>
Special Constants for Quad-Precision Soft-float</h3>
<p>Some special values and masks don't qualify as small integers and need to be constructed as vector constants in hexadecimal. For example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> magmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x7fffffff, -1, -1, -1);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> sigmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x0000ffff, -1, -1, -1);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x7fff0000, 0, 0, 0);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> hiddenbit = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x00010000, 0, 0, 0);</div>
</div><!-- fragment --><p> For most of these values the compiler will generate a quadword constant in the read-only data segment and generate a vector load for any function that references that constant.</p>
<p>One exception is the quadword sign mask which the GCC compiler recognizes as special case (See: <a class="el" href="vec__int128__ppc_8h.html#int128_const_0_0_3_2">Some special quadword constants</a>). This is a 4 instruction sequence of vector splat immediate words and shift lefts. The nominal execution latency is 6 cycles. The quadword sign mask can be used for both signed quadword integer and quad-precision float values.</p>
<p>It would be useful if we could identify similar (none load) sequences for other mask values. The Quad-Precision Quiet NaN bit mask <em>QNaNbit</em>) is similar to the <em>signmask</em>. Quiet NaNs <b>QNaNs</b> represent the result of specific invalid operations or when <em>Signaling NaNs</em> are (Operation Exception) disabled. Quad-Precision Soft-float needs this mask to generate default QNaNs or convert an operand of an invalid operations to return a QNaN result. See: <a class="el" href="vec__f128__ppc_8h.html#f128_softfloat_0_0_3_1_1">NaN and Infinity handling for Multiply</a>, <a class="el" href="vec__f128__ppc_8h.html#f128_softfloat_0_0_3_2_1">NaN and Infinity handling for Add</a>, and <a class="el" href="vec__f128__ppc_8h.html#f128_softfloat_0_0_3_3_1">NaN and Infinity handling for Subtract</a>.</p>
<p>Like the <em>signmask</em> it requires the generation of a 0x80000000 constant that can be shifted into position. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line">test_mask128_f128Qbit (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//  const vui32_t QNaNbit = CONST_VINT128_W (0x00008000, 0, 0, 0);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_ones = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (-1, -1, -1, -1);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> QNaNbit;</div>
<div class="line">  QNaNbit = vec_sl (q_ones, q_ones);</div>
<div class="line">  <span class="keywordflow">return</span> vec_sld (QNaNbit, q_zero, 10);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Unfortunately the compiler does not recognize this vector constant as a special case. So PVECLIB provides it own implementation. See: <a class="el" href="vec__f128__ppc_8h.html#a619b1beb77d75c62ea9913e527bb0cf1" title="Generate Quadword QNaN-bit mask Immediate.">vec_mask128_f128Qbit()</a>.</p>
<h4><a class="anchor" id="f128_softfloat_0_0_4_1_1"></a>
Tricks with one's complement</h4>
<p>For example the sign and magnitude masks are one's complements of each other. This allows us to get the effect of the <em>magmask</em> by reusing the <em>signmask</em> and using Vector AND with Complement. For example: </p><div class="fragment"><div class="line"><span class="comment">// Mask off sign bits so can use quadword integer magnitude compare.</span></div>
<div class="line">a_mag = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (vfa, signmask);</div>
<div class="line">b_mag = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (vfb, signmask);</div>
<div class="line"><span class="comment">// Extract the sign bit.</span></div>
<div class="line">a_sign = <a class="code" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (vfa, signmask);</div>
<div class="line">b_sign = <a class="code" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (vfb, signmask);</div>
</div><!-- fragment --><p>The alternative is to use the <em>magmask</em> and use Vector AND with Complement to extact the sign bits. For example: </p><div class="fragment"><div class="line"><span class="comment">// Mask off sign bits so can use quadword integer magnitude compare.</span></div>
<div class="line">a_mag = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (vfa, magmask);</div>
<div class="line">b_mag = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (vfb, magmask);</div>
<div class="line"><span class="comment">// Extract the sign bit.</span></div>
<div class="line">a_sign = <a class="code" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (vfa, magmask);</div>
<div class="line">b_sign = <a class="code" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (vfb, magmask);</div>
</div><!-- fragment --><p>This also applies to the vector select (vec_sel()) operation. Vector selects is defined as bit-wise (vra &amp; ~vrc) | (vrb &amp; vrc) where vrc is the select mask. So the complement of the select mask can be used by swapping select inputs vra/vrb.</p>
<p>Using the complement has no advantage unless we can generate the <em>magmask</em> with a shorter/faster (than <em>signmask</em>) sequence. Or if the complement is used elsewhere (in the function) and using the complement (for both/multiple operations) allows the implementation to eliminated an expensive constant load.</p>
<p>So lets look at what we can do to generate the magnitude mask (<em>magmask</em>). For example we can shift the <em>all ones</em> vector right one bit: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line">test_mask128_f128mag (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//  const vui32_t magmask = CONST_VINT128_W (0x7fffffff, -1, -1, -1);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_ones = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (-1, -1, -1, -1);</div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_ones, 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p> which generates: </p><div class="fragment"><div class="line">0000000000001560 &lt;test_mask128_f128mag&gt;:</div>
<div class="line">     vspltisw v0,-1</div>
<div class="line">     vspltisb v2,1</div>
<div class="line">     vsr     v2,v0,v2</div>
<div class="line">     blr</div>
</div><!-- fragment --><p> This sequence only requires 3 instructions and a nominal execution latency of 4 cycles. The vector splat immediate instructions are independent and can execute in parallel. So this technique for generating <em>magmask</em> and using it instead of <em>signmask</em> is advantageous. Also a clear advantage versus loading <em>magmask</em> as a vector constant (at 9+ cycles latency).</p>
<h4><a class="anchor" id="f128_softfloat_0_0_4_1_2"></a>
Other examples for special constants</h4>
<p>Now lets look at how we might generate the significand mask (<em>sigmask</em>.) For example we can shift the <em>all ones</em> vector right 16-bits:</p>
<div class="fragment"><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line">  test_mask128_f128sig (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//  const vui32_t sigmask = CONST_VINT128_W (0x0000ffff, -1, -1, -1);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_ones = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (-1, -1, -1, -1);</div>
<div class="line">  <span class="comment">// Equivalent to shift right 16-bits immediate.</span></div>
<div class="line">  <span class="keywordflow">return</span> vec_sld (q_zero, q_ones, 14);</div>
<div class="line">}</div>
</div><!-- fragment --><p> which generates: </p><div class="fragment"><div class="line">0000000000001580 &lt;test_mask128_f128sig&gt;:</div>
<div class="line">     vspltisw v0,0</div>
<div class="line">     vspltisw v2,-1</div>
<div class="line">     vsldoi  v2,v0,v2,14</div>
<div class="line">     blr</div>
</div><!-- fragment --><p> Again this sequence only requires 3 instructions and a nominal execution latency of 4 cycles. The vector splat immediate instructions are independent and can execute in parallel. So generating the <em>sigmask</em> this way has an advantage over loading a vector constant.</p>
<dl class="section note"><dt>Note</dt><dd>The quadword constant q_zero and q_ones are already recognized by the compiler as a special case and commonly used in mask generation. As such these constants should be subject to common subexpression optimization and generated once per function.</dd></dl>
<p>More examples of special constants are single-bit masks used to compare/test/set the carry/leading bits of the significand. These constants are easy to generate as halfword/word immediate values but need to be shifted left into the high order halfword of the quadword. For example: </p><div class="fragment"><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line">  test_mask128_f128Lbit (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//  const vui32_t hidden = CONST_VINT128_W (0x00010000, 0, 0, 0);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> hidden = vec_splat_u32 (1);</div>
<div class="line">  <span class="keywordflow">return</span> vec_sld (hidden, q_zero, 14);</div>
<div class="line">}</div>
</div><!-- fragment --><p> which generates: </p><div class="fragment"><div class="line">0000000000001600 &lt;test_mask128_f128Lbit&gt;:</div>
<div class="line">     vspltisw v2,0</div>
<div class="line">     vspltisw v0,1</div>
<div class="line">     vsldoi  v2,v0,v2,14</div>
<div class="line">     blr</div>
</div><!-- fragment --><p> Again this sequence only requires 3 instructions and a nominal execution latency of 4 cycles. The vector splat immediate instructions are independent and can execute in parallel. We could use the splat halfword immediate for '1' here but word constants are more commonly used and there is no advantage (in instruction count or latency). See: <a class="el" href="vec__int64__ppc_8h.html#a19a32c33468aa6da229f4712d9e1adc0" title="Vector Splat Immediate Signed Doubleword. Duplicate the signed integer constant across doubleword ele...">vec_splat_s64()</a> and <a class="el" href="vec__int128__ppc_8h.html#a6373310baef2083fb42fd30bbdc6a618" title="Vector Splat Immediate Signed Quadword. Extend a signed integer constant across the quadword element ...">vec_splat_s128()</a>.</p>
<p>Similarly for the carry bit: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line">test_mask128_f128Cbit (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//  const vui32_t carry = CONST_VINT128_W (0x00020000, 0, 0, 0);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> carry = vec_splat_u32 (2);</div>
<div class="line">  <span class="keywordflow">return</span> vec_sld (carry, q_zero, 14);</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="f128_softfloat_0_0_4_1_3"></a>
Some constants are trickier</h4>
<p>Some constants are just more difficult to construct. For example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x7fff0000, 0, 0, 0);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_naninf = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0x7fff, 0, 0x7fff);</div>
</div><!-- fragment --><p> These constants are used to extract/insert exponents and to test operands for NaN/Infinity. They are used early in many Quad-precision operations, so any delay in getting these constants ready for use, will impact the performance of the whole operation. </p><dl class="section note"><dt>Note</dt><dd>The <em>expmask</em> is also used to construct NaN/Infinity values as special return values. But these cases should be rare and so any delays in loading these should not cause significant performance impact.</dd></dl>
<p>The tricky part is generating any value with sequence of '1's with '0's on both sides (not left or right justified). Especially within the constraints imposed by POWER8 (PowerISA 2.07B) and earlier machines. Any (none load) sequence require both a left and right shift and any bit (versus octet) shifts will require additional vector constants as shift counts. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line">test_mask128_f128exp_V0 (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//  const vui32_t expmask = CONST_VINT128_W (0x7fff0000, 0, 0, 0);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_ones = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (-1, -1, -1, -1);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask;</div>
<div class="line">  <span class="comment">// generate {0xffff0000, 0, 0, 0} from q_ones/q_zero</span></div>
<div class="line">  expmask = vec_sld (q_ones, q_zero, 14);</div>
<div class="line">  <span class="comment">// Then shift right halfword to get  {0x7fff0000, 0, 0, 0}</span></div>
<div class="line">  expmask = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) <a class="code" href="vec__int16__ppc_8h.html#a292973c417034f4b8813765b63ca03c2">vec_srhi</a> ((<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>) expmask, 1);</div>
<div class="line">  <span class="keywordflow">return</span> expmask;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Which generates: </p><div class="fragment"><div class="line">0000000000001590 &lt;test_mask128_f128exp_V0&gt;:</div>
<div class="line">    vspltisw v1,0</div>
<div class="line">    vspltisw v0,-1</div>
<div class="line">    vspltish v2,1</div>
<div class="line">    vsldoi  v0,v0,v1,14</div>
<div class="line">    vsrh    v2,v0,v2</div>
<div class="line">    blr</div>
</div><!-- fragment --><p> This is 5 instructions with a nominal latency of 6 cycles. The halfword shift right requires its own halfword shift count which is unlikely to find a common subexpression within Quad-precision codes.</p>
<p>Another possibility is use Vector Pack Pixel (<b>vpkpx</b>) to convert a sequences of words (4x8-bit pixel channels) into a sequence of halfwords (a leading 1-bit channel followed by 3x5-bit channels). The high order channel copies word bit 7 to halfword bit 0. The next three channels are copied 5-bits at a time from the high-order 5-bits of word bytes 1-3. The pack pixel operation requires 8 word elements (256-bits from 2 VRs) to generate 8 halfword elements (one 128-bit vector result).</p>
<p>For example the word element constant 0x00ffffff generates the halfword element 0x7fff. The trick becomes to generate the vectors {0x00ffffff, 0, 0, 0} and {0, 0, 0, 0} using only vector immediate instructions. Where possible we should use built-ins and values common in other operations within PVECLIB and <a class="el" href="vec__f128__ppc_8h.html" title="Header package containing a collection of 128-bit SIMD operations over Quad-Precision floating point ...">vec_f128_ppc.h</a>. This effectively limits us to the vector splat immediate and Vector Splat Immediate Signed Word (vspltisw) and Vector Shift Left Double by Octet Immediate (vsldoi). For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line"> test_mask128_f128exp_V1 (<span class="keywordtype">void</span>)</div>
<div class="line"> {</div>
<div class="line">   <span class="comment">//  const vui32_t expmask = CONST_VINT128_W (0x7fff0000, 0, 0, 0);</span></div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_ones = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (-1, -1, -1, -1);</div>
<div class="line">   <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask;</div>
<div class="line">   <span class="comment">// Genrate {0x00ffffff, 0, 0, 0} from q_ones/q_zeros</span></div>
<div class="line">   expmask = vec_sld (q_ones, q_zero, 13);</div>
<div class="line">   expmask = vec_sld (expmask, expmask, 15);</div>
<div class="line">   <span class="comment">// Pack to Pixel to generate {0x7fff0000, 0, 0, 0}</span></div>
<div class="line"><span class="preprocessor"> #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div>
<div class="line">   <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vec_packpx (q_zero, expmask);</div>
<div class="line"><span class="preprocessor"> #else</span></div>
<div class="line">   <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vec_packpx (expmask, q_zero);</div>
<div class="line"><span class="preprocessor"> #endif</span></div>
<div class="line"><span class="preprocessor"> }</span></div>
</div><!-- fragment --><p> Which generates: </p><div class="fragment"><div class="line">0000000000001580 &lt;test_mask128_f128exp_V1&gt;:</div>
<div class="line">    vspltisw v2,0</div>
<div class="line">    vspltisw v0,-1</div>
<div class="line">    vsldoi  v0,v0,v2,13</div>
<div class="line">    vsldoi  v0,v0,v0,15</div>
<div class="line">    vpkpx   v2,v0,v2</div>
<div class="line">    blr</div>
</div><!-- fragment --><p> This is actually worse than the previous example. Still 5 instructions with a nominal latency of 6-8 cycles. The last 3 instructions are serially dependent on both of the q-ones/q_zero generation operations. The second vsldoi in addition to vpkpx did not improve the performance.</p>
<dl class="section note"><dt>Note</dt><dd>The vec_packpx() intrinsic is is defined as endian sensitive in the <em>Power Vector Intrinsic Programming Reference</em>. So we need the __BYTE_ORDER__ conditional to generate the correct quadword magnitude for both endians.</dd></dl>
<p>Time to look more closely at the <b>vpkpx</b> operation. Perhaps we can take advantage of different handling of the <em>auxiliary channel</em> versus the <em>color channels</em>. If we can find a byte value where the low-order bit (bit-7) is '0' while the high-order five bits are 0b11111. For example the byte value 0xf8 (signed char -8) meets these requirements. The word element 0xf8f8f8f8 will pack to the halfword pixel 0x7fff. A vector of these word elements can be generated with vec_splat_s8(-8).</p>
<p>We need the q_zero constant to clear the right three word elements of the left vector and provide zeros to the right 128-bits of the 256-bits required for <b>vpkpx</b>. The q_ones constant is not required in this version. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line">test_mask128_f128exp_V2 (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//  const vui32_t expmask = CONST_VINT128_W (0x7fff0000, 0, 0, 0);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask;</div>
<div class="line">  <span class="comment">// Genrate {0xf8f8f8f8, 0, 0, 0}</span></div>
<div class="line">  expmask = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vec_splat_s8 (-8);</div>
<div class="line">  expmask = vec_sld (expmask, q_zero, 12);</div>
<div class="line">  <span class="comment">// Pack to Pixel and generate {0x7fff0000, 0, 0, 0}</span></div>
<div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vec_packpx (q_zero, expmask);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vec_packpx (expmask, q_zero);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">}</span></div>
</div><!-- fragment --><p> Which generates: </p><div class="fragment"><div class="line">0000000000001560 &lt;test_mask128_f128exp_V2&gt;:</div>
<div class="line">    vspltisw v2,0</div>
<div class="line">    vspltisb v0,-8</div>
<div class="line">    vsldoi  v0,v0,v2,12</div>
<div class="line">    vpkpx   v2,v0,v2</div>
<div class="line">    blr</div>
</div><!-- fragment --><p> This is better at 4 instructions with a nominal latency of 4-6 cycles. The first two (splat immediate) instructions are independent and can execute in parallel, but the vsldoi and vpkpx are serially dependent on the results of both instructions. The q-zero constant is likely to be shared with the generation of other quadword constants. The vec_splat_s8(-8) may be shared with the doubleword exp_naninf constant. See <a class="el" href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b" title="Generate Doubleword Quad-Precision exponent mask.">vec_mask64_f128exp()</a>.</p>
<p>The doubleword form of the exponent mask (<em>exp_naninf</em>) is used as a comparand when we need to test two Quad-precision operands for main path (both finite) or for special case handling (either is NaN/Infinity). We can use a similar technique to that above.</p>
<p>The differences are that the mask is right (versus left) justified and we are splating the mask to both doubleword. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div>
<div class="line">test_mask64_f128exp (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//const vui32_t exp_naninf = CONST_VINT128_W (0, 0x7fff, 0, 0x7fff);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Genrate {0, 0, 0, 0xf8f8f8f8}</span></div>
<div class="line">  expmask = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vec_splat_u8 (-8);</div>
<div class="line">  expmask = vec_sld (q_zero, expmask, 4);</div>
<div class="line">  <span class="comment">// Pack to Pixel and generate {0, 0x7fff, 0, 0x7fff}</span></div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) vec_packpx (expmask, expmask);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here we can skip the __BYTE_ORDER__ conditional as the vec_packpx() operands are symmetrical. The example above generates: </p><div class="fragment"><div class="line">0000000000001560 &lt;test_mask128_f128exp_V2&gt;:</div>
<div class="line">    vspltisw v2,0</div>
<div class="line">    vspltisb v0,-8</div>
<div class="line">    vsldoi  v2,v2,v0,4</div>
<div class="line">    vpkpx   v2,v2,v2</div>
<div class="line">    blr</div>
</div><!-- fragment --><p> Again 4 instructions with a nominal latency of 4-6 cycles.</p>
<p>Another set of difficult constants to generate are the small powers of 2 (greater than 8). Values 64 and 128 are used for range checks before normalization. These values do not fit into the signed 5-bit (vector splat) immediate fields available to POWER8 and earlier.</p>
<p>The sign-bit constant can be converted to the value 128 with a Vector Shift Left Double by Octet Immediate (vsldoi). For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div>
<div class="line">test_const128_f128_128(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//  const vui32_t signmask = CONST_VINT128_W(0, 0, 0, 128);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_ones = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (-1, -1, -1, -1);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask;</div>
<div class="line">  signmask = vec_sl (q_ones, q_ones);</div>
<div class="line">  <span class="keywordflow">return</span> vec_sld (q_zero, signmask, 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This runs 4 instruction with the q_zero/q_ones immediate constants subject to common subexpression evaluation and sharing. This yields a latency of 4 to 6 cycles.</p>
<p>The doubleword form can be based on the above with an additional instruction to splat the low doubleword. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div>
<div class="line">test_const64_f128_128(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//  const vui32_t dw_128 = CONST_VINT128_W(0, 0, 0, 128);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_ones = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (-1, -1, -1, -1);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask;</div>
<div class="line">  signmask = vec_sl (q_ones, q_ones);</div>
<div class="line">  signmask = vec_sld (q_zero, signmask, 1);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int64__ppc_8h.html#a5242d6311cd5ab50377cfeb2cf2ac8bf">vec_mrgald</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) signmask, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) signmask);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This works for VSX enable platforms (POWER7 and later) but bumps the latency to 6-8 cycles.</p>
<p>Another possibility is to use the Vector Count Leading Zeros instructions to generate constants for the number of bits in the element. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div>
<div class="line">test_const64_f128_64(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//  const vui32_t dw_128 = CONST_VINT128_W(0, 64, 0, 64);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <span class="comment">// Generate {64, 64} from count leading zeros of {0, 0}</span></div>
<div class="line">  <span class="keywordflow">return</span>  <a class="code" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a>((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) q_zero);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This requires only 2 instruction and the q_zero immediate constant is subject to common subexpression evaluation and sharing. This yields a latency of 2 to 4 cycles.</p>
<dl class="section note"><dt>Note</dt><dd>This technique applies to all element sizes where <b>Vector Count Leading Zeros</b> (vclz) are supported. For POWER7 and earlier support byte/halfword/word (constants 8,16, and 32). POWER8 supports Vector Count Leading Zeros Doubleword (vclzd) for constant 64. So far (as of POWER10) there is not quadword (constant 128) form, but for POWER9 we can use <b>VSX Vector Splat Immediate Byte</b> and <b>Vector Extend Sign Byte To Doubleword</b>.</dd></dl>
<p>To generate the doubleword constant 128 we can generate the constant 64 and double it. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div>
<div class="line">test_const64_f128_128(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//  const vui32_t dw_128 = CONST_VINT128_W(0, 128, 0,128);</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0, 0, 0, 0);</div>
<div class="line">  <span class="comment">// Generate {64, 64} from count leading zeros of {0, 0}</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> dw64 = <a class="code" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a>((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) q_zero);</div>
<div class="line">  <span class="comment">// Generate {128, 128}</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (dw64, dw64);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This runs 3 instruction with the q_zero immediate constant subject to common subexpression evaluation and sharing. This yields a latency of 4 to 6 cycles.</p>
<h1><a class="anchor" id="f128_examples_0_0"></a>
Examples</h1>
<p>For example: using the the classification functions for implementing the math library function sine and cosine. The Posix specification requires that special input values are processed without raising extraneous floating point exceptions and return specific floating point values in response. For example the sin() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>value</em>.</li>
<li>If the input <em>value</em> is subnormal then return <em>value</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a NaN.</li>
<li>Otherwise compute and return sin(value).</li>
</ul>
<p>The following code example uses functions from this header to address the POSIX requirements for special values input to sinf128(): </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line">test_sinf128 (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> value)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">vec_all_isnormalf128</a> (value))</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// body of taylor series.</span></div>
<div class="line">      ...</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (value))</div>
<div class="line">        result = <a class="code" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ();</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        result = value;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For another example the cos() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>1.0</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a NaN.</li>
<li>Otherwise compute and return cos(value).</li>
</ul>
<p>The following code example uses functions from this header to address the Posix requirements for special values input to cosf128(): </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line">test_cosf128 (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> value)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">vec_all_isfinitef128</a> (value))</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">vec_all_iszerof128</a> (value))</div>
<div class="line">        result = 1.0Q;</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// body of taylor series ...</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (value))</div>
<div class="line">        result = <a class="code" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ();</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        result = value;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Neither example raises floating point exceptions or sets <b>errno</b>, as appropriate for a vector math library.</p>
<h1><a class="anchor" id="f128_perf_0_0"></a>
Performance data</h1>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="add641f5a217eff45f0e836fa98613584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add641f5a217eff45f0e836fa98613584">&#9670;&nbsp;</a></span>vec_absf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_absf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute Quad-Precision. </p>
<p>Clear the sign bit of the __float128 input and return the resulting positive __float128 value.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value containing a signed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128 and a positive sign of f128. </dd></dl>

</div>
</div>
<a id="a946ffd501b32f3ec96563ab101afbfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946ffd501b32f3ec96563ab101afbfad">&#9670;&nbsp;</a></span>vec_all_isfinitef128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isfinitef128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary128 finite value has an exponent between 0x0000 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value. Using the !vec_all_eq compare conditional verify this condition and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="a66fc4e7c94d0b30bb3515931aaf723da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fc4e7c94d0b30bb3515931aaf723da">&#9670;&nbsp;</a></span>vec_all_isinff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isinff128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. Using the vec_all_eq compare conditional verifies both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="af06b73ac57985011c558670adc283e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06b73ac57985011c558670adc283e89">&#9670;&nbsp;</a></span>vec_all_isnanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnanf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is Not a Number (NaN). </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. Using the combined vec_all_eq / vec_any_gt compare conditional verify both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-14 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="afc830b382bd45dc0ff815024c1bfb26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc830b382bd45dc0ff815024c1bfb26d">&#9670;&nbsp;</a></span>vec_all_isnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary128 normal value has an exponent between 0x0001 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). Using the combined vec_all_ne compares conditional verify both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-29 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="adf1a94cccdb3f106a0e6399e2f034718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1a94cccdb3f106a0e6399e2f034718">&#9670;&nbsp;</a></span>vec_all_issubnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_issubnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is subnormal (denormal). </p>
<p>A IEEE Binary128 subnormal has an exponent of 0x0000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-29 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary128 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if the __float128 value is subnormal. </dd></dl>

</div>
</div>
<a id="a2bee3fac5a163513bae170a54ac641ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bee3fac5a163513bae170a54ac641ca">&#9670;&nbsp;</a></span>vec_all_isunorderedf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isunorderedf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if either __float128 value (vra, vrb) is NaN. </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. The sign bit is ignored. For POWER9 and later we use scalar_test_data_class(). Otherwise mask off the sign bit and compare greater than unsigned quadword to the integer equivalent of Quad-Precision infinity.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">16-25 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if either __float128 value (vra, vrb) is NaN. </dd></dl>

</div>
</div>
<a id="ac554a9d0d12fca036772aaaee5908414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac554a9d0d12fca036772aaaee5908414">&#9670;&nbsp;</a></span>vec_all_iszerof128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_iszerof128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is +-0.0. </p>
<p>A IEEE Binary128 zero has an exponent of 0x0000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if the __float128 value is +/- zero. </dd></dl>

</div>
</div>
<a id="aae0e62b9910ec833dfc20719d09e526e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0e62b9910ec833dfc20719d09e526e">&#9670;&nbsp;</a></span>vec_and_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_and_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value ANDed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="a796440333ee623aa782ef3eb5a021587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796440333ee623aa782ef3eb5a021587">&#9670;&nbsp;</a></span>vec_andc_bin128_2_vui128t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_andc_bin128_2_vui128t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector __int128 and logical AND Compliment with mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned __int128 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value ANDed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="aedfcf3adea80e0407b40c6ec0e851aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfcf3adea80e0407b40c6ec0e851aab">&#9670;&nbsp;</a></span>vec_andc_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_andc_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value ANDed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="aec73dba497304699389a168256f32d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec73dba497304699389a168256f32d29">&#9670;&nbsp;</a></span>vec_cmpeqtoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpeqtoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa == vfb, otherwise all '0's. Zeros, Infinities and NaN of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or a VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a7e3f85b4c3fe43ae58df0c72d1f29920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3f85b4c3fe43ae58df0c72d1f29920">&#9670;&nbsp;</a></span>vec_cmpequqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpequqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa == vfb, otherwise all '0's. Zeros of either sign compare equal. Infinities of the same sign compare equal. A NaN in either or both operands compare unequal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">18-30 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a83177380e5feaacb1da72c99df1c6d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83177380e5feaacb1da72c99df1c6d82">&#9670;&nbsp;</a></span>vec_cmpequzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpequzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa == vfb, otherwise all '0's. Zeros of either sign compare equal. Infinities and NaNs of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or a VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="aa40f7a997a4c92eb55203444434c070e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40f7a997a4c92eb55203444434c070e">&#9670;&nbsp;</a></span>vec_cmpgetoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgetoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than or Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt;= vfb, otherwise all '0's. Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than or equal. </dd></dl>

</div>
</div>
<a id="a870bc0f51bb3931039fec799a7c3605a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870bc0f51bb3931039fec799a7c3605a">&#9670;&nbsp;</a></span>vec_cmpgeuqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgeuqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than or Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt;= vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than or equal. </dd></dl>

</div>
</div>
<a id="a6b31351604fbca85ace1c1efc8bd6506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b31351604fbca85ace1c1efc8bd6506">&#9670;&nbsp;</a></span>vec_cmpgeuzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgeuzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than Or Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt;= vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than or equal. </dd></dl>

</div>
</div>
<a id="ae320639a93f8bc42359d9214a5e9c17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae320639a93f8bc42359d9214a5e9c17e">&#9670;&nbsp;</a></span>vec_cmpgttoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgttoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt; vfb, otherwise all '0's. Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than. </dd></dl>

</div>
</div>
<a id="a4bd8774bd68a914ac0fe3f66d16a8965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd8774bd68a914ac0fe3f66d16a8965">&#9670;&nbsp;</a></span>vec_cmpgtuqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgtuqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt; vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than. </dd></dl>

</div>
</div>
<a id="a6fbd885123cdb812bf19d2758cde202f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbd885123cdb812bf19d2758cde202f">&#9670;&nbsp;</a></span>vec_cmpgtuzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgtuzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt; vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than. </dd></dl>

</div>
</div>
<a id="a2034138934ee70e2ed25978ecb18ebc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2034138934ee70e2ed25978ecb18ebc0">&#9670;&nbsp;</a></span>vec_cmpletoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpletoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than or Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt;= vfb, otherwise all '0's. Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than or equal. </dd></dl>

</div>
</div>
<a id="a4a72e3eb8f3d96e537e940cc7583b3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a72e3eb8f3d96e537e940cc7583b3c7">&#9670;&nbsp;</a></span>vec_cmpleuqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpleuqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than or Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt;= vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than or equal. </dd></dl>

</div>
</div>
<a id="ae776b348d6c4c4a45966b451aa72072c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae776b348d6c4c4a45966b451aa72072c">&#9670;&nbsp;</a></span>vec_cmpleuzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpleuzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than or Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt;= vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than or equal. </dd></dl>

</div>
</div>
<a id="a82c672a1a0bcd3005acdfff33e70e782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c672a1a0bcd3005acdfff33e70e782">&#9670;&nbsp;</a></span>vec_cmplttoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmplttoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt; vfb, otherwise all '0's. Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than. </dd></dl>

</div>
</div>
<a id="a388307f4693587b9e49148fbe95d8da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388307f4693587b9e49148fbe95d8da5">&#9670;&nbsp;</a></span>vec_cmpltuqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpltuqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt; vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than. </dd></dl>

</div>
</div>
<a id="a1e3242d44d78984694295087f9f415e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3242d44d78984694295087f9f415e8">&#9670;&nbsp;</a></span>vec_cmpltuzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpltuzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt; vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than. </dd></dl>

</div>
</div>
<a id="aa2a23cbeeb063d30316ab3e7bdd77fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a23cbeeb063d30316ab3e7bdd77fd7">&#9670;&nbsp;</a></span>vec_cmpnetoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpnetoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Not Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa != vfb, otherwise all '0's. Zeros, Infinities and NaN of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or a VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare not equal. </dd></dl>

</div>
</div>
<a id="ab3e270eb83aa8d90a2459b0097fec944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e270eb83aa8d90a2459b0097fec944">&#9670;&nbsp;</a></span>vec_cmpneuqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpneuqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Not Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa == vfb, otherwise all '0's. Zeros of either sign compare equal. Infinities of the same sign compare equal. A NaN in either or both operands compare unequal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">18-30 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare not equal. </dd></dl>

</div>
</div>
<a id="a4ffa4be24c8714347ded9340de33e999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffa4be24c8714347ded9340de33e999">&#9670;&nbsp;</a></span>vec_cmpneuzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpneuzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Not Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa != vfb, otherwise all '0's. Zeros of either sign compare equal. Infinities and NaNs of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or a VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare not equal. </dd></dl>

</div>
</div>
<a id="ab50ec5ca14b23861c520e99f9b24a11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50ec5ca14b23861c520e99f9b24a11f">&#9670;&nbsp;</a></span>vec_cmpqp_all_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa == vfb, otherwise 0. Zeros of either sign compare equal. Infinities of the same sign compare equal. A NaN in either or both operands compare unequal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">18-30 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a01aef626eb6cd826f5874f3324dd7217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01aef626eb6cd826f5874f3324dd7217">&#9670;&nbsp;</a></span>vec_cmpqp_all_ge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_ge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than Or Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt;= vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than. </dd></dl>

</div>
</div>
<a id="a253c27dd7f4fe852a4f0c6dce45d886b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253c27dd7f4fe852a4f0c6dce45d886b">&#9670;&nbsp;</a></span>vec_cmpqp_all_gt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt; vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than. </dd></dl>

</div>
</div>
<a id="a19dca4ec505a30c52361dff6300fdba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dca4ec505a30c52361dff6300fdba7">&#9670;&nbsp;</a></span>vec_cmpqp_all_le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_le </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less Than Or Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt;= vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 less than or equal. </dd></dl>

</div>
</div>
<a id="a630f6cef8a6cdcc6dd22d3c1ece138b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630f6cef8a6cdcc6dd22d3c1ece138b7">&#9670;&nbsp;</a></span>vec_cmpqp_all_lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less Than (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt; vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 less than. </dd></dl>

</div>
</div>
<a id="a3d858ca0228e20b1e7f3bec686021fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d858ca0228e20b1e7f3bec686021fb6">&#9670;&nbsp;</a></span>vec_cmpqp_all_ne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_ne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Not-Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa == vfb, otherwise 0. Zeros of either sign compare equal. Infinities of the same sign compare equal. A NaN in either or both operands compare unequal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">18-30 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare not-equal. </dd></dl>

</div>
</div>
<a id="a44c233f656fb0ef554dfbdfb23e66954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c233f656fb0ef554dfbdfb23e66954">&#9670;&nbsp;</a></span>vec_cmpqp_all_toeq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_toeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa == vfb, otherwise 0. Zeros, Infinities and NaN of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a9a4f2f83695c9980679e8a2488ed2c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4f2f83695c9980679e8a2488ed2c55">&#9670;&nbsp;</a></span>vec_cmpqp_all_toge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_toge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than Or Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt;= vfb, otherwise 0 (false). Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than or equal. </dd></dl>

</div>
</div>
<a id="a926a5e7b9a23e7464d70d9fa6ae49dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926a5e7b9a23e7464d70d9fa6ae49dda">&#9670;&nbsp;</a></span>vec_cmpqp_all_togt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_togt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt; vfb, otherwise 0 (false). Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than. </dd></dl>

</div>
</div>
<a id="a8171c3fa6a0ecdf7b19be3df8227cbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8171c3fa6a0ecdf7b19be3df8227cbf6">&#9670;&nbsp;</a></span>vec_cmpqp_all_tole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_tole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare All Less Than Or Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt;= vfb, otherwise 0 (false). Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare less than or equal. </dd></dl>

</div>
</div>
<a id="a9d466774a32ef558f6e3ea64dd6b3cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d466774a32ef558f6e3ea64dd6b3cdd">&#9670;&nbsp;</a></span>vec_cmpqp_all_tolt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_tolt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare All Less Than (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt; vfb, otherwise 0 (false). Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare less than. </dd></dl>

</div>
</div>
<a id="ad8d272e77ab3c69808ad3efac20afb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d272e77ab3c69808ad3efac20afb36">&#9670;&nbsp;</a></span>vec_cmpqp_all_tone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_tone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Not-Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa != vfb, otherwise 0. Zeros, Infinities and NaN of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare not-equal. </dd></dl>

</div>
</div>
<a id="a4c7d9eb6f3ee5d504bddd9f4b9171bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7d9eb6f3ee5d504bddd9f4b9171bfd">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzeq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa == vfb, otherwise 0. Zeros of either sign compare equal. Infinities and NaNs of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a59a13069849f5ac559db634deab32d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a13069849f5ac559db634deab32d0e">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than Or Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt;= vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than or equal. </dd></dl>

</div>
</div>
<a id="ab0dcb860a9015e36ade2d6a9fac55c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dcb860a9015e36ade2d6a9fac55c62">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzgt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzgt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt; vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than. </dd></dl>

</div>
</div>
<a id="a75d444218effcb971289efb1e02a3dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d444218effcb971289efb1e02a3dc9">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less Than Or Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt;= vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 less than or equal. </dd></dl>

</div>
</div>
<a id="a95dde3d0847b947b1f422afef46fbfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95dde3d0847b947b1f422afef46fbfc6">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzlt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzlt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less Than (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt; vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 less than. </dd></dl>

</div>
</div>
<a id="aa147fd8c1d3da47a2786b6b745a9e1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa147fd8c1d3da47a2786b6b745a9e1a6">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Not-Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa != vfb, otherwise 0. Zeros of either sign compare equal. Infinities and NaNs of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a1e6c52eb3208f4d9ed851ee48f773d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6c52eb3208f4d9ed851ee48f773d68">&#9670;&nbsp;</a></span>vec_cmpqp_exp_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_exp_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Quad-Precision Exponents for Equal. </p>
<p>Compare the exponents of two Binary-float 128-bit values and return 1, if vfa<sup>exp</sup> == vfb<sup>exp</sup>, otherwise 0. A NaN in either or both operands compare unequal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use the VSX Scalar Compare Exponents Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 exponent compare equal. </dd></dl>

</div>
</div>
<a id="abf2d90d67cb3f605fbc9598f133b0305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2d90d67cb3f605fbc9598f133b0305">&#9670;&nbsp;</a></span>vec_cmpqp_exp_gt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_exp_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Exponents Quad-Precision for Greater Than. </p>
<p>Compare the exponents of two Binary-float 128-bit values and return 1, if vfa<sup>exp</sup> &gt; vfb<sup>exp</sup>, otherwise 0. A NaN in either or both operands returns 0.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use the VSX Scalar Compare Exponents Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 exponent compare greater than. </dd></dl>

</div>
</div>
<a id="a3eb9b92be998695424107de6a60890a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb9b92be998695424107de6a60890a8">&#9670;&nbsp;</a></span>vec_cmpqp_exp_lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_exp_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Exponents Quad-Precision for Less Than. </p>
<p>Compare the exponents of two Binary-float 128-bit values and return 1, if vfa<sup>exp</sup> &lt; vfb<sup>exp</sup>, otherwise 0. A NaN in either or both operands returns 0.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use the VSX Scalar Compare Exponents Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 exponent compare equal. </dd></dl>

</div>
</div>
<a id="a3014214c103453a34372cc52e6d79073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3014214c103453a34372cc52e6d79073">&#9670;&nbsp;</a></span>vec_cmpqp_exp_unordered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_exp_unordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Exponents Quad-Precision for Unordered. </p>
<p>Compare two Binary-float 128-bit values and return 1, if either or both operands are NaN, otherwise 0.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use the VSX Scalar Compare Exponents Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 unordered. </dd></dl>

</div>
</div>
<a id="a173efeafba080313d50e8b018c26c611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173efeafba080313d50e8b018c26c611">&#9670;&nbsp;</a></span>vec_const128_f128_128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_const128_f128_128 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Quadword constant 128. </p>
<p>Load immediate the quadword constant vui32_t {0, 0, 0, 128}.</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b" title="Generate Doubleword Quad-Precision exponent mask.">vec_mask64_f128exp()</a> for rationale.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>The 128-bit const vui32_t {0, 0, 0, 128}. </dd></dl>

</div>
</div>
<a id="a380ba36beb77c11beb7050698a62fd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380ba36beb77c11beb7050698a62fd23">&#9670;&nbsp;</a></span>vec_const64_f128_128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_const64_f128_128 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate doubleword splat constant 128. </p>
<p>Load immediate the quadword constant vui32_t {0, 0, 0, 128}.</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b" title="Generate Doubleword Quad-Precision exponent mask.">vec_mask64_f128exp()</a> for rationale.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>The 128-bit const vui64_t {128, 128}. </dd></dl>

</div>
</div>
<a id="a0a30726ccfb216e4d2e1ede3854ab96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a30726ccfb216e4d2e1ede3854ab96b">&#9670;&nbsp;</a></span>vec_const_huge_valf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_huge_valf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a positive infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>const __float128 positive infinity. </dd></dl>

</div>
</div>
<a id="a9c68f73f69c4776bb054d42915e7103d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c68f73f69c4776bb054d42915e7103d">&#9670;&nbsp;</a></span>vec_const_inff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_inff128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a positive infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 positive infinity. </dd></dl>

</div>
</div>
<a id="af7fb1013dfcf633156cd7f855a11fb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fb1013dfcf633156cd7f855a11fb56">&#9670;&nbsp;</a></span>vec_const_nanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_nanf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a quiet NaN. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 quiet NaN. </dd></dl>

</div>
</div>
<a id="aac806c62ebaae6ab8faca87794cb917c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac806c62ebaae6ab8faca87794cb917c">&#9670;&nbsp;</a></span>vec_const_nansf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_nansf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a signaling NaN. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 signaling NaN. </dd></dl>

</div>
</div>
<a id="adfb73eac40698921735bad8ac4ce560e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb73eac40698921735bad8ac4ce560e">&#9670;&nbsp;</a></span>vec_copysignf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_copysignf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the sign bit from f128x and merge with the magnitude from f128y. The merged result is returned as a __float128 value. </p>
<dl class="section note"><dt>Note</dt><dd>This operation was patterned after the intrinsic vec_cpsgn (altivec.h) introduced for POWER7 and VSX. It turns out the original (GCC 4.9) compiler implementation reversed the operands and does not match the PowerISA or the Vector Intrinsic Programming Reference manuals. Subsequent compilers and PVECLIB implementations replicated this (operand order) error. This has now been reported as bug against the compilers, which are in the process of applying fixes and distributing updates. This version of PVECLIB is updated to match the Vector Intrinsic Programming Reference.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128x</td><td>a __float128 value containing the sign bit. </td></tr>
    <tr><td class="paramname">f128y</td><td>a __float128 value containing the magnitude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128y and the sign of f128x. </dd></dl>

</div>
</div>
<a id="ad1668ff13922ca04059f1844a7a1464f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1668ff13922ca04059f1844a7a1464f">&#9670;&nbsp;</a></span>vec_isfinitef128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isfinitef128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary128 finite value has an exponent between 0x0000 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value. Using the vec_cmpeq conditional to generate the predicate mask for NaN / Inf and then invert this for the finite condition. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="aebd9706acb775392282cfe4d4e3a03aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd9706acb775392282cfe4d4e3a03aa">&#9670;&nbsp;</a></span>vec_isinf_signf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_isinf_signf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true (nonzero) value if the __float128 value is infinity. If infinity, indicate the sign as +1 for positive infinity and -1 for negative infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. Using the vec_all_eq compare conditional verifies both conditions. A subsequent vec_any_gt checks the sign bit and set the result appropriately. The sign bit is ignored.</p>
<p>This sequence avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12-32 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3-12 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 if not infinity and +1/-1 otherwise. </dd></dl>

</div>
</div>
<a id="a94f9c7429c2ebd9b9f32ad6e98689ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f9c7429c2ebd9b9f32ad6e98689ebb">&#9670;&nbsp;</a></span>vec_isinff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isinff128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a 128-bit vector boolean true if the __float128 value is infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s.. </dd></dl>

</div>
</div>
<a id="a11c410994f958a6b4ac9583878a55a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c410994f958a6b4ac9583878a55a72">&#9670;&nbsp;</a></span>vec_isnanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isnanf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN). </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. The sign bit is ignored. For POWER9 and later we use scalar_test_data_class(). Otherwise mask off the sign bit and compare greater than unsigned quadword to the integer equivalent of Quad-Precision infinity.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="aa25185c83b69f6af3f3d9399199c8a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25185c83b69f6af3f3d9399199c8a57">&#9670;&nbsp;</a></span>vec_isnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary128 normal value has an exponent between 0x0001 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="a9670e4655a9c7888c80343780cd7abf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9670e4655a9c7888c80343780cd7abf9">&#9670;&nbsp;</a></span>vec_issubnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_issubnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true value, if the __float128 value is subnormal (denormal). </p>
<p>A IEEE Binary128 subnormal has an exponent of 0x0000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">16-25 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="aec9148af78b075f253c9848945df6135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9148af78b075f253c9848945df6135">&#9670;&nbsp;</a></span>vec_isunorderedf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isunorderedf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true value, if either __float128 value (vra, vrb) is NaN. </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. The sign bit is ignored. For POWER9 and later we use scalar_test_data_class(). Otherwise mask off the sign bit and compare greater than unsigned quadword to the integer equivalent of Quad-Precision infinity.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">16-25 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean _int128. </dd></dl>

</div>
</div>
<a id="a598a822d22b02ba0d2c2a1095a4e700d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598a822d22b02ba0d2c2a1095a4e700d">&#9670;&nbsp;</a></span>vec_iszerof128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_iszerof128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true value, if the value that is +-0.0. </p>
<p>A IEEE Binary64 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a2ba9852d8733f6861d799a10027e1e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba9852d8733f6861d799a10027e1e95">&#9670;&nbsp;</a></span>vec_mask128_f128Cbit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mask128_f128Cbit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Quadword C-bit mask Immediate. </p>
<p>Load immediate the quadword constant vui32_t {0x00020000, 0, 0, 0}.</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b" title="Generate Doubleword Quad-Precision exponent mask.">vec_mask64_f128exp()</a> for rationale.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-4 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>The 128-bit mask vui32_t {0x00020000, 0, 0, 0}. </dd></dl>

</div>
</div>
<a id="a553edc28189515110f96a6ab6531927f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553edc28189515110f96a6ab6531927f">&#9670;&nbsp;</a></span>vec_mask128_f128exp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mask128_f128exp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Quadword Quad-Precision exponent mask. </p>
<p>Load immediate the quadword constant vui32_t {0x7fff0000, 0, 0, 0}.</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b" title="Generate Doubleword Quad-Precision exponent mask.">vec_mask64_f128exp()</a> for rationale.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>The 128-bit mask vui32_t {0x7fff0000, 0, 0, 0}. </dd></dl>

</div>
</div>
<a id="a29201a75ecd86b135dbb013dbd2ced75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29201a75ecd86b135dbb013dbd2ced75">&#9670;&nbsp;</a></span>vec_mask128_f128Lbit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mask128_f128Lbit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Quadword L-bit mask Immediate. </p>
<p>Load immediate the quadword constant vui32_t {0x00010000, 0, 0, 0}.</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b" title="Generate Doubleword Quad-Precision exponent mask.">vec_mask64_f128exp()</a> for rationale.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-4 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>The 128-bit mask vui32_t {0x00010000, 0, 0, 0}. </dd></dl>

</div>
</div>
<a id="a5751b5c36a7a3d73c81abd7759e51594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5751b5c36a7a3d73c81abd7759e51594">&#9670;&nbsp;</a></span>vec_mask128_f128mag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mask128_f128mag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Quadword Quad-Precision magnitude mask. </p>
<p>Load immediate the quadword constant vui32_t {0x7fffffff, -1, -1, -1}.</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b" title="Generate Doubleword Quad-Precision exponent mask.">vec_mask64_f128exp()</a> for rationale.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-4 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>The 128-bit mask vui32_t {0x7fffffff, -1, -1, -1}. </dd></dl>

</div>
</div>
<a id="a619b1beb77d75c62ea9913e527bb0cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619b1beb77d75c62ea9913e527bb0cf1">&#9670;&nbsp;</a></span>vec_mask128_f128Qbit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mask128_f128Qbit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Quadword QNaN-bit mask Immediate. </p>
<p>Load immediate the quadword constant vui32_t {0x00008000, 0, 0, 0}.</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b" title="Generate Doubleword Quad-Precision exponent mask.">vec_mask64_f128exp()</a> for rationale.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>The 128-bit mask vui32_t {0x00008000, 0, 0, 0}. </dd></dl>

</div>
</div>
<a id="a42ca6322cc3885264ca350a66b4e1bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ca6322cc3885264ca350a66b4e1bff">&#9670;&nbsp;</a></span>vec_mask128_f128sig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mask128_f128sig </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Quadword Quad-Precision significand mask. </p>
<p>Load immediate the quadword constant vui32_t {0x0000ffff, -1, -1, -1}.</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b" title="Generate Doubleword Quad-Precision exponent mask.">vec_mask64_f128exp()</a> for rationale.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-4 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>The 128-bit mask vui32_t {0x0000ffff, -1, -1, -1}. </dd></dl>

</div>
</div>
<a id="ac94c7ddb75a8fc5f543e65e31e03f1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94c7ddb75a8fc5f543e65e31e03f1c1">&#9670;&nbsp;</a></span>vec_mask128_f128sign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mask128_f128sign </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Quadword Quad-Precision Sign-bit mask. </p>
<p>Load immediate the quadword constant vui32_t {0x80000000, -1, -1, -1}.</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="vec__f128__ppc_8h.html#ae1ef1a77f575bd319d6cf90e1b81765b" title="Generate Doubleword Quad-Precision exponent mask.">vec_mask64_f128exp()</a> for rationale.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>The 128-bit mask vui32_t {0x80000000, -1, -1, -1}. </dd></dl>

</div>
</div>
<a id="ae1ef1a77f575bd319d6cf90e1b81765b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ef1a77f575bd319d6cf90e1b81765b">&#9670;&nbsp;</a></span>vec_mask64_f128exp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mask64_f128exp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Doubleword Quad-Precision exponent mask. </p>
<p>Load the quadword constant vui32_t {0, 0x7fff, 0, 0x7fff}.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler, left to its own devices, will load vector constants from the read-only data section (.rodata). This requires (at least) 5 cycles assuming a L1 cache hit. This does not include any instructions needed for address calculation, alignment, or endian fix-up (another 4-8 cycles). A L1 cache miss adds more (7-27) cycles to retrieve data from the L2/L3 cache levels. A short sequence, using only vector register and immediate operands, eliminates load associated address calculation and cache misses. This provides better and more repeatable performance.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The consistent use of q_zero/q_ones constants across these operations allows the compiler to apply common subexpression elimination (CSE) optimizations.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The 128-bit mask vui32_t {0x00010000, 0, 0, 0}. </dd></dl>

</div>
</div>
<a id="a1dff4f515dc0b37a4411401a44aa5157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dff4f515dc0b37a4411401a44aa5157">&#9670;&nbsp;</a></span>vec_mrgh_bin128_2_vui64t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mrgh_bin128_2_vui64t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge High and Transfer function from a pair of __binary128 scalars to a vector long long int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should generate a single xxmrghd for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">vfb</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The high doublewords of vfa/vfb value merged into a vector long long int. </dd></dl>

</div>
</div>
<a id="afc2ac713dcb43499b47410c02b6c854c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2ac713dcb43499b47410c02b6c854c">&#9670;&nbsp;</a></span>vec_mrgl_bin128_2_vui64t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mrgl_bin128_2_vui64t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge Low and Transfer function from a pair of __binary128 scalars to a vector long long int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should generate a single xxmrgld for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">vfb</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The low doublewords of vfa/vfb value merged into a vector long long int. </dd></dl>

</div>
</div>
<a id="a7c2297dc22a6a3120491e1721648c0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2297dc22a6a3120491e1721648c0e7">&#9670;&nbsp;</a></span>vec_nabsf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_nabsf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negative Absolute value Quad-Precision. </p>
<p>Unconditionally set sign bit of the __float128 input and return the resulting positive __float128 value.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value containing a signed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128 and a negative sign. </dd></dl>

</div>
</div>
<a id="a3323b6fb0b379a21f3dd70f7f204bd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3323b6fb0b379a21f3dd70f7f204bd2a">&#9670;&nbsp;</a></span>vec_negf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_negf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate the sign bit of a __float128 input and return the resulting __float128 value. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value containing a signed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128 and the opposite sign of f128. </dd></dl>

</div>
</div>
<a id="a3612e915d9043c23eeaac6eb5e129312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3612e915d9043c23eeaac6eb5e129312">&#9670;&nbsp;</a></span>vec_or_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_or_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector int and logical OR with mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value ORed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="a2843ee28bf45b6e7589f2b1d073a2187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2843ee28bf45b6e7589f2b1d073a2187">&#9670;&nbsp;</a></span>vec_sel_bin128_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_sel_bin128_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">vfb</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector bool __int128 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit of vfa or vfb depending on the mask. </dd></dl>

</div>
</div>
<a id="a47637906e95a7c94cffc093bc2e57dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47637906e95a7c94cffc093bc2e57dbf">&#9670;&nbsp;</a></span>vec_self128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_self128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">vfb</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector bool __int128 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit of vfa or vfb depending on the mask. </dd></dl>

</div>
</div>
<a id="a4d5b388cfc9af26418bdd4ec8e4e6f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5b388cfc9af26418bdd4ec8e4e6f73">&#9670;&nbsp;</a></span>vec_setb_qp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_setb_qp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Set Bool from Quadword Floating-point. </p>
<p>If the quadword's sign bit is '1' then return a vector bool __int128 that is all '1's. Otherwise return all '0's.</p>
<p>The resulting mask can be used in vector masking and select operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation will set the sign mask regardless of data class. For POWER9 the Scalar Test Data Class instructions copy the sign bit to CR bit 0 which distinguishes between +/- NaN.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4 - 6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a 128-bit vector treated a signed __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector bool of all '1's if the sign bit is '1'. Otherwise all '0's. </dd></dl>

</div>
</div>
<a id="a4ca7749d334c2a2c17a4d2a98b5bf755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca7749d334c2a2c17a4d2a98b5bf755">&#9670;&nbsp;</a></span>vec_signbitf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_signbitf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return int boolean true if the __float128 value is negative (sign bit is '1'). </p>
<p>For POWER9 use scalar_test_neg (a special case of scalar_test_data_class). For POWER8 and earlier, vec_and with a signmask and then vec_all_eq compare with that mask generates the boolean of the sign bit.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-10 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a int boolean indicating the sign bit. </dd></dl>

</div>
</div>
<a id="aec6e44a75847d3d3e5611b89eed71c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6e44a75847d3d3e5611b89eed71c0a">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui128t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_xfer_bin128_2_vui128t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector __int128. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector __int128. </dd></dl>

</div>
</div>
<a id="aff0629194f4f63bb083c271844459072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0629194f4f63bb083c271844459072">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui16t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_xfer_bin128_2_vui16t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector short int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector short int. </dd></dl>

</div>
</div>
<a id="a8043c2c5ac35d2b0a8bd8f33779c91a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8043c2c5ac35d2b0a8bd8f33779c91a6">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_xfer_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="acac5809f5f651e45113de8410664f2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac5809f5f651e45113de8410664f2c7">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui64t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xfer_bin128_2_vui64t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector long long int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector long long int. </dd></dl>

</div>
</div>
<a id="a57dc5b9171d5ce3d49f0f12795659c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57dc5b9171d5ce3d49f0f12795659c1a">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui8t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_xfer_bin128_2_vui8t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector char. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector char. </dd></dl>

</div>
</div>
<a id="a91b99b632646aaca91de6834e2b1da26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b99b632646aaca91de6834e2b1da26">&#9670;&nbsp;</a></span>vec_xfer_vui128t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui128t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned __int128 to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned __int128 value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="a3dec5c23a659b2fca1c219fe783f88eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dec5c23a659b2fca1c219fe783f88eb">&#9670;&nbsp;</a></span>vec_xfer_vui16t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui16t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned short to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned short value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="af0596ab318ba6d1ec5e7ed40871255a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0596ab318ba6d1ec5e7ed40871255a9">&#9670;&nbsp;</a></span>vec_xfer_vui32t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui32t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned int to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="ae8002c29875a226d11ec57a42b5b3955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8002c29875a226d11ec57a42b5b3955">&#9670;&nbsp;</a></span>vec_xfer_vui64t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui64t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned long long to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned long long value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="a047b7dc5b55b2d13e2fd826c63872ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047b7dc5b55b2d13e2fd826c63872ea9">&#9670;&nbsp;</a></span>vec_xfer_vui8t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui8t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned char to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned char value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="a7de75d3d010fe5ac7310322e2abea122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de75d3d010fe5ac7310322e2abea122">&#9670;&nbsp;</a></span>vec_xor_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_xor_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector int and logical Exclusive OR with mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value XORed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="aa3bff7954c22b5d85f976f046290f37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bff7954c22b5d85f976f046290f37b">&#9670;&nbsp;</a></span>vec_xsaddqpo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xsaddqpo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VSX Scalar Add Quad-Precision using round to Odd. </p>
<p>The quad-precision element of vectors vfa and vfb are added to produce the quad-precision result. The rounding mode is round to odd.</p>
<p>For POWER9 use the xsaddqpo instruction. For POWER8 use this soft-float implementation using vector instruction generated by PVECLIB operations. For POWER7 and earlier us the compilers soft-float implementation.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes the xsmulqpo instruction, the implementation may use that.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">54-71 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">1/12 cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector unsigned __int128 value. </dd></dl>

</div>
</div>
<a id="a1a8ceb0eb2c47892371a12502d14f170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8ceb0eb2c47892371a12502d14f170">&#9670;&nbsp;</a></span>vec_xscvdpqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xscvdpqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>f64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VSX Scalar Convert Double-Precision to Quad-Precision format. </p>
<p>The left most double-precision element of vector f64 is converted to quad-precision format.</p>
<p>For POWER9 use the xscvdpqp instruction. For POWER8 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to Signaling NaN and setting the FPSCR. However if the hardware target includes the xscvdpqp instruction, the implementation may use that.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f64</td><td>a vector double. The left most element is converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value. </dd></dl>

</div>
</div>
<a id="a5e3c778a7c90b6e6a2d89cd5a1012061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3c778a7c90b6e6a2d89cd5a1012061">&#9670;&nbsp;</a></span>vec_xscvqpdpo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_xscvqpdpo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VSX Scalar Convert with round Quad-Precision to Double-Precision (using round to odd). </p>
<p>The quad-precision element of vector f128 is converted to double-precision. The Floating point value is rounded to odd before conversion. The result is placed in doubleword element 0 while element 1 is set to zero.</p>
<p>For POWER9 use the xscvqpdpo instruction. For POWER8 and earlier use vector instructions generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes the xscvqpdpo instruction, the implementation may use that.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector unsigned long long value. </dd></dl>

</div>
</div>
<a id="a73ad56c509ea22f26fb2d47217bc5e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ad56c509ea22f26fb2d47217bc5e51">&#9670;&nbsp;</a></span>vec_xscvqpudz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xscvqpudz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VSX Scalar Convert with round to zero Quad-Precision to Unsigned doubleword. </p>
<p>The quad-precision element of vector f128 is converted to an unsigned doubleword integer. The Floating point value is rounded toward zero before conversion. The result is placed in element 0 while element 1 is set to zero.</p>
<p>For POWER9 use the xscvqpudz instruction. For POWER8 and earlier use vector instructions generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes the xscvqpudz instruction, the implementation may use that.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector unsigned long long value. </dd></dl>

</div>
</div>
<a id="aaf9d4ad5a60e9ffaa0ca16d29f90c092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9d4ad5a60e9ffaa0ca16d29f90c092">&#9670;&nbsp;</a></span>vec_xscvqpuqz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_xscvqpuqz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VSX Scalar Convert with round to zero Quad-Precision to Unsigned Quadword. </p>
<p>The quad-precision element of vector f128 is converted to an unsigned quadword integer. The Floating point value is rounded toward zero before conversion.</p>
<p>For POWER10 use the xscvqpuqz instruction. For POWER9 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes the xscvqpuqz instruction, the implementation may use that.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector unsigned __int128 value. </dd></dl>

</div>
</div>
<a id="acc58cb3be351ea2bf163aeb8dbb5709c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc58cb3be351ea2bf163aeb8dbb5709c">&#9670;&nbsp;</a></span>vec_xscvsdqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xscvsdqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>int64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VSX Scalar Convert Signed-Doubleword to Quad-Precision format. </p>
<p>The left most signed doubleword element of vector int64 is converted to quad-precision format.</p>
<p>For POWER9 use the xscvsdqp instruction. For POWER8 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>At this point we are not trying to comply with PowerISA by setting any FPSCR bits associated with Quad-Precision convert. If such is required, FR and/or FI can be set using the Move To FPSCR Bit 0 (mtfsb0) instruction.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int64</td><td>a vector signed long long. The left most element is converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value. </dd></dl>

</div>
</div>
<a id="a27bfd64d7eefd8e84619950f19f827ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bfd64d7eefd8e84619950f19f827ba">&#9670;&nbsp;</a></span>vec_xscvsqqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xscvsqqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a>&#160;</td>
          <td class="paramname"><em>int128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VSX Scalar Convert Signed-Quadword to Quad-Precision format. </p>
<p>The signed quadword element of vector int128 is converted to quad-precision format. If the conversion is not exact the default rounding mode is "Round to Nearest Even".</p>
<p>For POWER10 use the xscvuqqp instruction. POWER9 only supports doubleword converts so use a combination of two xscvudqp and xsmaddqp instructions. For POWER8 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>The POWER8 implementation ignores the hardware rounding mode <b>FPSCR<sub>RN</sub></b>.</dd>
<dd>
At this point we are not trying to comply with PowerISA by setting any FPSCR bits associated with Quad-Precision convert. If such is required, FPFR, FR and FI can be set using the Move To FPSCR Bit 0/1 (mtfsb[0|1]) instruction.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">44-53 </td><td class="markdownTableBodyLeft">1/13cycles  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int128</td><td>a vector signed __int128 which is converted to QP format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value. </dd></dl>

</div>
</div>
<a id="a1eadadc05fe1873deadaef16926f6c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eadadc05fe1873deadaef16926f6c86">&#9670;&nbsp;</a></span>vec_xscvudqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xscvudqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>int64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VSX Scalar Convert Unsigned-Doubleword to Quad-Precision format. </p>
<p>The left most unsigned doubleword element of vector int64 is converted to quad-precision format.</p>
<p>For POWER9 use the xscvudqp instruction. For POWER8 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>At this point we are not trying to comply with PowerISA by setting any FPSCR bits associated with Quad-Precision convert. If such is required, FR and/or FI can be set using the Move To FPSCR Bit 0 (mtfsb0) instruction.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int64</td><td>a vector unsigned long long. The left most element is converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value. </dd></dl>

</div>
</div>
<a id="a24b1f22552fd177d10af1dbc0f43d5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b1f22552fd177d10af1dbc0f43d5f8">&#9670;&nbsp;</a></span>vec_xscvuqqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xscvuqqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>int128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VSX Scalar Convert Unsigned-Quadword to Quad-Precision format. </p>
<p>The unsigned quadword element of vector int128 is converted to quad-precision format. If the conversion is not exact the default rounding mode is "Round to Nearest Even".</p>
<p>For POWER10 use the xscvuqqp instruction. POWER9 only supports doubleword converts so use a combination of two xscvudqp and xsmaddqp instructions. For POWER8 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>The POWER8 implementation ignores the hardware rounding mode <b>FPSCR<sub>RN</sub></b>.</dd>
<dd>
At this point we are not trying to comply with PowerISA by setting any FPSCR bits associated with Quad-Precision convert. If such is required, FPFR, FR and FI can be set using the Move To FPSCR Bit 0/1 (mtfsb[0|1]) instruction.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">38-47 </td><td class="markdownTableBodyLeft">1/13cycles  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int128</td><td>a vector unsigned __int128 which is converted to QP format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value. </dd></dl>

</div>
</div>
<a id="af95c675ceebc0627c777d2c7e2daef0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95c675ceebc0627c777d2c7e2daef0b">&#9670;&nbsp;</a></span>vec_xsiexpqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xsiexpqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar Insert Exponent Quad-Precision. </p>
<p>Merge the sign (bit 0) and significand (bits 16:127) from sig with the 15-bit exponent from exp (bits 49:63). The exponent is moved to bits 1:15 of the final result. The result is returned as a Quad_precision floating point value.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xsiexpqp instruction, This instruction requires a POWER9-enabled compiler targeting -mcpu=power9 and is not available for older compilers nor POWER8 and earlier. We can't use the built-in scalar_insert_exp because it requires scalar (GPR) inputs and vec_insert_exp is not defined for Quad-Precision. We expect (in context) inputs will be in VRs. This operation provides implementations for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-8 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>vector __int128 containing the Sign Bit and 112-bit significand. </td></tr>
    <tr><td class="paramname">exp</td><td>vector unsigned long long element 0 containing the 15-bit exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value where the exponent bits (1:15) of sig are replaced from bits 49:63 of exp. </dd></dl>

</div>
</div>
<a id="af62c779fc5de06a954a55d9c0ddd3baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62c779fc5de06a954a55d9c0ddd3baf">&#9670;&nbsp;</a></span>vec_xsmulqpo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xsmulqpo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VSX Scalar Multiply Quad-Precision using round to Odd. </p>
<p>The quad-precision element of vectors vfa and vfb are multiplied to produce the quad-precision result. The rounding mode is round to odd.</p>
<p>For POWER9 use the xsmulqpo instruction. For POWER8 use this soft-float implementation using vector instruction generated by PVECLIB operations. For POWER7 and earlier is the compilers soft-float implementation.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes the xsmulqpo instruction, the implementation may use that.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">78-84 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">24 </td><td class="markdownTableBodyLeft">1/12 cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector unsigned __int128 value. </dd></dl>

</div>
</div>
<a id="a5f8e71a4362e87704c5172b751ecbc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8e71a4362e87704c5172b751ecbc6f">&#9670;&nbsp;</a></span>vec_xssubqpo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xssubqpo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VSX Scalar Subtract Quad-Precision using round to Odd. </p>
<p>The quad-precision element of vector vfb is subtracted from vfa to produce the quad-precision result. The rounding mode is round to odd.</p>
<p>For POWER9 use the xssubqpo instruction. For POWER8 use this soft-float implementation using vector instruction generated by PVECLIB operations. For POWER7 and earlier us the compilers soft-float implementation.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes the xsmulqpo instruction, the implementation may use that.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">51-70 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">1/12 cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector unsigned __int128 value. </dd></dl>

</div>
</div>
<a id="a3d78e42d9cc58491fa46149bf5798167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d78e42d9cc58491fa46149bf5798167">&#9670;&nbsp;</a></span>vec_xsxexpqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xsxexpqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar Extract Exponent Quad-Precision. </p>
<p>Extract the quad-precision exponent (bits 1:15) and right justify it to (bits 49:63 of) doubleword 0 of the result vector. The result is returned as vector long long integer value.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xsxexpqp instruction. This instruction requires a POWER9-enabled compiler targeting -mcpu=power9 and is not available for older compilers nor POWER8 and earlier. We can't use the built-in scalar_extract_exp because it returns scalar (GPR) results and vec_extract_exp is not defined for Quad-Precision. We expect (in context) results are needed in VRs. This operation provides implementations for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-10 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>__binary128 scalar value in a vector register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long long element 0 containing the 15-bit exponent </dd></dl>

</div>
</div>
<a id="ab1eb10beac182e936d7e49d491c34fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1eb10beac182e936d7e49d491c34fe0">&#9670;&nbsp;</a></span>vec_xsxsigqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_xsxsigqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar Extract Significand Quad-Precision. </p>
<p>Extract the quad-precision significand (bits 16:127) and restore the implied (hidden) bit (bit 15) if the quad-precition value is normal (not zero, subnormal, Infinity or NaN). The result is returned as vector __int128 integer value with up to 113 bits of significance.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xsxsigqp instruction. This instruction requires a POWER9-enabled compiler targeting -mcpu=power9 and is not available for older compilers nor POWER8 and earlier. We can't use the built-in scalar_extract_sig because it returns scalar (GPR) results and vec_extract_sig is not defined for Quad-Precision. We expect (in context) results are needed in VRs. This operation provides implementations for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12-14 </td><td class="markdownTableBodyLeft">1/6cycles  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>__binary128 scalar value in a vector register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector __int128 containing the significand. </dd></dl>

</div>
</div>
<a id="a93a77b974dcb698d916828f5986ea9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a77b974dcb698d916828f5986ea9cd">&#9670;&nbsp;</a></span>vec_xxxexpqpp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xxxexpqpp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Extract Exponent Quad-Precision Pair. </p>
<p>Extract the quad-precision exponent (bits 1:15), from each member of the QP Pair, and right justify the exponents to (bits 49:63 of) doublewords 0/1 of the result vector. The result is returned as vector long long integer value.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 instruction sequence xsxexpqp/xsxexpqp/xxmrghd.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-8 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>first __binary128 scalar value in a vector register. </td></tr>
    <tr><td class="paramname">vfb</td><td>first __binary128 scalar value in a vector register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long long elements 0/1 containing 15-bit exponents from vfa/vfb. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="avec__int128__ppc_8h_html_a7f9ebc5ad32b151a3e08136d51aad4dc"><div class="ttname"><a href="vec__int128__ppc_8h.html#a7f9ebc5ad32b151a3e08136d51aad4dc">vec_cmpltuq</a></div><div class="ttdeci">static vb128_t vec_cmpltuq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare Less Than Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:3406</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a871f91423e5154739ae225c82620d6b4"><div class="ttname"><a href="vec__int64__ppc_8h.html#a871f91423e5154739ae225c82620d6b4">vec_cmpud_all_le</a></div><div class="ttdeci">static int vec_cmpud_all_le(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare all Less than equal Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:2287</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_ad4ce43dcbc14fb34623d5ece8073b86e"><div class="ttname"><a href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a></div><div class="ttdeci">static vb128_t vec_cmpgtuq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare Greater Than Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:3227</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_af18b98d2d73f1afbc439e1407c78f305"><div class="ttname"><a href="vec__int128__ppc_8h.html#af18b98d2d73f1afbc439e1407c78f305">vec_addecuq</a></div><div class="ttdeci">static vui128_t vec_addecuq(vui128_t a, vui128_t b, vui128_t ci)</div><div class="ttdoc">Vector Add Extended &amp; write Carry Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2622</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_af0596ab318ba6d1ec5e7ed40871255a9"><div class="ttname"><a href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a></div><div class="ttdeci">static __binary128 vec_xfer_vui32t_2_bin128(vui32_t f128)</div><div class="ttdoc">Transfer a vector unsigned int to __binary128 scalar.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4580</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a6bafb410404d4f1e10a99263b57d1df0"><div class="ttname"><a href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a></div><div class="ttdeci">static vui128_t vec_subuqm(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Subtract Unsigned Quadword Modulo.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:7439</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_ac263f88b177c2f3db909ca92e41e3ff9"><div class="ttname"><a href="vec__int128__ppc_8h.html#ac263f88b177c2f3db909ca92e41e3ff9">vec_negsq</a></div><div class="ttdeci">static vi128_t vec_negsq(vi128_t int128)</div><div class="ttdoc">Vector Negate Signed Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6234</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_acb534c11a544d9e0b61acdecbb62adaa"><div class="ttname"><a href="vec__f64__ppc_8h.html#acb534c11a544d9e0b61acdecbb62adaa">vec_xvxexpdp</a></div><div class="ttdeci">static vui64_t vec_xvxexpdp(vf64_t vrb)</div><div class="ttdoc">Vector Extract Exponent Double-Precision.</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:1713</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a3975205947785b1745a791ef12256e9a"><div class="ttname"><a href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a></div><div class="ttdeci">#define VEC_BYTE_H</div><div class="ttdoc">Element index for highest order byte.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:350</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_ae8002c29875a226d11ec57a42b5b3955"><div class="ttname"><a href="vec__f128__ppc_8h.html#ae8002c29875a226d11ec57a42b5b3955">vec_xfer_vui64t_2_bin128</a></div><div class="ttdeci">static __binary128 vec_xfer_vui64t_2_bin128(vui64_t f128)</div><div class="ttdoc">Transfer a vector unsigned long long to __binary128 scalar.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4603</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a16cdf519bbbf190c311bd27d3e254208"><div class="ttname"><a href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div><div class="ttdeci">__vector __bool __int128 vb128_t</div><div class="ttdoc">vector of one 128-bit bool __int128 element.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:240</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a8ba40be93339359793ef776e1d5d7577"><div class="ttname"><a href="vec__int128__ppc_8h.html#a8ba40be93339359793ef776e1d5d7577">vec_sldq</a></div><div class="ttdeci">static vui128_t vec_sldq(vui128_t vrw, vui128_t vrx, vui128_t vrb)</div><div class="ttdoc">Vector Shift Left Double Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6613</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a24b1f22552fd177d10af1dbc0f43d5f8"><div class="ttname"><a href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8">vec_xscvuqqp</a></div><div class="ttdeci">static __binary128 vec_xscvuqqp(vui128_t int128)</div><div class="ttdoc">VSX Scalar Convert Unsigned-Quadword to Quad-Precision format.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:9271</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a55dcb361982b9da13b02373d720d6c7d"><div class="ttname"><a href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a></div><div class="ttdeci">static int vec_cmpud_all_lt(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare all Less than Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:2311</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_ad24220d787ac863b7911a303da17d1a0"><div class="ttname"><a href="vec__int64__ppc_8h.html#ad24220d787ac863b7911a303da17d1a0">vec_minud</a></div><div class="ttdeci">static vui64_t vec_minud(vui64_t vra, vui64_t vrb)</div><div class="ttdoc">Vector Minimum Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:2663</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_af95c675ceebc0627c777d2c7e2daef0b"><div class="ttname"><a href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a></div><div class="ttdeci">static __binary128 vec_xsiexpqp(vui128_t sig, vui64_t exp)</div><div class="ttdoc">Scalar Insert Exponent Quad-Precision.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:9716</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_ae4520a89b9b5a292a3e647a6d5b712ad"><div class="ttname"><a href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a></div><div class="ttdeci">#define CONST_VINT128_W(__w0, __w1, __w2, __w3)</div><div class="ttdoc">Arrange word elements of a unsigned int initializer in high-&gt;low order. May require an explicit cast.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:304</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_af4ffb9244d1aa4482b683d35c3544194"><div class="ttname"><a href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a></div><div class="ttdeci">#define CONST_VINT64_DW(__dw0, __dw1)</div><div class="ttdoc">Arrange elements of dword initializer in high-&gt;low order.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:295</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_afb47075b07673afbf78f8c60298f3712"><div class="ttname"><a href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="ttdeci">__vector unsigned short vui16_t</div><div class="ttdoc">vector of 16-bit unsigned short elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:204</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a2c2c01f3aa165fedba47600f87067768"><div class="ttname"><a href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a></div><div class="ttdeci">static int vec_cmpuq_all_eq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare all Equal Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:3804</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a3b2bbf9f23490ccca3bdc08bc1dc7831"><div class="ttname"><a href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a></div><div class="ttdeci">__vector __int128 vi128_t</div><div class="ttdoc">vector of one 128-bit signed __int128 element.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:235</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a8a7660b170e71ec58ee95a79cd1c47d5"><div class="ttname"><a href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a></div><div class="ttdeci">static int vec_cmpud_all_eq(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare all Equal Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:2193</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a11c410994f958a6b4ac9583878a55a72"><div class="ttname"><a href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">vec_isnanf128</a></div><div class="ttdeci">static vb128_t vec_isnanf128(__binary128 f128)</div><div class="ttdoc">Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:7666</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a946ffd501b32f3ec96563ab101afbfad"><div class="ttname"><a href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">vec_all_isfinitef128</a></div><div class="ttdeci">static int vec_all_isfinitef128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is Finite (Not NaN nor Inf).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4691</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a443a43ae34ab3b78564d2a8277503cac"><div class="ttname"><a href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div><div class="ttdeci">vf128_t __binary128</div><div class="ttdoc">Define __binary128 if not defined by the compiler. Same as __float128 for PPC.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:3680</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a52a773b6353c69a546bdc2e8686a50ec"><div class="ttname"><a href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div><div class="ttdeci">__vector unsigned long long vui64_t</div><div class="ttdoc">vector of 64-bit unsigned long long elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:208</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a671e86d52ad53adce6a558476c7ffc0c"><div class="ttname"><a href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a></div><div class="ttdeci">static vui64_t vec_splatd(vui64_t vra, const int ctl)</div><div class="ttdoc">Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of ...</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:3382</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_aed458e4755a6589049b936cf9f24f6f8"><div class="ttname"><a href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a></div><div class="ttdeci">__vector unsigned char vui8_t</div><div class="ttdoc">vector of 8-bit unsigned char elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:202</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_af13f19199e5872ecaf88742043f26642"><div class="ttname"><a href="vec__int64__ppc_8h.html#af13f19199e5872ecaf88742043f26642">vec_cmpud_all_gt</a></div><div class="ttdeci">static int vec_cmpud_all_gt(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare all Greater Than Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:2255</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_aaf9d4ad5a60e9ffaa0ca16d29f90c092"><div class="ttname"><a href="vec__f128__ppc_8h.html#aaf9d4ad5a60e9ffaa0ca16d29f90c092">vec_xscvqpuqz</a></div><div class="ttdeci">static vui128_t vec_xscvqpuqz(__binary128 f128)</div><div class="ttdoc">VSX Scalar Convert with round to zero Quad-Precision to Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:8891</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a0b7aee3c81538f5537680b610d934500"><div class="ttname"><a href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a></div><div class="ttdeci">static vui64_t vec_subudm(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Subtract Unsigned Doubleword Modulo.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:3746</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a0fb3ddc8b334ae25119a02e749884290"><div class="ttname"><a href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a></div><div class="ttdeci">static vui64_t vec_vsld(vui64_t vra, vui64_t vrb)</div><div class="ttdoc">Vector Shift Left Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:4238</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_ab1eb10beac182e936d7e49d491c34fe0"><div class="ttname"><a href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">vec_xsxsigqp</a></div><div class="ttdeci">static vui128_t vec_xsxsigqp(__binary128 f128)</div><div class="ttdoc">Scalar Extract Significand Quad-Precision.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:9814</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_ac05c640c6a42770cb95466ff4a2d903c"><div class="ttname"><a href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a></div><div class="ttdeci">static vui128_t vec_srqi(vui128_t vra, const unsigned int shb)</div><div class="ttdoc">Vector Shift Right Quadword Immediate.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:7154</div></div>
<div class="ttc" id="avec__int16__ppc_8h_html_a292973c417034f4b8813765b63ca03c2"><div class="ttname"><a href="vec__int16__ppc_8h.html#a292973c417034f4b8813765b63ca03c2">vec_srhi</a></div><div class="ttdeci">static vui16_t vec_srhi(vui16_t vra, const unsigned int shb)</div><div class="ttdoc">Vector Shift Right Halfword Immediate.</div><div class="ttdef"><b>Definition:</b> vec_int16_ppc.h:1093</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a066cc120c198773a2f8dfd17480b7a49"><div class="ttname"><a href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49">vec_clzq</a></div><div class="ttdeci">static vui128_t vec_clzq(vui128_t vra)</div><div class="ttdoc">Vector Count Leading Zeros Quadword for unsigned __int128 elements.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2918</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_aee5c5b2998ef105b4c6f39739748ffa8"><div class="ttname"><a href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a></div><div class="ttdeci">static vui128_t vec_muludq(vui128_t *mulu, vui128_t a, vui128_t b)</div><div class="ttdoc">Vector Multiply Unsigned Double Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:5734</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a440a601539df9f00dfe3669b06ea5766"><div class="ttname"><a href="vec__int64__ppc_8h.html#a440a601539df9f00dfe3669b06ea5766">vec_cmpud_any_eq</a></div><div class="ttdeci">static int vec_cmpud_any_eq(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare any Equal Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:2365</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_ad7aaadba249ce46c4c94f78df1020da3"><div class="ttname"><a href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a></div><div class="ttdeci">static vui128_t vec_addcuq(vui128_t a, vui128_t b)</div><div class="ttdoc">Vector Add &amp; write Carry Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2568</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a2b7f505ebca731aa6fdc7433f82c0c6d"><div class="ttname"><a href="vec__int128__ppc_8h.html#a2b7f505ebca731aa6fdc7433f82c0c6d">vec_cmpuq_all_le</a></div><div class="ttdeci">static int vec_cmpuq_all_le(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare any Less Than or Equal Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:3936</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_aaf7a8e92d8ba681dac3d2ec3259c0820"><div class="ttname"><a href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a></div><div class="ttdeci">__vector unsigned __int128 vui128_t</div><div class="ttdoc">vector of one 128-bit unsigned __int128 element.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:237</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_aee93592cb008b78c17e85d1eaa3419e1"><div class="ttname"><a href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a></div><div class="ttdeci">__vector __bool long long vb64_t</div><div class="ttdoc">vector of 64-bit bool long long elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:230</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_ab63ac21e968bf199eadd72f94b653905"><div class="ttname"><a href="vec__f64__ppc_8h.html#ab63ac21e968bf199eadd72f94b653905">vec_all_isnormalf64</a></div><div class="ttdeci">static int vec_all_isnormalf64(vf64_t vf64)</div><div class="ttdoc">Return true if all 2x64-bit vector double values are normal (Not NaN, Inf, denormal,...</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:388</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_a27becc842e7270c96c54a00d4a292d54"><div class="ttname"><a href="vec__f64__ppc_8h.html#a27becc842e7270c96c54a00d4a292d54">vec_all_iszerof64</a></div><div class="ttdeci">static int vec_all_iszerof64(vf64_t vf64)</div><div class="ttdoc">Return true if all 2x64-bit vector double values are +-0.0.</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:480</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a03cdec54548bd95e04d4835d96b1bea4"><div class="ttname"><a href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a></div><div class="ttdeci">static vui64_t vec_clzd(vui64_t vra)</div><div class="ttdoc">Vector Count Leading Zeros Doubleword for unsigned long long elements.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:1313</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a82d83d78ff2330205a8d74741b34a1be"><div class="ttname"><a href="vec__int128__ppc_8h.html#a82d83d78ff2330205a8d74741b34a1be">vec_cmpltsq</a></div><div class="ttdeci">static vb128_t vec_cmpltsq(vi128_t vra, vi128_t vrb)</div><div class="ttdoc">Vector Compare Less Than Signed Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:3357</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a66fc4e7c94d0b30bb3515931aaf723da"><div class="ttname"><a href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a></div><div class="ttdeci">static int vec_all_isinff128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is infinity.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4723</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_af74036e39e72e0f3c29706d30fbb96d1"><div class="ttname"><a href="vec__int128__ppc_8h.html#af74036e39e72e0f3c29706d30fbb96d1">vec_setb_cyq</a></div><div class="ttdeci">static vb128_t vec_setb_cyq(vui128_t vcy)</div><div class="ttdoc">Vector Set Bool from Quadword Carry.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6509</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a0c3abdfe41178c152e0a2130c20476ff"><div class="ttname"><a href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a></div><div class="ttdeci">__vector long long vi64_t</div><div class="ttdoc">vector of 64-bit signed long long elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:217</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_aedfcf3adea80e0407b40c6ec0e851aab"><div class="ttname"><a href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a></div><div class="ttdeci">static vui32_t vec_andc_bin128_2_vui32t(__binary128 f128, vui32_t mask)</div><div class="ttdoc">Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4085</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a4d5b388cfc9af26418bdd4ec8e4e6f73"><div class="ttname"><a href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73">vec_setb_qp</a></div><div class="ttdeci">static vb128_t vec_setb_qp(__binary128 f128)</div><div class="ttdoc">Vector Set Bool from Quadword Floating-point.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:7953</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_ac93dc5ed8bb3501470cf70c5cb5796a9"><div class="ttname"><a href="vec__int128__ppc_8h.html#ac93dc5ed8bb3501470cf70c5cb5796a9">vec_cmpuq_all_gt</a></div><div class="ttdeci">static int vec_cmpuq_all_gt(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare any Greater Than Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:3892</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_af8b42004c11b01c7606d8d6e299e8107"><div class="ttname"><a href="vec__f64__ppc_8h.html#af8b42004c11b01c7606d8d6e299e8107">vec_xvxsigdp</a></div><div class="ttdeci">static vui64_t vec_xvxsigdp(vf64_t vrb)</div><div class="ttdoc">Vector Extract Significand Double-Precision.</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:1762</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_af21d01bb19f0ea8605d8c37035837802"><div class="ttname"><a href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802">vec_setb_sq</a></div><div class="ttdeci">static vb128_t vec_setb_sq(vi128_t vra)</div><div class="ttdoc">Vector Set Bool from Signed Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6576</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_a6bdfdf013a97ccd6dc20b1447f81d498"><div class="ttname"><a href="vec__f64__ppc_8h.html#a6bdfdf013a97ccd6dc20b1447f81d498">vec_all_isfinitef64</a></div><div class="ttdeci">static int vec_all_isfinitef64(vf64_t vf64)</div><div class="ttdoc">Return true if all 2x64-bit vector double values are Finite (Not NaN nor Inf).</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:253</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a9d8b8de825b673b53cd50458dfc6efa8"><div class="ttname"><a href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a></div><div class="ttdeci">#define VEC_DW_L</div><div class="ttdoc">Element index for low order dword.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:324</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a4390e79e503b741605914fe63d35c5bf"><div class="ttname"><a href="vec__int64__ppc_8h.html#a4390e79e503b741605914fe63d35c5bf">vec_selud</a></div><div class="ttdeci">static vui64_t vec_selud(vui64_t vra, vui64_t vrb, vb64_t vrc)</div><div class="ttdoc">Vector Select Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:3354</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a27bfd64d7eefd8e84619950f19f827ba"><div class="ttname"><a href="vec__f128__ppc_8h.html#a27bfd64d7eefd8e84619950f19f827ba">vec_xscvsqqp</a></div><div class="ttdeci">static __binary128 vec_xscvsqqp(vi128_t int128)</div><div class="ttdoc">VSX Scalar Convert Signed-Quadword to Quad-Precision format.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:9130</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a9c68f73f69c4776bb054d42915e7103d"><div class="ttname"><a href="vec__f128__ppc_8h.html#a9c68f73f69c4776bb054d42915e7103d">vec_const_inff128</a></div><div class="ttdeci">static __binary128 vec_const_inff128()</div><div class="ttdoc">return a positive infinity.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4988</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a7197cd5c6e946211f2718b5e8464cdc0"><div class="ttname"><a href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0">vec_cmpequq</a></div><div class="ttdeci">static vb128_t vec_cmpequq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare Equal Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:3043</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_aa03d831ec09612229357e2ea34383eaf"><div class="ttname"><a href="vec__int64__ppc_8h.html#aa03d831ec09612229357e2ea34383eaf">vec_cmpud_any_ne</a></div><div class="ttdeci">static int vec_cmpud_any_ne(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare any Not Equal Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:2508</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a5242d6311cd5ab50377cfeb2cf2ac8bf"><div class="ttname"><a href="vec__int64__ppc_8h.html#a5242d6311cd5ab50377cfeb2cf2ac8bf">vec_mrgald</a></div><div class="ttdeci">static vui64_t vec_mrgald(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Merge Algebraic Low Doublewords.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:2736</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a3323b6fb0b379a21f3dd70f7f204bd2a"><div class="ttname"><a href="vec__f128__ppc_8h.html#a3323b6fb0b379a21f3dd70f7f204bd2a">vec_negf128</a></div><div class="ttdeci">static __binary128 vec_negf128(__binary128 f128)</div><div class="ttdoc">Negate the sign bit of a __float128 input and return the resulting __float128 value.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:7886</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_acd5bafec6c1c15b0336551e82d1169d4"><div class="ttname"><a href="vec__int64__ppc_8h.html#acd5bafec6c1c15b0336551e82d1169d4">vec_mrgahd</a></div><div class="ttdeci">static vui64_t vec_mrgahd(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Merge Algebraic High Doublewords.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:2710</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a2ff4a776536870e01b7c9e454586544b"><div class="ttname"><a href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div><div class="ttdeci">__vector unsigned int vui32_t</div><div class="ttdoc">vector of 32-bit unsigned int elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:206</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_ac23cdb84882a03083962b1679b622ea4"><div class="ttname"><a href="vec__int64__ppc_8h.html#ac23cdb84882a03083962b1679b622ea4">vec_cmpltud</a></div><div class="ttdeci">static vb64_t vec_cmpltud(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare less Than Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:1771</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_adfb73eac40698921735bad8ac4ce560e"><div class="ttname"><a href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e">vec_copysignf128</a></div><div class="ttdeci">static __binary128 vec_copysignf128(__binary128 f128x, __binary128 f128y)</div><div class="ttdoc">Copy the sign bit from f128x and merge with the magnitude from f128y. The merged result is returned a...</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4950</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_aaa33904ec4de42f54cceab34adb303c5"><div class="ttname"><a href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a></div><div class="ttdeci">static vui128_t vec_sldqi(vui128_t vrw, vui128_t vrx, const unsigned int shb)</div><div class="ttdoc">Vector Shift Left Double Quadword Immediate.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6649</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_aae0e62b9910ec833dfc20719d09e526e"><div class="ttname"><a href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a></div><div class="ttdeci">static vui32_t vec_and_bin128_2_vui32t(__binary128 f128, vui32_t mask)</div><div class="ttdoc">Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4040</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a539de2a4426a84102471306acc571ce8"><div class="ttname"><a href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a></div><div class="ttdeci">static vui128_t vec_adduqm(vui128_t a, vui128_t b)</div><div class="ttdoc">Vector Add Unsigned Quadword Modulo.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2739</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_aa3bff7954c22b5d85f976f046290f37b"><div class="ttname"><a href="vec__f128__ppc_8h.html#aa3bff7954c22b5d85f976f046290f37b">vec_xsaddqpo</a></div><div class="ttdeci">static __binary128 vec_xsaddqpo(__binary128 vfa, __binary128 vfb)</div><div class="ttdoc">VSX Scalar Add Quad-Precision using round to Odd.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:8035</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a6264e6ca42126726b0e490754dde0db7"><div class="ttname"><a href="vec__int64__ppc_8h.html#a6264e6ca42126726b0e490754dde0db7">vec_cmpud_all_ge</a></div><div class="ttdeci">static int vec_cmpud_all_ge(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare all Greater Than or Equal Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:2223</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a3d78e42d9cc58491fa46149bf5798167"><div class="ttname"><a href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a></div><div class="ttdeci">static vui64_t vec_xsxexpqp(__binary128 f128)</div><div class="ttdoc">Scalar Extract Exponent Quad-Precision.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:9765</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_aeb17e3bb401eff58cf827c9fc5f281bf"><div class="ttname"><a href="vec__int64__ppc_8h.html#aeb17e3bb401eff58cf827c9fc5f281bf">vec_cmpgtud</a></div><div class="ttdeci">static vb64_t vec_cmpgtud(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare Greater Than Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:1622</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a28052c1907d1f733c9dda8a48039e546"><div class="ttname"><a href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a></div><div class="ttdeci">static vui64_t vec_addudm(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Add Unsigned Doubleword Modulo.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:1261</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_afc830b382bd45dc0ff815024c1bfb26d"><div class="ttname"><a href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">vec_all_isnormalf128</a></div><div class="ttdeci">static int vec_all_isnormalf128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4807</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a1fffe85d6f314f935fcd1fabf0ebe389"><div class="ttname"><a href="vec__int64__ppc_8h.html#a1fffe85d6f314f935fcd1fabf0ebe389">vec_cmpsd_all_gt</a></div><div class="ttdeci">static int vec_cmpsd_all_gt(vi64_t a, vi64_t b)</div><div class="ttdoc">Vector Compare all Greater Than Signed Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:1909</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a0edd172a5656b842d6586c5078284942"><div class="ttname"><a href="vec__int128__ppc_8h.html#a0edd172a5656b842d6586c5078284942">vec_srq</a></div><div class="ttdeci">static vui128_t vec_srq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Shift Right Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:7114</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a91b99b632646aaca91de6834e2b1da26"><div class="ttname"><a href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">vec_xfer_vui128t_2_bin128</a></div><div class="ttdeci">static __binary128 vec_xfer_vui128t_2_bin128(vui128_t f128)</div><div class="ttdoc">Transfer a vector unsigned __int128 to __binary128 scalar.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4626</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a9ecd14e25b4de7ce7bb657e0e2f492bc"><div class="ttname"><a href="vec__int64__ppc_8h.html#a9ecd14e25b4de7ce7bb657e0e2f492bc">vec_cmpsd_all_lt</a></div><div class="ttdeci">static int vec_cmpsd_all_lt(vi64_t a, vi64_t b)</div><div class="ttdoc">Vector Compare all Less than Signed Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:1965</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a47637906e95a7c94cffc093bc2e57dbf"><div class="ttname"><a href="vec__f128__ppc_8h.html#a47637906e95a7c94cffc093bc2e57dbf">vec_self128</a></div><div class="ttdeci">static __binary128 vec_self128(__binary128 vfa, __binary128 vfb, vb128_t mask)</div><div class="ttdoc">Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binar...</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:7926</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a42d2b39711c06106097ef869a20420b6"><div class="ttname"><a href="vec__int64__ppc_8h.html#a42d2b39711c06106097ef869a20420b6">vec_swapd</a></div><div class="ttdeci">static vui64_t vec_swapd(vui64_t vra)</div><div class="ttdoc">Vector doubleword swap. Exchange the high and low doubleword elements of a vector.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:3789</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_af7fb1013dfcf633156cd7f855a11fb56"><div class="ttname"><a href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a></div><div class="ttdeci">static __binary128 vec_const_nanf128()</div><div class="ttdoc">return a quiet NaN.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:5000</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_af06b73ac57985011c558670adc283e89"><div class="ttname"><a href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a></div><div class="ttdeci">static int vec_all_isnanf128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is Not a Number (NaN).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4763</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a070fe972995f3954362835f5b72e5ff6"><div class="ttname"><a href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a></div><div class="ttdeci">static vui128_t vec_slqi(vui128_t vra, const unsigned int shb)</div><div class="ttdoc">Vector Shift Left Quadword Immediate.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6748</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a49fe2c36fca9911ab99a1f8abb53f0ff"><div class="ttname"><a href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a></div><div class="ttdeci">static vui128_t vec_slq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Shift Left Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6707</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a560aef2acfdf1db1cf14848ec6cb0c1c"><div class="ttname"><a href="vec__int64__ppc_8h.html#a560aef2acfdf1db1cf14848ec6cb0c1c">vec_cmpequd</a></div><div class="ttdeci">static vb64_t vec_cmpequd(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare Equal Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:1451</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_adb2bc7bad8fc5c335244ac6f877f3c8f"><div class="ttname"><a href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a></div><div class="ttdeci">#define VEC_DW_H</div><div class="ttdoc">Element index for high order dword.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:322</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_ac554a9d0d12fca036772aaaee5908414"><div class="ttname"><a href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">vec_all_iszerof128</a></div><div class="ttdeci">static int vec_all_iszerof128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is +-0.0.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:4906</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a7a067a69e501014d68d003ac4e11d9fd"><div class="ttname"><a href="vec__common__ppc_8h.html#a7a067a69e501014d68d003ac4e11d9fd">VEC_HW_H</a></div><div class="ttdeci">#define VEC_HW_H</div><div class="ttdoc">Element index for highest order hword.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:338</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a5949bfddc954f2a50922abfbd32176cd"><div class="ttname"><a href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a></div><div class="ttdeci">static vui128_t vec_seluq(vui128_t vra, vui128_t vrb, vb128_t vrc)</div><div class="ttdoc">Vector Select Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6482</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 10 2022 14:57:44 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
