<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_f128_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_f128_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over Quad-Precision floating point elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__common__ppc_8h_source.html">pveclib/vec_common_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__int128__ppc_8h_source.html">pveclib/vec_int128_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__f64__ppc_8h_source.html">pveclib/vec_f64_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__f128__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union____VF__128.html">__VF_128</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union used to transfer 128-bit data between vector and __float128 types.  <a href="union____VF__128.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5c0751a2b64a9a560e9a964294f63166"><td class="memItemLeft" align="right" valign="top"><a id="a5c0751a2b64a9a560e9a964294f63166"></a>
typedef <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a></td></tr>
<tr class="memdesc:a5c0751a2b64a9a560e9a964294f63166"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 128-bit binary128 element. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a5c0751a2b64a9a560e9a964294f63166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="memItemLeft" align="right" valign="top"><a id="a5f89d266b82d1a8f300348cf99b9ae3f"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5f89d266b82d1a8f300348cf99b9ae3f">__Float128</a></td></tr>
<tr class="memdesc:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __Float128 if not defined by the compiler. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443a43ae34ab3b78564d2a8277503cac"><td class="memItemLeft" align="right" valign="top"><a id="a443a43ae34ab3b78564d2a8277503cac"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></td></tr>
<tr class="memdesc:a443a43ae34ab3b78564d2a8277503cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __binary128 if not defined by the compiler. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a443a43ae34ab3b78564d2a8277503cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af2270bedc312f7d99c0605358cd28c"><td class="memItemLeft" align="right" valign="top"><a id="a4af2270bedc312f7d99c0605358cd28c"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4af2270bedc312f7d99c0605358cd28c">__float128</a></td></tr>
<tr class="memdesc:a4af2270bedc312f7d99c0605358cd28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __float128 if not defined by the compiler. Same as __float128 for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a4af2270bedc312f7d99c0605358cd28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55019fe6dc8271e91613db7b1ae96721"><td class="memItemLeft" align="right" valign="top"><a id="a55019fe6dc8271e91613db7b1ae96721"></a>
typedef long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a55019fe6dc8271e91613db7b1ae96721">__IBM128</a></td></tr>
<tr class="memdesc:a55019fe6dc8271e91613db7b1ae96721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __IBM128 if not defined by the compiler. Same as old long double for PPC. <br  />
 <br /></td></tr>
<tr class="separator:a55019fe6dc8271e91613db7b1ae96721"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2843ee28bf45b6e7589f2b1d073a2187"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a2843ee28bf45b6e7589f2b1d073a2187">vec_sel_bin128_2_bin128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb, <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> mask)</td></tr>
<tr class="memdesc:a2843ee28bf45b6e7589f2b1d073a2187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value.  <a href="vec__f128__ppc_8h.html#a2843ee28bf45b6e7589f2b1d073a2187">More...</a><br /></td></tr>
<tr class="separator:a2843ee28bf45b6e7589f2b1d073a2187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e62b9910ec833dfc20719d09e526e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mask)</td></tr>
<tr class="memdesc:aae0e62b9910ec833dfc20719d09e526e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask.  <a href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">More...</a><br /></td></tr>
<tr class="separator:aae0e62b9910ec833dfc20719d09e526e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfcf3adea80e0407b40c6ec0e851aab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mask)</td></tr>
<tr class="memdesc:aedfcf3adea80e0407b40c6ec0e851aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask.  <a href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">More...</a><br /></td></tr>
<tr class="separator:aedfcf3adea80e0407b40c6ec0e851aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de75d3d010fe5ac7310322e2abea122"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a7de75d3d010fe5ac7310322e2abea122">vec_xor_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mask)</td></tr>
<tr class="memdesc:a7de75d3d010fe5ac7310322e2abea122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask.  <a href="vec__f128__ppc_8h.html#a7de75d3d010fe5ac7310322e2abea122">More...</a><br /></td></tr>
<tr class="separator:a7de75d3d010fe5ac7310322e2abea122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796440333ee623aa782ef3eb5a021587"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a796440333ee623aa782ef3eb5a021587">vec_andc_bin128_2_vui128t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128, <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> mask)</td></tr>
<tr class="memdesc:a796440333ee623aa782ef3eb5a021587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a quadword from a __binary128 scalar to a vector __int128 and logical AND Compliment with mask.  <a href="vec__f128__ppc_8h.html#a796440333ee623aa782ef3eb5a021587">More...</a><br /></td></tr>
<tr class="separator:a796440333ee623aa782ef3eb5a021587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a57dc5b9171d5ce3d49f0f12795659c1a">vec_xfer_bin128_2_vui8t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector char.  <a href="vec__f128__ppc_8h.html#a57dc5b9171d5ce3d49f0f12795659c1a">More...</a><br /></td></tr>
<tr class="separator:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0629194f4f63bb083c271844459072"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aff0629194f4f63bb083c271844459072">vec_xfer_bin128_2_vui16t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aff0629194f4f63bb083c271844459072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector short int.  <a href="vec__f128__ppc_8h.html#aff0629194f4f63bb083c271844459072">More...</a><br /></td></tr>
<tr class="separator:aff0629194f4f63bb083c271844459072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a8043c2c5ac35d2b0a8bd8f33779c91a6">vec_xfer_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector int.  <a href="vec__f128__ppc_8h.html#a8043c2c5ac35d2b0a8bd8f33779c91a6">More...</a><br /></td></tr>
<tr class="separator:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac5809f5f651e45113de8410664f2c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#acac5809f5f651e45113de8410664f2c7">vec_xfer_bin128_2_vui64t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:acac5809f5f651e45113de8410664f2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector long long int.  <a href="vec__f128__ppc_8h.html#acac5809f5f651e45113de8410664f2c7">More...</a><br /></td></tr>
<tr class="separator:acac5809f5f651e45113de8410664f2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6e44a75847d3d3e5611b89eed71c0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aec6e44a75847d3d3e5611b89eed71c0a">vec_xfer_bin128_2_vui128t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aec6e44a75847d3d3e5611b89eed71c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector __int128.  <a href="vec__f128__ppc_8h.html#aec6e44a75847d3d3e5611b89eed71c0a">More...</a><br /></td></tr>
<tr class="separator:aec6e44a75847d3d3e5611b89eed71c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a047b7dc5b55b2d13e2fd826c63872ea9">vec_xfer_vui8t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> f128)</td></tr>
<tr class="memdesc:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned char to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#a047b7dc5b55b2d13e2fd826c63872ea9">More...</a><br /></td></tr>
<tr class="separator:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dec5c23a659b2fca1c219fe783f88eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3dec5c23a659b2fca1c219fe783f88eb">vec_xfer_vui16t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> f128)</td></tr>
<tr class="memdesc:a3dec5c23a659b2fca1c219fe783f88eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned short to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#a3dec5c23a659b2fca1c219fe783f88eb">More...</a><br /></td></tr>
<tr class="separator:a3dec5c23a659b2fca1c219fe783f88eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0596ab318ba6d1ec5e7ed40871255a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> f128)</td></tr>
<tr class="memdesc:af0596ab318ba6d1ec5e7ed40871255a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned int to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">More...</a><br /></td></tr>
<tr class="separator:af0596ab318ba6d1ec5e7ed40871255a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8002c29875a226d11ec57a42b5b3955"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ae8002c29875a226d11ec57a42b5b3955">vec_xfer_vui64t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> f128)</td></tr>
<tr class="memdesc:ae8002c29875a226d11ec57a42b5b3955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned long long to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#ae8002c29875a226d11ec57a42b5b3955">More...</a><br /></td></tr>
<tr class="separator:ae8002c29875a226d11ec57a42b5b3955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b99b632646aaca91de6834e2b1da26"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">vec_xfer_vui128t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> f128)</td></tr>
<tr class="memdesc:a91b99b632646aaca91de6834e2b1da26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned __int128 to __binary128 scalar.  <a href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">More...</a><br /></td></tr>
<tr class="separator:a91b99b632646aaca91de6834e2b1da26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add641f5a217eff45f0e836fa98613584"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#add641f5a217eff45f0e836fa98613584">vec_absf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:add641f5a217eff45f0e836fa98613584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute Quad-Precision.  <a href="vec__f128__ppc_8h.html#add641f5a217eff45f0e836fa98613584">More...</a><br /></td></tr>
<tr class="separator:add641f5a217eff45f0e836fa98613584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946ffd501b32f3ec96563ab101afbfad"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">vec_all_isfinitef128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a946ffd501b32f3ec96563ab101afbfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is Finite (Not NaN nor Inf).  <a href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">More...</a><br /></td></tr>
<tr class="separator:a946ffd501b32f3ec96563ab101afbfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fc4e7c94d0b30bb3515931aaf723da"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a66fc4e7c94d0b30bb3515931aaf723da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is infinity.  <a href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">More...</a><br /></td></tr>
<tr class="separator:a66fc4e7c94d0b30bb3515931aaf723da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06b73ac57985011c558670adc283e89"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:af06b73ac57985011c558670adc283e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is Not a Number (NaN).  <a href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">More...</a><br /></td></tr>
<tr class="separator:af06b73ac57985011c558670adc283e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc830b382bd45dc0ff815024c1bfb26d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">vec_all_isnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:afc830b382bd45dc0ff815024c1bfb26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">More...</a><br /></td></tr>
<tr class="separator:afc830b382bd45dc0ff815024c1bfb26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1a94cccdb3f106a0e6399e2f034718"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#adf1a94cccdb3f106a0e6399e2f034718">vec_all_issubnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:adf1a94cccdb3f106a0e6399e2f034718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is subnormal (denormal).  <a href="vec__f128__ppc_8h.html#adf1a94cccdb3f106a0e6399e2f034718">More...</a><br /></td></tr>
<tr class="separator:adf1a94cccdb3f106a0e6399e2f034718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bee3fac5a163513bae170a54ac641ca"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a2bee3fac5a163513bae170a54ac641ca">vec_all_isunorderedf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a2bee3fac5a163513bae170a54ac641ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if either __float128 value (vra, vrb) is NaN.  <a href="vec__f128__ppc_8h.html#a2bee3fac5a163513bae170a54ac641ca">More...</a><br /></td></tr>
<tr class="separator:a2bee3fac5a163513bae170a54ac641ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac554a9d0d12fca036772aaaee5908414"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">vec_all_iszerof128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:ac554a9d0d12fca036772aaaee5908414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is +-0.0.  <a href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">More...</a><br /></td></tr>
<tr class="separator:ac554a9d0d12fca036772aaaee5908414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb73eac40698921735bad8ac4ce560e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e">vec_copysignf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128x, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128y)</td></tr>
<tr class="memdesc:adfb73eac40698921735bad8ac4ce560e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign bit from f128y and merge with the magnitude from f128x. The merged result is returned as a __float128 value.  <a href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e">More...</a><br /></td></tr>
<tr class="separator:adfb73eac40698921735bad8ac4ce560e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a0a30726ccfb216e4d2e1ede3854ab96b">vec_const_huge_valf128</a> ()</td></tr>
<tr class="memdesc:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a positive infinity.  <a href="vec__f128__ppc_8h.html#a0a30726ccfb216e4d2e1ede3854ab96b">More...</a><br /></td></tr>
<tr class="separator:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c68f73f69c4776bb054d42915e7103d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9c68f73f69c4776bb054d42915e7103d">vec_const_inff128</a> ()</td></tr>
<tr class="memdesc:a9c68f73f69c4776bb054d42915e7103d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a positive infinity.  <a href="vec__f128__ppc_8h.html#a9c68f73f69c4776bb054d42915e7103d">More...</a><br /></td></tr>
<tr class="separator:a9c68f73f69c4776bb054d42915e7103d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fb1013dfcf633156cd7f855a11fb56"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ()</td></tr>
<tr class="memdesc:af7fb1013dfcf633156cd7f855a11fb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a quiet NaN.  <a href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">More...</a><br /></td></tr>
<tr class="separator:af7fb1013dfcf633156cd7f855a11fb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac806c62ebaae6ab8faca87794cb917c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aac806c62ebaae6ab8faca87794cb917c">vec_const_nansf128</a> ()</td></tr>
<tr class="memdesc:aac806c62ebaae6ab8faca87794cb917c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a signaling NaN.  <a href="vec__f128__ppc_8h.html#aac806c62ebaae6ab8faca87794cb917c">More...</a><br /></td></tr>
<tr class="separator:aac806c62ebaae6ab8faca87794cb917c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec73dba497304699389a168256f32d29"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aec73dba497304699389a168256f32d29">vec_cmpeqtoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aec73dba497304699389a168256f32d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#aec73dba497304699389a168256f32d29">More...</a><br /></td></tr>
<tr class="separator:aec73dba497304699389a168256f32d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83177380e5feaacb1da72c99df1c6d82"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a83177380e5feaacb1da72c99df1c6d82">vec_cmpequzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a83177380e5feaacb1da72c99df1c6d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a83177380e5feaacb1da72c99df1c6d82">More...</a><br /></td></tr>
<tr class="separator:a83177380e5feaacb1da72c99df1c6d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3f85b4c3fe43ae58df0c72d1f29920"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a7e3f85b4c3fe43ae58df0c72d1f29920">vec_cmpequqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a7e3f85b4c3fe43ae58df0c72d1f29920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a7e3f85b4c3fe43ae58df0c72d1f29920">More...</a><br /></td></tr>
<tr class="separator:a7e3f85b4c3fe43ae58df0c72d1f29920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40f7a997a4c92eb55203444434c070e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aa40f7a997a4c92eb55203444434c070e">vec_cmpgetoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aa40f7a997a4c92eb55203444434c070e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than or Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#aa40f7a997a4c92eb55203444434c070e">More...</a><br /></td></tr>
<tr class="separator:aa40f7a997a4c92eb55203444434c070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b31351604fbca85ace1c1efc8bd6506"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a6b31351604fbca85ace1c1efc8bd6506">vec_cmpgeuzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a6b31351604fbca85ace1c1efc8bd6506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than Or Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a6b31351604fbca85ace1c1efc8bd6506">More...</a><br /></td></tr>
<tr class="separator:a6b31351604fbca85ace1c1efc8bd6506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870bc0f51bb3931039fec799a7c3605a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a870bc0f51bb3931039fec799a7c3605a">vec_cmpgeuqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a870bc0f51bb3931039fec799a7c3605a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than or Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a870bc0f51bb3931039fec799a7c3605a">More...</a><br /></td></tr>
<tr class="separator:a870bc0f51bb3931039fec799a7c3605a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320639a93f8bc42359d9214a5e9c17e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ae320639a93f8bc42359d9214a5e9c17e">vec_cmpgttoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ae320639a93f8bc42359d9214a5e9c17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ae320639a93f8bc42359d9214a5e9c17e">More...</a><br /></td></tr>
<tr class="separator:ae320639a93f8bc42359d9214a5e9c17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbd885123cdb812bf19d2758cde202f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a6fbd885123cdb812bf19d2758cde202f">vec_cmpgtuzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a6fbd885123cdb812bf19d2758cde202f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a6fbd885123cdb812bf19d2758cde202f">More...</a><br /></td></tr>
<tr class="separator:a6fbd885123cdb812bf19d2758cde202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd8774bd68a914ac0fe3f66d16a8965"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4bd8774bd68a914ac0fe3f66d16a8965">vec_cmpgtuqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a4bd8774bd68a914ac0fe3f66d16a8965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a4bd8774bd68a914ac0fe3f66d16a8965">More...</a><br /></td></tr>
<tr class="separator:a4bd8774bd68a914ac0fe3f66d16a8965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2034138934ee70e2ed25978ecb18ebc0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a2034138934ee70e2ed25978ecb18ebc0">vec_cmpletoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a2034138934ee70e2ed25978ecb18ebc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than or Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a2034138934ee70e2ed25978ecb18ebc0">More...</a><br /></td></tr>
<tr class="separator:a2034138934ee70e2ed25978ecb18ebc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae776b348d6c4c4a45966b451aa72072c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ae776b348d6c4c4a45966b451aa72072c">vec_cmpleuzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ae776b348d6c4c4a45966b451aa72072c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than or Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ae776b348d6c4c4a45966b451aa72072c">More...</a><br /></td></tr>
<tr class="separator:ae776b348d6c4c4a45966b451aa72072c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a72e3eb8f3d96e537e940cc7583b3c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4a72e3eb8f3d96e537e940cc7583b3c7">vec_cmpleuqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a4a72e3eb8f3d96e537e940cc7583b3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than or Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a4a72e3eb8f3d96e537e940cc7583b3c7">More...</a><br /></td></tr>
<tr class="separator:a4a72e3eb8f3d96e537e940cc7583b3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c672a1a0bcd3005acdfff33e70e782"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a82c672a1a0bcd3005acdfff33e70e782">vec_cmplttoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a82c672a1a0bcd3005acdfff33e70e782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a82c672a1a0bcd3005acdfff33e70e782">More...</a><br /></td></tr>
<tr class="separator:a82c672a1a0bcd3005acdfff33e70e782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3242d44d78984694295087f9f415e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a1e3242d44d78984694295087f9f415e8">vec_cmpltuzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a1e3242d44d78984694295087f9f415e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a1e3242d44d78984694295087f9f415e8">More...</a><br /></td></tr>
<tr class="separator:a1e3242d44d78984694295087f9f415e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388307f4693587b9e49148fbe95d8da5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a388307f4693587b9e49148fbe95d8da5">vec_cmpltuqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a388307f4693587b9e49148fbe95d8da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a388307f4693587b9e49148fbe95d8da5">More...</a><br /></td></tr>
<tr class="separator:a388307f4693587b9e49148fbe95d8da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a23cbeeb063d30316ab3e7bdd77fd7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aa2a23cbeeb063d30316ab3e7bdd77fd7">vec_cmpnetoqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aa2a23cbeeb063d30316ab3e7bdd77fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Not Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#aa2a23cbeeb063d30316ab3e7bdd77fd7">More...</a><br /></td></tr>
<tr class="separator:aa2a23cbeeb063d30316ab3e7bdd77fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffa4be24c8714347ded9340de33e999"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4ffa4be24c8714347ded9340de33e999">vec_cmpneuzqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a4ffa4be24c8714347ded9340de33e999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Not Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a4ffa4be24c8714347ded9340de33e999">More...</a><br /></td></tr>
<tr class="separator:a4ffa4be24c8714347ded9340de33e999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e270eb83aa8d90a2459b0097fec944"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ab3e270eb83aa8d90a2459b0097fec944">vec_cmpneuqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ab3e270eb83aa8d90a2459b0097fec944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Not Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ab3e270eb83aa8d90a2459b0097fec944">More...</a><br /></td></tr>
<tr class="separator:ab3e270eb83aa8d90a2459b0097fec944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c233f656fb0ef554dfbdfb23e66954"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a44c233f656fb0ef554dfbdfb23e66954">vec_cmpqp_all_toeq</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a44c233f656fb0ef554dfbdfb23e66954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a44c233f656fb0ef554dfbdfb23e66954">More...</a><br /></td></tr>
<tr class="separator:a44c233f656fb0ef554dfbdfb23e66954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7d9eb6f3ee5d504bddd9f4b9171bfd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4c7d9eb6f3ee5d504bddd9f4b9171bfd">vec_cmpqp_all_uzeq</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a4c7d9eb6f3ee5d504bddd9f4b9171bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a4c7d9eb6f3ee5d504bddd9f4b9171bfd">More...</a><br /></td></tr>
<tr class="separator:a4c7d9eb6f3ee5d504bddd9f4b9171bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50ec5ca14b23861c520e99f9b24a11f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ab50ec5ca14b23861c520e99f9b24a11f">vec_cmpqp_all_eq</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ab50ec5ca14b23861c520e99f9b24a11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ab50ec5ca14b23861c520e99f9b24a11f">More...</a><br /></td></tr>
<tr class="separator:ab50ec5ca14b23861c520e99f9b24a11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4f2f83695c9980679e8a2488ed2c55"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9a4f2f83695c9980679e8a2488ed2c55">vec_cmpqp_all_toge</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a9a4f2f83695c9980679e8a2488ed2c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than Or Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a9a4f2f83695c9980679e8a2488ed2c55">More...</a><br /></td></tr>
<tr class="separator:a9a4f2f83695c9980679e8a2488ed2c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a13069849f5ac559db634deab32d0e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a59a13069849f5ac559db634deab32d0e">vec_cmpqp_all_uzge</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a59a13069849f5ac559db634deab32d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than Or Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a59a13069849f5ac559db634deab32d0e">More...</a><br /></td></tr>
<tr class="separator:a59a13069849f5ac559db634deab32d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aef626eb6cd826f5874f3324dd7217"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a01aef626eb6cd826f5874f3324dd7217">vec_cmpqp_all_ge</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a01aef626eb6cd826f5874f3324dd7217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than Or Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a01aef626eb6cd826f5874f3324dd7217">More...</a><br /></td></tr>
<tr class="separator:a01aef626eb6cd826f5874f3324dd7217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926a5e7b9a23e7464d70d9fa6ae49dda"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a926a5e7b9a23e7464d70d9fa6ae49dda">vec_cmpqp_all_togt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a926a5e7b9a23e7464d70d9fa6ae49dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a926a5e7b9a23e7464d70d9fa6ae49dda">More...</a><br /></td></tr>
<tr class="separator:a926a5e7b9a23e7464d70d9fa6ae49dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dcb860a9015e36ade2d6a9fac55c62"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ab0dcb860a9015e36ade2d6a9fac55c62">vec_cmpqp_all_uzgt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ab0dcb860a9015e36ade2d6a9fac55c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ab0dcb860a9015e36ade2d6a9fac55c62">More...</a><br /></td></tr>
<tr class="separator:ab0dcb860a9015e36ade2d6a9fac55c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253c27dd7f4fe852a4f0c6dce45d886b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a253c27dd7f4fe852a4f0c6dce45d886b">vec_cmpqp_all_gt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a253c27dd7f4fe852a4f0c6dce45d886b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a253c27dd7f4fe852a4f0c6dce45d886b">More...</a><br /></td></tr>
<tr class="separator:a253c27dd7f4fe852a4f0c6dce45d886b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8171c3fa6a0ecdf7b19be3df8227cbf6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a8171c3fa6a0ecdf7b19be3df8227cbf6">vec_cmpqp_all_tole</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a8171c3fa6a0ecdf7b19be3df8227cbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare All Less Than Or Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a8171c3fa6a0ecdf7b19be3df8227cbf6">More...</a><br /></td></tr>
<tr class="separator:a8171c3fa6a0ecdf7b19be3df8227cbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d444218effcb971289efb1e02a3dc9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a75d444218effcb971289efb1e02a3dc9">vec_cmpqp_all_uzle</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a75d444218effcb971289efb1e02a3dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less Than Or Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a75d444218effcb971289efb1e02a3dc9">More...</a><br /></td></tr>
<tr class="separator:a75d444218effcb971289efb1e02a3dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dca4ec505a30c52361dff6300fdba7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a19dca4ec505a30c52361dff6300fdba7">vec_cmpqp_all_le</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a19dca4ec505a30c52361dff6300fdba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less Than Or Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a19dca4ec505a30c52361dff6300fdba7">More...</a><br /></td></tr>
<tr class="separator:a19dca4ec505a30c52361dff6300fdba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d466774a32ef558f6e3ea64dd6b3cdd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9d466774a32ef558f6e3ea64dd6b3cdd">vec_cmpqp_all_tolt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a9d466774a32ef558f6e3ea64dd6b3cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare All Less Than (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a9d466774a32ef558f6e3ea64dd6b3cdd">More...</a><br /></td></tr>
<tr class="separator:a9d466774a32ef558f6e3ea64dd6b3cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dde3d0847b947b1f422afef46fbfc6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a95dde3d0847b947b1f422afef46fbfc6">vec_cmpqp_all_uzlt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a95dde3d0847b947b1f422afef46fbfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less Than (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a95dde3d0847b947b1f422afef46fbfc6">More...</a><br /></td></tr>
<tr class="separator:a95dde3d0847b947b1f422afef46fbfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630f6cef8a6cdcc6dd22d3c1ece138b7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a630f6cef8a6cdcc6dd22d3c1ece138b7">vec_cmpqp_all_lt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a630f6cef8a6cdcc6dd22d3c1ece138b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less Than (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a630f6cef8a6cdcc6dd22d3c1ece138b7">More...</a><br /></td></tr>
<tr class="separator:a630f6cef8a6cdcc6dd22d3c1ece138b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d272e77ab3c69808ad3efac20afb36"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ad8d272e77ab3c69808ad3efac20afb36">vec_cmpqp_all_tone</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:ad8d272e77ab3c69808ad3efac20afb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Not-Equal (Total-order) Quad-Precision.  <a href="vec__f128__ppc_8h.html#ad8d272e77ab3c69808ad3efac20afb36">More...</a><br /></td></tr>
<tr class="separator:ad8d272e77ab3c69808ad3efac20afb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa147fd8c1d3da47a2786b6b745a9e1a6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aa147fd8c1d3da47a2786b6b745a9e1a6">vec_cmpqp_all_uzne</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aa147fd8c1d3da47a2786b6b745a9e1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Not-Equal (Zero-unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#aa147fd8c1d3da47a2786b6b745a9e1a6">More...</a><br /></td></tr>
<tr class="separator:aa147fd8c1d3da47a2786b6b745a9e1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d858ca0228e20b1e7f3bec686021fb6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3d858ca0228e20b1e7f3bec686021fb6">vec_cmpqp_all_ne</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a3d858ca0228e20b1e7f3bec686021fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Not-Equal (Unordered) Quad-Precision.  <a href="vec__f128__ppc_8h.html#a3d858ca0228e20b1e7f3bec686021fb6">More...</a><br /></td></tr>
<tr class="separator:a3d858ca0228e20b1e7f3bec686021fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6c52eb3208f4d9ed851ee48f773d68"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a1e6c52eb3208f4d9ed851ee48f773d68">vec_cmpqp_exp_eq</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a1e6c52eb3208f4d9ed851ee48f773d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Quad-Precision Exponents for Equal.  <a href="vec__f128__ppc_8h.html#a1e6c52eb3208f4d9ed851ee48f773d68">More...</a><br /></td></tr>
<tr class="separator:a1e6c52eb3208f4d9ed851ee48f773d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2d90d67cb3f605fbc9598f133b0305"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#abf2d90d67cb3f605fbc9598f133b0305">vec_cmpqp_exp_gt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:abf2d90d67cb3f605fbc9598f133b0305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Exponents Quad-Precision for Greater Than.  <a href="vec__f128__ppc_8h.html#abf2d90d67cb3f605fbc9598f133b0305">More...</a><br /></td></tr>
<tr class="separator:abf2d90d67cb3f605fbc9598f133b0305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb9b92be998695424107de6a60890a8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3eb9b92be998695424107de6a60890a8">vec_cmpqp_exp_lt</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a3eb9b92be998695424107de6a60890a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Exponents Quad-Precision for Less Than.  <a href="vec__f128__ppc_8h.html#a3eb9b92be998695424107de6a60890a8">More...</a><br /></td></tr>
<tr class="separator:a3eb9b92be998695424107de6a60890a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3014214c103453a34372cc52e6d79073"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3014214c103453a34372cc52e6d79073">vec_cmpqp_exp_unordered</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:a3014214c103453a34372cc52e6d79073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Exponents Quad-Precision for Unordered.  <a href="vec__f128__ppc_8h.html#a3014214c103453a34372cc52e6d79073">More...</a><br /></td></tr>
<tr class="separator:a3014214c103453a34372cc52e6d79073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1668ff13922ca04059f1844a7a1464f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ad1668ff13922ca04059f1844a7a1464f">vec_isfinitef128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:ad1668ff13922ca04059f1844a7a1464f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is Finite (Not NaN nor Inf).  <a href="vec__f128__ppc_8h.html#ad1668ff13922ca04059f1844a7a1464f">More...</a><br /></td></tr>
<tr class="separator:ad1668ff13922ca04059f1844a7a1464f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd9706acb775392282cfe4d4e3a03aa"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aebd9706acb775392282cfe4d4e3a03aa">vec_isinf_signf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aebd9706acb775392282cfe4d4e3a03aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true (nonzero) value if the __float128 value is infinity. For infinity indicate the sign as +1 for positive infinity and -1 for negative infinity.  <a href="vec__f128__ppc_8h.html#aebd9706acb775392282cfe4d4e3a03aa">More...</a><br /></td></tr>
<tr class="separator:aebd9706acb775392282cfe4d4e3a03aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a94f9c7429c2ebd9b9f32ad6e98689ebb">vec_isinff128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 128-bit vector boolean true if the __float128 value is infinity.  <a href="vec__f128__ppc_8h.html#a94f9c7429c2ebd9b9f32ad6e98689ebb">More...</a><br /></td></tr>
<tr class="separator:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c410994f958a6b4ac9583878a55a72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">vec_isnanf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a11c410994f958a6b4ac9583878a55a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN).  <a href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">More...</a><br /></td></tr>
<tr class="separator:a11c410994f958a6b4ac9583878a55a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25185c83b69f6af3f3d9399199c8a57"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aa25185c83b69f6af3f3d9399199c8a57">vec_isnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aa25185c83b69f6af3f3d9399199c8a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).  <a href="vec__f128__ppc_8h.html#aa25185c83b69f6af3f3d9399199c8a57">More...</a><br /></td></tr>
<tr class="separator:aa25185c83b69f6af3f3d9399199c8a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9670e4655a9c7888c80343780cd7abf9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9670e4655a9c7888c80343780cd7abf9">vec_issubnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a9670e4655a9c7888c80343780cd7abf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true value, if the __float128 value is subnormal (denormal).  <a href="vec__f128__ppc_8h.html#a9670e4655a9c7888c80343780cd7abf9">More...</a><br /></td></tr>
<tr class="separator:a9670e4655a9c7888c80343780cd7abf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9148af78b075f253c9848945df6135"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aec9148af78b075f253c9848945df6135">vec_isunorderedf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb)</td></tr>
<tr class="memdesc:aec9148af78b075f253c9848945df6135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true value, if either __float128 value (vra, vrb) is NaN.  <a href="vec__f128__ppc_8h.html#aec9148af78b075f253c9848945df6135">More...</a><br /></td></tr>
<tr class="separator:aec9148af78b075f253c9848945df6135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598a822d22b02ba0d2c2a1095a4e700d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a598a822d22b02ba0d2c2a1095a4e700d">vec_iszerof128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a598a822d22b02ba0d2c2a1095a4e700d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true value, if the value that is +-0.0.  <a href="vec__f128__ppc_8h.html#a598a822d22b02ba0d2c2a1095a4e700d">More...</a><br /></td></tr>
<tr class="separator:a598a822d22b02ba0d2c2a1095a4e700d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2297dc22a6a3120491e1721648c0e7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a7c2297dc22a6a3120491e1721648c0e7">vec_nabsf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a7c2297dc22a6a3120491e1721648c0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative Absolute value Quad-Precision.  <a href="vec__f128__ppc_8h.html#a7c2297dc22a6a3120491e1721648c0e7">More...</a><br /></td></tr>
<tr class="separator:a7c2297dc22a6a3120491e1721648c0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3323b6fb0b379a21f3dd70f7f204bd2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3323b6fb0b379a21f3dd70f7f204bd2a">vec_negf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a3323b6fb0b379a21f3dd70f7f204bd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate the sign bit of a __float128 input and return the resulting __float128 value.  <a href="vec__f128__ppc_8h.html#a3323b6fb0b379a21f3dd70f7f204bd2a">More...</a><br /></td></tr>
<tr class="separator:a3323b6fb0b379a21f3dd70f7f204bd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47637906e95a7c94cffc093bc2e57dbf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a47637906e95a7c94cffc093bc2e57dbf">vec_self128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfa, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vfb, <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> mask)</td></tr>
<tr class="memdesc:a47637906e95a7c94cffc093bc2e57dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value.  <a href="vec__f128__ppc_8h.html#a47637906e95a7c94cffc093bc2e57dbf">More...</a><br /></td></tr>
<tr class="separator:a47637906e95a7c94cffc093bc2e57dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73">vec_setb_qp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Set Bool from Quadword Floating-point.  <a href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73">More...</a><br /></td></tr>
<tr class="separator:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4ca7749d334c2a2c17a4d2a98b5bf755">vec_signbitf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return int boolean true if the __float128 value is negative (sign bit is '1').  <a href="vec__f128__ppc_8h.html#a4ca7749d334c2a2c17a4d2a98b5bf755">More...</a><br /></td></tr>
<tr class="separator:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8ceb0eb2c47892371a12502d14f170"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a1a8ceb0eb2c47892371a12502d14f170">vec_xscvdpqp</a> (<a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> f64)</td></tr>
<tr class="memdesc:a1a8ceb0eb2c47892371a12502d14f170"><td class="mdescLeft">&#160;</td><td class="mdescRight">VXS Scalar Convert Double-Precision to Quad-Precision format.  <a href="vec__f128__ppc_8h.html#a1a8ceb0eb2c47892371a12502d14f170">More...</a><br /></td></tr>
<tr class="separator:a1a8ceb0eb2c47892371a12502d14f170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3c778a7c90b6e6a2d89cd5a1012061"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5e3c778a7c90b6e6a2d89cd5a1012061">vec_xscvqpdpo</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a5e3c778a7c90b6e6a2d89cd5a1012061"><td class="mdescLeft">&#160;</td><td class="mdescRight">VXS Scalar Convert with round Quad-Precision to Double-Precision (using round to odd).  <a href="vec__f128__ppc_8h.html#a5e3c778a7c90b6e6a2d89cd5a1012061">More...</a><br /></td></tr>
<tr class="separator:a5e3c778a7c90b6e6a2d89cd5a1012061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ad56c509ea22f26fb2d47217bc5e51"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a73ad56c509ea22f26fb2d47217bc5e51">vec_xscvqpudz</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a73ad56c509ea22f26fb2d47217bc5e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">VXS Scalar Convert with round to zero Quad-Precision to Unsigned doubleword.  <a href="vec__f128__ppc_8h.html#a73ad56c509ea22f26fb2d47217bc5e51">More...</a><br /></td></tr>
<tr class="separator:a73ad56c509ea22f26fb2d47217bc5e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9d4ad5a60e9ffaa0ca16d29f90c092"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aaf9d4ad5a60e9ffaa0ca16d29f90c092">vec_xscvqpuqz</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aaf9d4ad5a60e9ffaa0ca16d29f90c092"><td class="mdescLeft">&#160;</td><td class="mdescRight">VXS Scalar Convert with round to zero Quad-Precision to Unsigned Quadword.  <a href="vec__f128__ppc_8h.html#aaf9d4ad5a60e9ffaa0ca16d29f90c092">More...</a><br /></td></tr>
<tr class="separator:aaf9d4ad5a60e9ffaa0ca16d29f90c092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc58cb3be351ea2bf163aeb8dbb5709c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#acc58cb3be351ea2bf163aeb8dbb5709c">vec_xscvsdqp</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> int64)</td></tr>
<tr class="memdesc:acc58cb3be351ea2bf163aeb8dbb5709c"><td class="mdescLeft">&#160;</td><td class="mdescRight">VXS Scalar Convert Signed-Doubleword to Quad-Precision format.  <a href="vec__f128__ppc_8h.html#acc58cb3be351ea2bf163aeb8dbb5709c">More...</a><br /></td></tr>
<tr class="separator:acc58cb3be351ea2bf163aeb8dbb5709c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eadadc05fe1873deadaef16926f6c86"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a1eadadc05fe1873deadaef16926f6c86">vec_xscvudqp</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> int64)</td></tr>
<tr class="memdesc:a1eadadc05fe1873deadaef16926f6c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">VXS Scalar Convert Unsigned-Doubleword to Quad-Precision format.  <a href="vec__f128__ppc_8h.html#a1eadadc05fe1873deadaef16926f6c86">More...</a><br /></td></tr>
<tr class="separator:a1eadadc05fe1873deadaef16926f6c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bfd64d7eefd8e84619950f19f827ba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a27bfd64d7eefd8e84619950f19f827ba">vec_xscvsqqp</a> (<a class="el" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> int128)</td></tr>
<tr class="memdesc:a27bfd64d7eefd8e84619950f19f827ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">VXS Scalar Convert Signed-Quadword to Quad-Precision format.  <a href="vec__f128__ppc_8h.html#a27bfd64d7eefd8e84619950f19f827ba">More...</a><br /></td></tr>
<tr class="separator:a27bfd64d7eefd8e84619950f19f827ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b1f22552fd177d10af1dbc0f43d5f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8">vec_xscvuqqp</a> (<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> int128)</td></tr>
<tr class="memdesc:a24b1f22552fd177d10af1dbc0f43d5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">VXS Scalar Convert Unsigned-Quadword to Quad-Precision format.  <a href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8">More...</a><br /></td></tr>
<tr class="separator:a24b1f22552fd177d10af1dbc0f43d5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95c675ceebc0627c777d2c7e2daef0b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> sig, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp)</td></tr>
<tr class="memdesc:af95c675ceebc0627c777d2c7e2daef0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Insert Exponent Quad-Precision.  <a href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">More...</a><br /></td></tr>
<tr class="separator:af95c675ceebc0627c777d2c7e2daef0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d78e42d9cc58491fa46149bf5798167"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a3d78e42d9cc58491fa46149bf5798167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Extract Exponent Quad-Precision.  <a href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">More...</a><br /></td></tr>
<tr class="separator:a3d78e42d9cc58491fa46149bf5798167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eb10beac182e936d7e49d491c34fe0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">vec_xsxsigqp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:ab1eb10beac182e936d7e49d491c34fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Extract Significand Quad-Precision.  <a href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">More...</a><br /></td></tr>
<tr class="separator:ab1eb10beac182e936d7e49d491c34fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over Quad-Precision floating point elements. </p>
<p>PowerISA 3.0B added Quad-Precision floating point type and operations to the Vector-Scalar Extension (VSX) facility. The first hardware implementation is available in POWER9.</p>
<p>PowerISA 3.1 added new min/max/compare Quad-Precision operations. Also added new quadword (128-bit) integer operations including converts between quadword integer and Quad-Precision floating point. The first hardware implementation is available in POWER10.</p>
<p>While all Quad-Precision operations are on 128-bit vector registers, they are defined as scalars in the PowerISA. The OpenPOWER ABI also treats the __float128 type as scalar that just happens to use vector registers for parameter passing and operations. As such no operations using __float128 (_Float128, or __ieee128) as parameter or return value are defined as vector built-ins in the ABI or &lt;altivec.h&gt;.</p>
<dl class="section note"><dt>Note</dt><dd>GCC 8.2 does document some built-ins, using the <em>scalar</em> prefix (scalar_extract_exp, scalar_extract_sig, scalar_test_data_class), that do accept the __ieee128 type. This work seems to be incomplete as scalar_exp_cmp_* for the __ieee128 type are not present. GCC 7.3 defines vector and scalar forms of the extract/insert_exp for float and double but not for __ieee128. These built-ins are not defined in GCC 6.4. See <a href="https://gcc.gnu.org/onlinedocs/">compiler documentation</a>. These are useful operations and can be implemented in a few vector logical instructions for earlier machines. So it seems reasonable to add these to pveclib for both vector and scalar forms.</dd></dl>
<p>Quad-Precision is not supported in hardware until POWER9. However the compiler and runtime supports the __float128 type and arithmetic operations via soft-float emulation for earlier processors. The soft-float implementation follows the ABI and passes __float128 parameters and return values in vector registers.</p>
<p>The PowerISA 3.0 also defines a number of useful quad-precision operations using the "round-to-odd" override. This is useful when the results of quad-precision arithmetic must be rounded to a shorter precision while avoiding double rounding. Recent GCC compilers support these operations as built-ins for the POWER9 target, but they not supported by the C language or GCC runtime library. This means that round-to-odd is not easily available to libraries that need to support IEEE-128 on POWER8. Again it may be reasonable to add these to pveclib.</p>
<dl class="section note"><dt>Note</dt><dd>See <a href="https://www.exploringbinary.com/gcc-avoids-double-rounding-errors-with-round-to-odd/">GCC Avoids Double Rounding Errors With Round-To-Odd</a></dd></dl>
<p>Another issue is the performance of GCC soft-float runtime for IEEE-128 (KF mode). There seem to be a number of issues with code generation for transfers from __float128 to 64-bit integer GPRs. This is required to match the ABI (vector) parameters to the soft-float runtime using integer scalars. For POWER8 targets the GCC compiler generates store vector followed by two load doubleword instructions. This generates high frequencies of load-hit-store rejects at runtime. It also looks like there is significant instruction latency associated with the XER carry bit required for extended (128-bit) integer arithmetic.</p>
<dl class="section note"><dt>Note</dt><dd>Both of these issues can be avoided by providing a soft-float implementation for __float128 using VXS vector 128-bit arithmetic and logical operations. So far direct comparisons for _float128 compare and conversion operations show a significant performance gain for the PVECLIB vector implementations vs the GCC KF mode runtime. The most convincing results will come when the round-to-odd implementations for IEEE-128 add and multiply are available. This allows direct performance comparison across __float128 arithmetic operations. Please stand-by.</dd></dl>
<p>There are number of __float128 operations that should generate a single instruction for POWER9 and few (less than 10) instructions for POWER8. This includes all of the __float128 classification functions (isnormal/subnormal/finite/inf/nan/zero). Unfortunately for POWER8 the compilers will generate calls to the GCC runtime (__unordkf2, __gekf2, ...) for these functions. In many cases the code size generated for the runtime calls far exceeds any in-line VSX code PVECLIB will generate.</p>
<p>So it is not unreasonable for this header to provide vector forms of the __float128 classification functions (isnormal/subnormal/finite/inf/nan/zero). It is little additional effort to include the sign bit manipulation operations (copysign, abs, nabs, and neg).</p>
<p>These functions can be implemented directly using (one or more) POWER9 instructions, or a few vector logical and integer compare instructions for POWER7/8. Each is comfortably small enough to be in-lined and inherently faster than the equivalent POSIX or compiler built-in runtime functions. Performing these operations in-line and directly in vector registers (VRs) avoids call/return and VR &lt;-&gt; GPR transfer overhead.</p>
<p>It also seems reasonable to provide Quad-Precision extract/insert exponent/significand and compare exponent operations for POWER7/8. And with the PowerISA 3.1 release providing POWER9/8 implementations of min/max and quadword integer converts.</p>
<p>The quad-precision arithmetic, compare, and conversion operation are large enough that most applications will want to call a library. PVECLIB will build and release the appropriate CPU tuned libraries. This will follow the general design used for multiple quadword integer multiply functions (<a class="el" href="vec__int512__ppc_8h.html" title="Header package containing a collection of multiple precision quadword integer computation functions i...">vec_int512_ppc.h</a>).</p>
<p>These PVECLIB operations should be useful for applications using Quad-Precision while needing to still support POWER8 but also build for POWER9/10. An important goal is to allow applications and libraries to safely substitute PVECLIB operations for C language and math.h __float128 operators and functions as point optimizations. The largest gains will be seen for builds targeting POWER8 without degrading performance when targeting POWER9/10. They should also be useful and improve performance for soft-float implementations of math library functions.</p>
<dl class="section note"><dt>Note</dt><dd>At this time, PVECLIB does not intend to replace existing GCC/libm IEEE-128 runtime APIs and will maintain it own unique name-space. However if the maintainers of these projects want to leverage PVECLIB they are allowed under the terms of the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0.</a></dd>
<dd>
The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power8</b>, Quad-Precision floating-point built-ins operations useful for floating point classification are not defined. This header provides the appropriate substitutions, will generate the minimum code, appropriate for the target, and produce correct results.</dd>
<dd>
Most ppc64le compilers will default to <b>-mcpu=</b><em>power8</em> if <b>-mcpu</b> is not specified.</dd></dl>
<p>This header covers operations that are any of the following:</p>
<ul>
<li>Implemented in hardware instructions in newer processors, but useful to programmers on slightly older processors (even if the equivalent function requires more instructions).</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.h&gt; provided by available compilers in common use. Examples include scalar_test_neg, scalar_test_data_class, etc.</li>
<li>Defined for POWER9 (as built-ins) but not supported in the soft-float runtime implementation provided for POWER8. Examples include the arithmetic/conversion operations supporting the <em>round-to-odd</em> override.</li>
<li>Providing special vector float tests for special conditions without generating extraneous floating-point exceptions. This is important for implementing __float128 forms of ISO C99 Math functions. Examples include vector isnan, isinf, etc.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious.</li>
</ul>
<h1><a class="anchor" id="f128_softfloat_0_0"></a>
Vector implementation of Quad-Precision Soft-float</h1>
<p>The discussion above raises a interesting question. If we can provide useful implementations of Quad-Precision; classification, extract/insert, and compare exponent operations, why not continue with Quad-Precision compare, convert to/from integer, and arithmetic operations?</p>
<p>This raises the stakes in complexity and size of implementation. Providing a vector soft-float implementation equivalent to the GCC run-time libgcc <b>__addkf3/__divkf3/__mulkf3/__subkf3</b> would be a substantial effort. The IEEE standard is exacting about rounding and exception handling. Comparisons require special handling of; signed zero, infinities, and NaNs. Even float/integer conversions require correct rounding and return special values for overflow. Also it is not clear how such an effort would be accepted.</p>
<p>The good news is PVECLIB already provides a strong quadword integer operations set. Integer Add, subtract, and multiply are covered with the usual compare/shift/rotate operations (See <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>). The weak spot is general quadword integer divide. Until recently, integer divide has not been part of the vector ISA. But the introduction of Vector Divide Signed/Unsigned Quadword in POWER10 raises the priority of vector integer divide for PVECLIB.</p>
<p>For now we propose a phased approach, starting with enablers and infrastructure, building up layers, starting simple and adding complexity.</p>
<ul>
<li>Basic enablers; classification, extract/insert exponent, compare exponent.</li>
<li>Quad-Precision comparison operators.<ul>
<li>Initially ignore special cases and exceptions</li>
<li>Add Signed Zero, Infinity. and NaN special cases</li>
<li>Exceptions when someone asks</li>
</ul>
</li>
<li>Quad-Precision from/to integer word/doubleword/quadword.<ul>
<li>Cases that don't require rounding (i.e truncate and DW to QP).</li>
<li>Cases that require rounding<ul>
<li>Round to odd.</li>
<li>Round to Nearest/Even</li>
<li>Others if asked</li>
</ul>
</li>
</ul>
</li>
<li>Quad-Precision arithmetic<ul>
<li>Add/Sub/Mul<ul>
<li>Round-to-Odd first</li>
<li>Initially ignore special cases and exceptions</li>
</ul>
</li>
<li>Fused Multiply-Add<ul>
<li>Round-to-Odd first</li>
</ul>
</li>
<li>Divide<ul>
<li>Round-to-Odd first</li>
</ul>
</li>
<li>Add Signed Zero, Infinity. and NaN special cases</li>
<li>Other rounding modes</li>
<li>Exceptions when someone asks</li>
</ul>
</li>
</ul>
<p>The intent is that such PVECLIB operations can be mixed in with or substituted for C Language _FLoat128 expressions or functions. The in-lined operations should have performance advantages over equivalent library functions on both POWER8/9.</p>
<p>This is a big list. It is TBD how far I will get given my current limited resources.</p>
<dl class="section note"><dt>Note</dt><dd>We are focusing on POWER8 here because the implementation gets a lot harder for POWER7 and earlier. POWER7 is missing: Quadword integer add/sub with carry extend. Wide (word) integer multiply. Direct transfer between VRs and GPRs. Doubleword integer arithmetic, compares. and count-leading zeros.</dd></dl>
<h2><a class="anchor" id="f128_softfloat_0_0_0"></a>
Quad-Precision data class and exponent access for POWER8</h2>
<p>Most math library functions need to test the data class (normal, infinity, NaN, etc) and or range of input values. This usually involves separating the sign, exponent, and significand out from __float128 values, and comparing one or more of these parts, to special integer values.</p>
<p>PowerISA 3.0B (POWER9) provides instructions for these in addition to a comprehensive set of arithmetic and compare instructions. These operations are also useful for the soft-float implementation of __float128 for POWER8 and earlier. The OpenPOWER ABI specifies __float128 parameters are in VRs and are immediately accessible to VMX/VSR instructions. This is important as the cost of transferring values between VRs and GPRs is quite high on POWER8 and even higher for POWER7 and earlier (which requires store to temporaries and reload).</p>
<p>Fortunately these operations only require logical (and/or/xor), shift and integer compare operations to implement. These are available as vector intrinsics or provides by PVECLIB (see <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>).</p>
<p>The operations in this group include:</p><ul>
<li>Altivec like predicates; <a class="el" href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad" title="Return true if the __float128 value is Finite (Not NaN nor Inf).">vec_all_isfinitef128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da" title="Return true if the __float128 value is infinity.">vec_all_isinff128()</a>, <a class="el" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89" title="Return true if the __float128 value is Not a Number (NaN).">vec_all_isnanf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d" title="Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).">vec_all_isnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#adf1a94cccdb3f106a0e6399e2f034718" title="Return true if the __float128 value is subnormal (denormal).">vec_all_issubnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414" title="Return true if the __float128 value is +-0.0.">vec_all_iszerof128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a4ca7749d334c2a2c17a4d2a98b5bf755" title="Return int boolean true if the __float128 value is negative (sign bit is &#39;1&#39;).">vec_signbitf128()</a>.</li>
<li>Vector boolean predicates; <a class="el" href="vec__f128__ppc_8h.html#ad1668ff13922ca04059f1844a7a1464f" title="Return 128-bit vector boolean true if the __float128 value is Finite (Not NaN nor Inf).">vec_isfinitef128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a94f9c7429c2ebd9b9f32ad6e98689ebb" title="Return a 128-bit vector boolean true if the __float128 value is infinity.">vec_isinff128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72" title="Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN).">vec_isnanf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#aa25185c83b69f6af3f3d9399199c8a57" title="Return 128-bit vector boolean true if the __float128 value is normal (Not NaN, Inf,...">vec_isnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a9670e4655a9c7888c80343780cd7abf9" title="Return 128-bit vector boolean true value, if the __float128 value is subnormal (denormal).">vec_issubnormalf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a598a822d22b02ba0d2c2a1095a4e700d" title="Return 128-bit vector boolean true value, if the value that is +-0.0.">vec_iszerof128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73" title="Vector Set Bool from Quadword Floating-point.">vec_setb_qp()</a>.</li>
<li>Sign bit manipulation; <a class="el" href="vec__f128__ppc_8h.html#add641f5a217eff45f0e836fa98613584" title="Absolute Quad-Precision.">vec_absf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a7c2297dc22a6a3120491e1721648c0e7" title="Negative Absolute value Quad-Precision.">vec_nabsf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#a3323b6fb0b379a21f3dd70f7f204bd2a" title="Negate the sign bit of a __float128 input and return the resulting __float128 value.">vec_negf128()</a>, <a class="el" href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e" title="Copy the sign bit from f128y and merge with the magnitude from f128x. The merged result is returned a...">vec_copysignf128()</a>.</li>
<li>Data manipulation; <a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b" title="Scalar Insert Exponent Quad-Precision.">vec_xsiexpqp()</a>, <a class="el" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167" title="Scalar Extract Exponent Quad-Precision.">vec_xsxexpqp()</a>, <a class="el" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0" title="Scalar Extract Significand Quad-Precision.">vec_xsxsigqp()</a>.</li>
<li>Exponent Compare; <a class="el" href="vec__f128__ppc_8h.html#a1e6c52eb3208f4d9ed851ee48f773d68" title="Vector Compare Quad-Precision Exponents for Equal.">vec_cmpqp_exp_eq()</a>, <a class="el" href="vec__f128__ppc_8h.html#abf2d90d67cb3f605fbc9598f133b0305" title="Vector Compare Exponents Quad-Precision for Greater Than.">vec_cmpqp_exp_gt()</a>, <a class="el" href="vec__f128__ppc_8h.html#a3eb9b92be998695424107de6a60890a8" title="Vector Compare Exponents Quad-Precision for Less Than.">vec_cmpqp_exp_lt()</a>, <a class="el" href="vec__f128__ppc_8h.html#a3014214c103453a34372cc52e6d79073" title="Vector Compare Exponents Quad-Precision for Unordered.">vec_cmpqp_exp_unordered()</a>.</li>
</ul>
<p>For example the data class test isnan: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line"><a class="code" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">vec_isnanf128</a> (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR9) &amp;&amp; defined (scalar_test_data_class) &amp;&amp; \</span></div>
<div class="line"><span class="preprocessor">  defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> result = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (scalar_test_data_class (f128, 0x40))</div>
<div class="line">    result = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(-1, -1, -1, -1);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>)result;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> tmp;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x7fff0000, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line">  tmp = <a class="code" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a> (f128, signmask);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>)tmp , (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>)expmask);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">}</span></div>
</div><!-- fragment --><p> Which has implementations for POWER9 (and later) and POWER8 (and earlier).</p>
<p>For POWER9 it generates: </p><div class="fragment"><div class="line">xststdcqp cr0,v2,64</div>
<div class="line">bne     .+12</div>
<div class="line">xxspltib vs34,255</div>
<div class="line">b       .+8</div>
<div class="line">xxspltib vs34,0</div>
</div><!-- fragment --><p> Which uses the intrinsic scalar_test_data_class() to generate the VSX Scalar Test Data Class Quad-Precision instruction with "data class mask" of <em>class.NaN</em> to set the condition code. If the condition is <em>match</em>, load the 128-bit bool value of all 1's (true). Otherwise load all 0's (false).</p>
<p>For POWER8 it generates </p><div class="fragment"><div class="line">addis   r9,r2,@ha.rodata.cst16+0x30</div>
<div class="line">vspltisw v1,-1</div>
<div class="line">vspltisw v12,0</div>
<div class="line">addi    r9,r9,@l.rodata.cst16+0x30</div>
<div class="line">vslw    v1,v1,v1</div>
<div class="line">lvx     v0,0,r9</div>
<div class="line">vsldoi  v1,v1,v12,12</div>
<div class="line"> </div>
<div class="line">xxlandc vs33,vs34,vs33</div>
<div class="line">vsubcuq v0,v0,v1</div>
<div class="line">xxspltw vs32,vs32,3</div>
<div class="line">vcmpequw v2,v0,v12</div>
</div><!-- fragment --><p> The first 7 instructions above, load the constant vectors needed by the logic. These constants only need to be generated once per function and can be shared across operations.</p>
<p>In the C code we use a special transfer function combined with logical AND complement (<a class="el" href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab" title="Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask.">vec_andc_bin128_2_vui32t()</a>). This is required because while __float128 values are held in VRs, the compiler considers them to be scalars and will not allow simple casts to (any) vector type. So the PVECLIB implementation provides <em>xfer</em> function using a union to transfer the __float128 value to a vector type. In most case this logical transfer simply serves to make the compiler happy and does not need to generate any code. In this case the <em>xfer</em> function combines the transfer with a vector and complement to mask off the sign bit.</p>
<p>Then compare the masked result as a 128-bit integer value greater than infinity (expmask). Here we use the <a class="el" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e" title="Vector Compare Greater Than Unsigned Quadword.">vec_cmpgtuq()</a> operation from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>. For POWER8, <a class="el" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e" title="Vector Compare Greater Than Unsigned Quadword.">vec_cmpgtuq()</a> generates the Vector Subtract and Write Carry Unsigned Quadword instruction for 128-bit unsigned compares. A '0' carry indicates greater than. The next two instructions (from <a class="el" href="vec__int128__ppc_8h.html#a921647d5b67f0de5006ee32fb3d9c4f1" title="Vector Set Bool from Quadword not Carry.">vec_setb_ncq()</a>) convert the carry bit to the required 128-bit bool value.</p>
<p>While the POWER8 sequence requires more instructions (including the const vector set up) than POWER9, it is not significantly larger. And as mentioned above, the set-up code can be optimized across operations sharing the same constants. The code (less the setup) is only 10 cycles for POWER8 vs 6 for POWER9. Also the code is not any larger than the function call overhead for the libgcc runtime equivalent <b>__unordkf2</b>. And is much faster then the generic soft-float implementation.</p>
<p>Another example, Scalar Extract Exponent Quad-Precision:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div>
<div class="line"><a class="code" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR9) &amp;&amp; defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xsxexpqp %0,%1&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (f128)</div>
<div class="line">      : );</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> tmp;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x7fff0000, 0, 0, 0)</div>
<div class="line"> </div>
<div class="line">  tmp = <a class="code" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a> (f128, expmask);</div>
<div class="line">  result = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) vec_sld (tmp, tmp, 10);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Which has implementations for POWER9 (and later) and POWER8 (and earlier).</p>
<p>For POWER9 it generates the VSX Scalar Extract Exponent Quad-Precision instruction. </p><div class="fragment"><div class="line">xsxexpqp v2,v2</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Should use the intrinsic scalar_extract_exp() here but this is not available until GCC 11. So use in-line assembler until the internsic is available and verified.</dd></dl>
<p>For POWER8 we generate </p><div class="fragment"><div class="line">addis   r9,r2,.rodata.cst16+0xc0@ha</div>
<div class="line">addi    r9,r9,.rodata.cst16+0xc0@l</div>
<div class="line">lvx     v13,0,r9</div>
<div class="line"> </div>
<div class="line">xxland  vs34,vs34,vs45</div>
<div class="line">vsldoi  v2,v2,v2,10</div>
</div><!-- fragment --><p> The first 3 instructions above load the constant vector needed by the logic. This constant only needs to be generated once per function and can be shared across operations.</p>
<p>Again we use a special transfer function combined with logical AND (<a class="el" href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e" title="Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask.">vec_and_bin128_2_vui32t()</a>) to transfer the__float128 to a vector type and mask off all bits except for the 15-bit exponent. Then we rotate the exponent logically right 48-bit to right justify the exponent in vector doubleword 0. This matches the results of the xsxexpqp instruction.</p>
<h2><a class="anchor" id="f128_softfloat_IRRN_0_0"></a>
Intermediate results and Rounding for Quad-Precision</h2>
<p>The IEEE-128 floating-point storage (external) format fits neatly in 128-bits. But this compact format needs to be expanded internally during QP operations. The sign and exponent are normally manipulated separately from the significant. And for finite values the Leading-bit (implied but not included in the storage format) must be restored to take part in arithmetic/rounding/normalization operations.</p>
<p>For a soft-float implementation of IEEE-128 on POWER8 we want to extract these components into 128-bit vector registers and operate on them using vector instruction. This allows direct use of 128-bit arithmetic/shift/rotate operations (see <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>), while avoiding expensive transfers between VRs and GPRs.</p>
<p>To extract the sign-bit we can either AND with a 128-bit mask or use a set-bool operation (<a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73" title="Vector Set Bool from Quadword Floating-point.">vec_setb_qp()</a> or <a class="el" href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802" title="Vector Set Bool from Signed Quadword.">vec_setb_sq()</a>). The masked sign-bit can be ORed with the final IEEE-128 vector result to set the appropriate sign. The 128-bit vector bool can be using with vec_sel() (<a class="el" href="vec__f128__ppc_8h.html#a47637906e95a7c94cffc093bc2e57dbf" title="Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binar...">vec_self128()</a>, <a class="el" href="vec__int128__ppc_8h.html#a9d388d607e331ffb7cecd6dcbdd0d18b" title="Vector Select Signed Quadword.">vec_selsq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd" title="Vector Select Unsigned Quadword.">vec_seluq()</a>) to select results based on the sign-bit while avoiding branch logic.</p>
<p>We use <a class="el" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167" title="Scalar Extract Exponent Quad-Precision.">vec_xsxexpqp()</a> to extract the 15-bit exponent into a vector doubleword integer element. The biased exponent is returned in the high doubleword (matching the POWER9 instruction). Depending on the operation, the exponent (or derived values) may need to be transfered/replicated to the low doubleword element. This is easily accomplished using <a class="el" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c" title="Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of ...">vec_splatd()</a>.</p>
<p>We use <a class="el" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0" title="Scalar Extract Significand Quad-Precision.">vec_xsxsigqp()</a> to extract the 113-bit significand into a vector quadword integer. This operation restores the leading-bit for normal (not NaN, Infinity, denormal or zero) values. The significand is returned right-justified in the quadword.</p>
<p>At the end of the operation we can use vec_or() and <a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b" title="Scalar Insert Exponent Quad-Precision.">vec_xsiexpqp()</a> to combine these (sign, exponent, and significand) components into a IEEE-128 result.</p>
<h3><a class="anchor" id="f128_softfloat_IRRN_0_1"></a>
Representation Intermediate results for Quad-Precision</h3>
<p>Internal IEEE floating-point operations will need/generate additional bits to support normalization and rounding. The PowerISA describes a <b>VSX Execution Model for IEEE Operations</b></p>
<p>IEEE quad-precision execution model </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter">0 </th><th class="markdownTableHeadCenter">1 --------------------------&mdash; 112 </th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadRight"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">S </td><td class="markdownTableBodyCenter">C </td><td class="markdownTableBodyCenter">L </td><td class="markdownTableBodyCenter">FRACTION </td><td class="markdownTableBodyCenter">G </td><td class="markdownTableBodyCenter">R </td><td class="markdownTableBodyRight">X  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft" colspan="7">- Sign bit  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft" colspan="7">- Carry bit  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft" colspan="7">- Leading bit, also called the implicit or hidden bit  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft" colspan="7">- Fraction (112-bits)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft" colspan="7">- Guard bit  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft" colspan="7">- Round bit  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft" colspan="7">- (X) AKA Sticky bit, logical OR of remaining bits  </td></tr>
</table>
<p>This model is a guide for processor design and soft-float implementors. This also described as the <em>Intermediate result Representation (<b>IR</b>)</em>. As such the implementation may arrange these bits into different registers as dictated by design and performance.</p>
<p>The GRX bits extend the low order bits of the fraction and are requirer for rounding. Basically these bits encode how <em>near</em> the intermediate result is to a representable result. The GR bits are required for post-normalization of the result and participate in shifts during normalization. For right shifts, bits shift out of the R-bit are logically ORed into the X-bit. For left shifts, 0 bits shifted into the R-bit (the X-bit is ignored).</p>
<p>As mentioned before it is convenient to keep sign-bit in a separate vector quadword. Its not an extension of the significand but is needed to select results for arithmetic and some rounding modes.</p>
<p>The remaining (C through X) bits can be represented in a vector quadword register or a register pair. For example integer to QP conversions can be represented in a vector quadword by left justifying the magnitude before normalization and rounding. For example from <a class="el" href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8" title="VXS Scalar Convert Unsigned-Quadword to Quad-Precision format.">vec_xscvuqqp()</a>: </p><div class="fragment"><div class="line">{ <span class="comment">// We need to produce a normal QP, so we treat the integer like a</span></div>
<div class="line">  <span class="comment">// denormal, then normalize it.</span></div>
<div class="line">  <span class="comment">// Start with the quad exponent bias + 127 then subtract the count of</span></div>
<div class="line">  <span class="comment">// leading &#39;0&#39;s. The 128-bit sig can have 0-127 leading &#39;0&#39;s.</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_expm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>(0, (0x3fff + 127));</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> i64_clz = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49">vec_clzq</a> (q_sig);</div>
<div class="line">  q_sig = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) i64_clz);</div>
<div class="line">  q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_expm, i64_clz);</div>
<div class="line">  <span class="comment">// This is the part that might require rounding.</span></div>
<div class="line">  <span class="comment">// The Significand (including the L-bit) is right justified in</span></div>
<div class="line">  <span class="comment">// in the high-order 113-bits of q_sig.</span></div>
<div class="line">  <span class="comment">// The guard, round, and sticky (GRX) bits are in the low-order</span></div>
<div class="line">  <span class="comment">// 15 bits.</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> The simplest case is <em>Round toward Zero</em> </p><div class="fragment"><div class="line"><span class="comment">// Round toward zero to normalize and truncate</span></div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
<div class="line">...</div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a42d2b39711c06106097ef869a20420b6">vec_swapd</a> (q_exp);</div>
<div class="line">result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
<div class="line">...</div>
</div><!-- fragment --><p> The <em>Round to Nearest Even</em> case may increment the significand and that may generate a carry from the <b>L-bit</b>. One option is to use <a class="el" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3" title="Vector Add &amp; write Carry Unsigned Quadword.">vec_addcuq()</a> to capture the carry. For example: </p><div class="fragment"><div class="line">...</div>
<div class="line"><span class="comment">// We add 0x3fff to GRX-bits which may carry into low order sig-bit</span></div>
<div class="line"><span class="comment">// This may result in a carry out from the L-bit into C-bit.</span></div>
<div class="line">q_carry = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) RXmask);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) RXmask);</div>
<div class="line"><span class="comment">// Generate a bool mask from the carry to use in the vsel</span></div>
<div class="line">qcmask = <a class="code" href="vec__int128__ppc_8h.html#af74036e39e72e0f3c29706d30fbb96d1">vec_setb_cyq</a> (q_carry);</div>
<div class="line"><span class="comment">// Two cases; 1) We did carry so shift (double) left 112 bits</span></div>
<div class="line">q_sigc = <a class="code" href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a> (q_carry, q_sig, 112);</div>
<div class="line"><span class="comment">// 2) no carry so shift right 15 bits</span></div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
<div class="line"><span class="comment">// Select which based on carry</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sigc, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) qcmask);</div>
<div class="line"><span class="comment">// Increment the exponent based on the carry</span></div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (q_exp, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) q_carry);</div>
</div><!-- fragment --><p> In this case having the carry as a separate vector simplifies adjusting the exponent.</p>
<p>Other cases that require quadword register pairs are QP Multiply and Multiply-Add. The product of two 113-bit significands requires 226-bits. We can use operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>. By pre-adjusting the inputs before the multiply we can align the split between the high and low 113-bits of the product to align with the high and low quadword registers. For example: </p><div class="fragment"><div class="line">... <span class="comment">// Not final</span></div>
<div class="line"><span class="comment">// Pre-align that multiply inputs so that the product is split</span></div>
<div class="line"><span class="comment">// with the L-Fraction-bits in high_sig, and GRX-bits in low_sig.</span></div>
<div class="line">a_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (a_sig, 8);</div>
<div class="line">b_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (b_sig, 7);</div>
<div class="line">low_sig = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;high_sig, a_sig, b_sig);</div>
</div><!-- fragment --><p> This simplifies the <em>Round to Odd</em> case.</p>
<h3><a class="anchor" id="f128_softfloat_IRRN_0_2"></a>
Rounding for Quad-Precision</h3>
<p>TBD</p>
<p>The PowerISA support 6 rounding modes for Quad-Precision</p>
<ul>
<li>Round to Nearest Even</li>
<li>Round towards Zero</li>
<li>Round towards +Infinity</li>
<li>Round towards -Infinity</li>
<li>Round to Nearest Away</li>
<li>Round to Odd</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>See <a href="https://www.exploringbinary.com/gcc-avoids-double-rounding-errors-with-round-to-odd/">GCC Avoids Double Rounding Errors With Round-To-Odd</a></dd></dl>
<p>The first four modes are encoded in the <b>FPSCR<sub>RN</sub></b> rounding mode bits. The last two are encoded in instructions as instruction local overrides. The VSX Scalar Round to Quad-Precision Integer instruction can override the RN and encode any of the six rounding modes.</p>
<p>The rounding mode results are defined in terms of the intermediate result (IR), and how close it is to the <em>representable result</em>, based on the GRX-bits. The IR is either; exact, closer to the next lower (NL) representable result, Midway between, or closer to the next Higher (NH) representable result,</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">G </th><th class="markdownTableHeadCenter">R </th><th class="markdownTableHeadCenter">X </th><th class="markdownTableHeadLeft">interpretation  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyLeft">IR is exact  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyLeft">IR is closer to NL  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyLeft">IR is closer to NL  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyLeft">IR is closer to NL  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyLeft">IR is midway between NL and NH  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyLeft">IR is closer to NH  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyLeft">IR is closer to NH  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyLeft">IR is closer to NH  </td></tr>
</table>
<p>Next lower is effectively truncating the IR (setting GRX = 0b000), while next higher will increment the significand by one.</p>
<ul>
<li>Round to Nearest Even<ul>
<li>If exact chose IR</li>
<li>Otherwise if IR is closer to NL, choose NL</li>
<li>Otherwise if IR is closer to NH, choose NH</li>
<li>Otherwise if IR in midway, choose whichever makes the result even.</li>
</ul>
</li>
<li>Round towards Zero<ul>
<li>If exact chose IR</li>
<li>Otherwise, choose NL</li>
</ul>
</li>
<li>Round towards +Infinity<ul>
<li>If exact chose IR</li>
<li>Otherwise if positive, choose NH</li>
<li>Otherwise if negative, choose NL</li>
</ul>
</li>
<li>Round towards -Infinity<ul>
<li>If exact chose IR</li>
<li>Otherwise if positive, choose NL</li>
<li>Otherwise if negative, choose NH</li>
</ul>
</li>
<li>Round to Nearest Away<ul>
<li>If exact chose IR</li>
<li>Otherwise if G = 0, choose NL</li>
<li>Otherwise if G = 1, choose NH</li>
</ul>
</li>
<li>Round to Odd<ul>
<li>If exact chose IR</li>
<li>Otherwise, choose NL, and if G=1, or R=1, or X=1, set the least significant bit to 1.</li>
</ul>
</li>
</ul>
<p>Coding examples TBD. Full examples waiting for VSX Scalar Round to Quad-Precision Integer implementation.</p>
<p>Coding example for Round to Nearest, ties to even. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> RXmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>( 0, 0, 0, 0x3fff);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> lowmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>( 0, 0, 0, 1);</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_carry, q_sigc;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> qcmask;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_odd;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The Significand (including the L-bit) is right justified in</span></div>
<div class="line"><span class="comment">// in the high-order 113-bits of q_sig.</span></div>
<div class="line"><span class="comment">// The guard, round, and sticky (GRX) bits are in the low-order</span></div>
<div class="line"><span class="comment">// 15 bits.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// For &quot;round to Nearest, ties to even&quot;.</span></div>
<div class="line"><span class="comment">// GRX = 0b001 - 0b011; truncate</span></div>
<div class="line"><span class="comment">// GRX = 0b100 and bit-112 is odd; round up, otherwise truncate</span></div>
<div class="line"><span class="comment">// GRX = 0b100 - 0b111; round up</span></div>
<div class="line"><span class="comment">// We simplify by copying bit-112 and ORing it with X-bits.</span></div>
<div class="line"><span class="comment">// Then add 0x3fff to q_sig will generate a carry into bit-112</span></div>
<div class="line"><span class="comment">// if and only if GRX &gt; 0b100 or (GRX == 0b100) &amp;&amp; (bit-112 == 1)</span></div>
<div class="line"><span class="comment">// Isolate bit-112 and OR into GRX bits if q_sig is odd</span></div>
<div class="line">q_odd = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) <a class="code" href="vec__int16__ppc_8h.html#a292973c417034f4b8813765b63ca03c2">vec_srhi</a> ((<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>)q_sig, 15);</div>
<div class="line">q_odd = vec_and (q_odd, lowmask);</div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_odd);</div>
<div class="line"><span class="comment">// Now we round by adding 0x3fff to GRX-bits, which may</span></div>
<div class="line"><span class="comment">// carry into bit-112, incrementing the significand.</span></div>
<div class="line"><span class="comment">// This may result in a carry out of bit L into bit-C.</span></div>
<div class="line">q_carry = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) RXmask);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) RXmask);</div>
<div class="line"><span class="comment">// Now we have two cases with and without carry/renormalize</span></div>
<div class="line"><span class="comment">// Generate a bool mask from the carry to use in the vsel</span></div>
<div class="line">qcmask = <a class="code" href="vec__int128__ppc_8h.html#af74036e39e72e0f3c29706d30fbb96d1">vec_setb_cyq</a> (q_carry);</div>
<div class="line"><span class="comment">// case 1) We did carry so shift left (double quadword) 112 bits</span></div>
<div class="line">q_sigc = <a class="code" href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a> (q_carry, q_sig, 112);</div>
<div class="line"><span class="comment">// case 2) no carry so shift right 15 bits</span></div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
<div class="line"><span class="comment">// Select result based on on carry bool</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sigc, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) qcmask);</div>
<div class="line"><span class="comment">// Increment the exponent based on the carry-bit</span></div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (q_exp, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) q_carry);</div>
</div><!-- fragment --><p> This code runs about 16 instructions.</p>
<p>Coding example for Round toward Zero </p><div class="fragment"><div class="line"><span class="comment">// Simplest case, shift right 15 bits</span></div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
</div><!-- fragment --><p> This code runs about 3 instructions.</p>
<p>Coding example for Round to Odd </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> RXmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>( 0, 0, 0, 0x7fff);</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_odd;</div>
<div class="line"><span class="comment">// For &quot;round to Odd&quot;.</span></div>
<div class="line"><span class="comment">// If if G=1,  or R=1, or X=1, Set least significant bit to 1.</span></div>
<div class="line"><span class="comment">// Isolate GRX bit then add the mask.</span></div>
<div class="line">q_odd = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_siq, RXmask);</div>
<div class="line"><span class="comment">// The add will generate a carry into bit 112, for none-zero GRX</span></div>
<div class="line">q_odd = vec_add (q_odd, RXmask);</div>
<div class="line"><span class="comment">// Or this into bit 112 of the q_sig.</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_odd);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
</div><!-- fragment --><p> This code runs about 6 instructions to load the mask and round=odd.</p>
<h2><a class="anchor" id="f128_softfloat_0_0_1"></a>
Quad-Precision compares for POWER8</h2>
<p>IEEE floating-point compare is a bit more complicated than binary integer compare operations. The two main complications are; Not-a-Number (NaN) which IEEE insists are <em>unordered</em>, and signed 0.0 where IEEE insists that -0.0 is equal to +0.0. If you ignore the NaN and signed 0.0 cases you can treat floating-point values as signed magnitude binary integers, and use integer compares and boolean logic. Which looks like this:</p>
<ul>
<li>a =<sup>f</sup> b == (a =<sup>s</sup> b)</li>
<li>a &lt;<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;<sup>s</sup> b) | (a &lt;<sup>s</sup> 0 &amp; a &gt;<sup>u</sup> b)</li>
<li>a &lt;=<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;=<sup>s</sup> b) | (a &lt;<sup>s</sup> 0 &amp; a &gt;=<sup>u</sup> b)</li>
</ul>
<p>Where; =<sup>f</sup>, &lt;<sup>f</sup>, and &lt;=<sup>f</sup> are the desired floating-point compares, =<sup>s</sup>, &lt;<sup>s</sup>, &lt;=<sup>s</sup>, &gt;<sup>s</sup> and &gt;=<sup>s</sup>, are signed integer compares, and =<sup>s</sup>, &gt;<sup>u</sup>, and &gt;=<sup>u</sup> are unsigned integer compares.</p>
<dl class="section see"><dt>See also</dt><dd>"Hacker's Delight, 2nd Edition," Henry S. Warren, Jr, Addison Wesley, 2013. Chapter 17, Floating-point, Section 17-3 Comparing Floating-Point Numbers Using Integer Operations.</dd></dl>
<p>One key implication of this is that we will need signed and unsigned 128-bit compare operations. Instructions for 128-bit integer compares was added for PowerISA 3.1 (POWER10) but we also need to support POWER8/9. The good news is that PowerISA 2.07B (POWER8) includes Vector Add/Subtract Modulo/Carry/Extend Quadword instructions. Specifically Vector Subtract &amp; write Carry Unsigned Quadword can implement all the unsigned ordered (&lt;. &lt;=, &gt;, &gt;=) compares by manipulating the comparand order and evaluating the carry for 0 or 1.</p>
<p>POWER8 also includes vector doubleword integer compare instructions. And the Vector Compare Equal To Unsigned Doubleword instruction can be used with a few additional logical operations to implement 128-bit equal and not equal operations. These operations are already provided by <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<p>Some additional observations:</p><ul>
<li>The unsigned compare equal can be used for unsigned or signed integers.</li>
<li>(a &gt;=<sup>s</sup> 0) == ~(a &lt;<sup>s</sup> 0).<ul>
<li>So we only need one compare boolean and the binary NOT.</li>
<li>((a &gt;=<sup>s</sup> 0) &amp; a &lt;<sup>s</sup> b) | (~(a &gt;=<sup>s</sup> 0) &amp; a &gt;<sup>u</sup> b).</li>
<li>Now this starts to look like a vector select operation.</li>
<li>(src1 &amp; ~mask) | (src2 &amp; mask)</li>
</ul>
</li>
<li>(a &gt;=<sup>s</sup> 0) is a special case that only depends on the sign-bit.<ul>
<li>A unsigned compare can be used with a slight change,</li>
<li>Propagating the sign-bit across the (quad)word generates the same boolean. This is the <a class="el" href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802" title="Vector Set Bool from Signed Quadword.">vec_setb_sq()</a> operation. The __float128 variant is <a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73" title="Vector Set Bool from Quadword Floating-point.">vec_setb_qp()</a></li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The examples that follow, use vector __int128 parameters instead of __binary128 to avoid the hassles of cast incompatibility between scalar __binary128's and vector types. The actual implementations use the xfer functions.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line">test_cmpltf128_v1c (<a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfa128, <a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfb128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> altb, agtb;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> signbool;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Replace (vfa &gt;= 0) with (vfa &lt; 0) == vec_setb_qp (vfa)</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> shift = vec_splat_u8 (7);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> splat = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfa128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  signbool = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (splat, shift);</div>
<div class="line"> </div>
<div class="line">  altb = <a class="code" href="vec__int128__ppc_8h.html#a82d83d78ff2330205a8d74741b34a1be">vec_cmpltsq</a> (vfa128, vfb128);</div>
<div class="line">  agtb = <a class="code" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfa128, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfb128);</div>
<div class="line">  result = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)altb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)agtb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)signbool);</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we can tackle the pesky signed 0.0 case. The simplest method is to add another term that test for either a or b is -0.0. This simplifies to just logical a OR b and unsigned compare to -0.0. Which looks like this:</p>
<ul>
<li>a =<sup>f</sup> b == (a =<sup>s</sup> b) | ((a | b) == 0x80000000...0)</li>
<li>a &lt;<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;<sup>s</sup> b) | ((a &lt;<sup>s</sup> 0 &amp; a &gt;<sup>u</sup> b) &amp; ((a | b) != 0x80000000...0))</li>
<li>a &lt;=<sup>f</sup> b == (a &gt;=<sup>s</sup> 0 &amp; a &lt;=<sup>s</sup> b) | ((a &lt;<sup>s</sup> 0 &amp; a &gt;=<sup>u</sup> b) | ((a | b) == 0x80000000...0))</li>
</ul>
<p>Again we can replace signed compares (a &gt;= 0) and (a &lt; 0) with a single <a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73" title="Vector Set Bool from Quadword Floating-point.">vec_setb_qp()</a> and simplify the boolean logic by using vec_sel(). For the ((a | b) != 0x80000000...0) term we can save an instruction by replacing <a class="el" href="vec__int128__ppc_8h.html#a186d0b94bbc652e700ab4e1733b9524c" title="Vector Compare Not Equal Unsigned Quadword.">vec_cmpneuq()</a> with <a class="el" href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0" title="Vector Compare Equal Unsigned Quadword.">vec_cmpequq()</a> and replacing the AND operation with AND compliment. </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line">test_cmpltf128_v2c (<a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfa128, <a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> vfb128)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> altb, agtb, nesm;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> or_ab;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> signbool;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Replace (vfa &gt;= 0) with (vfa &lt; 0) == vec_setb_qp (vfa)</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> shift = vec_splat_u8 (7);</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> splat = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfa128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  signbool = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (splat, shift);</div>
<div class="line"> </div>
<div class="line">  altb = <a class="code" href="vec__int128__ppc_8h.html#a82d83d78ff2330205a8d74741b34a1be">vec_cmpltsq</a> (vfa128, vfb128);</div>
<div class="line">  agtb = <a class="code" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfa128, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfb128);</div>
<div class="line"> </div>
<div class="line">  or_ab = vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfa128, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfb128 );</div>
<div class="line">  <span class="comment">// For ne compare eq and and compliment</span></div>
<div class="line">  nesm = <a class="code" href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0">vec_cmpequq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) or_ab, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) signmask);</div>
<div class="line">  agtb = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_andc ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) agtb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) nesm);</div>
<div class="line">  <span class="comment">// select altb for 0&#39;s and agtb for 1&#39;s</span></div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)altb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)agtb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)signbool);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This sequence runs27 instructions when you include the constant loads.</p>
<p>An alternative compare method converts both floating-point values in a way that a single (unsigned) integer compare can be used.</p>
<div class="fragment"><div class="line"><span class="comment">// for each comparand</span></div>
<div class="line"> <span class="keywordflow">if</span> (n &gt;= 0)</div>
<div class="line">   n = n + 0x80000000;</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">   n = -n;</div>
<div class="line"><span class="comment">// Use unsigned integer comparison</span></div>
</div><!-- fragment --><p> An interesting feature of this method is that +0.0 becomes (0x00000000 + 0x80000000 = 0x80000000) and -0.0 becomes (0x80000000 - 0x80000000 = 0x80000000) which effectively converts any -0.0 into +0.0 for comparison. Signed 0.0 solved.</p>
<p>Another optimization converts (n = n + 0x80000000) to (n = n XOR 0x80000000). Gives the same result and for POWER8 a vec_xor() is 2 cycles latency vs 4 cycles for _vec_adduqm().</p>
<div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div>
<div class="line">test_cmpltf128_v3d (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vfa128, <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vfb128)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> zero = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> shift = vec_splat_u8 (7);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> result;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> age0, bge0;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vra, vrap, vran;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vrb, vrbp, vrbn;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> splta, spltb;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// signbool = vec_setb_qp;</span></div>
<div class="line">  splta = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfa128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  age0 = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (splta, shift);</div>
<div class="line"> </div>
<div class="line">  vrap = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_xor ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfa128, signmask);</div>
<div class="line">  vran = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) zero, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfa128);</div>
<div class="line">  vra  = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrap, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vran, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)age0);</div>
<div class="line"> </div>
<div class="line">  spltb = vec_splat ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vfb128, <a class="code" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>);</div>
<div class="line">  bge0 = (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_sra (spltb, shift);</div>
<div class="line"> </div>
<div class="line">  vrbp = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_xor ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vfb128, signmask);</div>
<div class="line">  vrbn = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) zero, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vfb128);</div>
<div class="line">  vrb  = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrbp, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrbn, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)bge0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int128__ppc_8h.html#a7f9ebc5ad32b151a3e08136d51aad4dc">vec_cmpltuq</a> (vra, vrb);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This sequence runs (approximately) 20 instructions when you include loading the required constants. It also manages to use only splat-immediate forms to load constants and so does not need to establish the TOC pointer nor any address calculations to access constants via load instructions.</p>
<p>The next IEEE issue is detecting NaNs and returning <em>unordered</em> status. Adding the following code to a compare operation insures that if either comparand is NaN; false (unordered) is returned for compares (eq, lt, gt).</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (vfa) || <a class="code" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (vfb))</div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>) vec_splat_u32 (0);</div>
</div><!-- fragment --><p> The pair of <a class="el" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89" title="Return true if the __float128 value is Not a Number (NaN).">vec_all_isnanf128()</a> operations add significant overhead both in code size (39 instructions) and cycles. This form should only be used if is required for correct results and has not been tested by prior logic in this code path.</p>
<dl class="section note"><dt>Note</dt><dd>At this point we are not trying to comply with PowerISA by setting any FPSCR bits associated with Quad-Precision compare. If such is required, VXSNAN and/or VXVC can be set using the Move To FPSCR Bit 1 (mtfsb1) instruction.</dd></dl>
<h2><a class="anchor" id="f128_softfloat_0_0_2"></a>
Quad-Precision converts for POWER8</h2>
<p>IEEE floating-point conversions are also a bit complicated. Dealing with Not-a-Number (NaN), Infinities and subnormal is part of it. But the conversion may also require normalization and rounding depending on element size and types involved. Some examples:</p><ul>
<li>Double precision floats and long long integers can be represented exactly in Quad precision float. But:</li>
<li>Down conversions (to doubleword) from Quad-Precision may require rounding/truncation.<ul>
<li>Conversions to integer that overflow are given special values.</li>
</ul>
</li>
<li>Conversions between QP and quadword integer may also require rounding/truncation.<ul>
<li>128-bit integer values may not fit into the QPs 113-bit significand.</li>
</ul>
</li>
</ul>
<p>For PowerISA 3.0 (POWER9) includes full hardware instruction support for Quad-Precision, Including:</p><ul>
<li>Conversions between Quad-Precison and Double floating-point (xscvdpqp, xscvqpdp[o]).</li>
<li>Conversions between Quad-Precison and doubleword and word integer (xscvqpsdz, xscvqpswz, xscvqpudz, xscvqpuwz, xscvsdqp, xscvudqp).</li>
</ul>
<p>PowerISA 3.1 (POWER10) includes:</p><ul>
<li>Conversions between Quad-Precison and quadword integer (xscvqpsqz, xscvqpuqz, xscvsqqp, xscvuqqp).</li>
</ul>
<p>For POWER8 (and earlier) we need to do a little more work The general plan for conversion starts by disassembling the input value into its parts and analyze. For signed integer values disassemble usually means sign and unsigned magnitude. Analysis might be a range check or counting leading zeros. For floating point values this is usually sign, exponent, and significand. Analysis usually means determining the data class (NaN, infinity, normal, subnormal, zero) as each requires special handling in the conversion.</p>
<p>Conversion involves adjusting the <em>parts</em> as needed to match the type of the result. This is normally only adds and shifts. Finally we need to reassemble the parts based on the result type. For integers this normally just converting the unsigned magnitude to a signed '2's complement value based on the sign of the input. For floating-point this requires merging the sign bit with the (adjusted) significand and merging that with the (adjusted) exponent.</p>
<p>The good news is that all of the required operations are already available in <b>altivec.h</b> or PVECLIB.</p>
<h3><a class="anchor" id="f128_softfloat_0_0_2_0"></a>
Convert Double-Precision to Quad-Precision</h3>
<p>This is one of the simpler conversions as the conversion is always exact (no rounding/truncation is required, and no overflow is possible). The process starts with disassembling the double-precision value. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line">f64[<a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>] = 0.0; <span class="comment">// clear the right most element to zero.</span></div>
<div class="line"><span class="comment">// Extract the exponent, significand, and sign bit.</span></div>
<div class="line">d_exp = <a class="code" href="vec__f64__ppc_8h.html#acb534c11a544d9e0b61acdecbb62adaa">vec_xvxexpdp</a> (f64);</div>
<div class="line">d_sig = <a class="code" href="vec__f64__ppc_8h.html#af8b42004c11b01c7606d8d6e299e8107">vec_xvxsigdp</a> (f64);</div>
<div class="line">q_sign = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) f64, signmask);</div>
</div><!-- fragment --><p> We insure that the low-order doubleword of the vector f64 is zeroed. This is necessary for then we normalize the 128-bit significand for the quad-precision result. The operations <a class="el" href="vec__f64__ppc_8h.html#acb534c11a544d9e0b61acdecbb62adaa" title="Vector Extract Exponent Double-Precision.">vec_xvxexpdp()</a> and <a class="el" href="vec__f64__ppc_8h.html#af8b42004c11b01c7606d8d6e299e8107" title="Vector Extract Significand Double-Precision.">vec_xvxsigdp()</a> are provided by <a class="el" href="vec__f64__ppc_8h.html" title="Header package containing a collection of 128-bit SIMD operations over 64-bit double-precision floati...">vec_f64_ppc.h</a> supporting both the POWER9 instruction and equivalent implementation for POWER8. And finally we extract the sign-bit. We can't use the copysign() here due to the difference in type.</p>
<p>Now we analyze the data class of the double-precision input. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#a6bdfdf013a97ccd6dc20b1447f81d498">vec_all_isfinitef64</a> (f64))</div>
<div class="line">  { <span class="comment">// Not NaN or Inf</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#ab63ac21e968bf199eadd72f94b653905">vec_all_isnormalf64</a> (vec_splat (f64, <a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>)))</div>
<div class="line">      {</div>
<div class="line">      <span class="comment">// ... adjust exponent and expand significand</span></div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      { <span class="comment">// Must be zero or subnormal</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#a27becc842e7270c96c54a00d4a292d54">vec_all_iszerof64</a> (f64))</div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// ... copy zero exponent and significand</span></div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          { <span class="comment">// Must be subnormal</span></div>
<div class="line">            <span class="comment">// ... normalize signifcand for QP and adjust exponent</span></div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  { <span class="comment">// isinf or isnan.</span></div>
<div class="line">    <span class="comment">// ... set exponent to QP max and expand significand</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p> This code is arranged with an eye to the most common cases and specifics of the conversion required by each data class. The operations <a class="el" href="vec__f64__ppc_8h.html#a6bdfdf013a97ccd6dc20b1447f81d498" title="Return true if all 2x64-bit vector double values are Finite (Not NaN nor Inf).">vec_all_isfinitef64()</a>, <a class="el" href="vec__f64__ppc_8h.html#ab63ac21e968bf199eadd72f94b653905" title="Return true if all 2x64-bit vector double values are normal (Not NaN, Inf, denormal,...">vec_all_isnormalf64()</a> and <a class="el" href="vec__f64__ppc_8h.html#a27becc842e7270c96c54a00d4a292d54" title="Return true if all 2x64-bit vector double values are +-0.0.">vec_all_iszerof64()</a> are provided by <a class="el" href="vec__f64__ppc_8h.html" title="Header package containing a collection of 128-bit SIMD operations over 64-bit double-precision floati...">vec_f64_ppc.h</a> supporting both the POWER9 instruction and equivalent implementation for POWER8.</p>
<p>The normal case requires shifting the significand and adjusting the exponent. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_delta = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( (0x3fff - 0x3ff), 0 );</div>
<div class="line">        ...</div>
<div class="line">        q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 4);</div>
<div class="line">        q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (d_exp, exp_delta);</div>
</div><!-- fragment --><p> The double significand has the fraction bits starting a bit-12 and the implied '1' in bit-11. For quad-precision we need to shift this right 4-bits to align the fraction to start in bit-16. We need a quadword shift as the significand will now extend into the high order bits of the second (low order) doubleword. To adjust the exponent we need to convert the double biased exponent (1 to 2046) into unbiased (-1022 to +1023) by subtracting the exponent bias (+1023 or 0x3ff) value. Then we can add the quad-precision exponent bias (+16383 or 0x3fff) to compute the final exponent. We can combine the bias difference into a single constant (0x3fff - 0x3ff) and only need a single add at runtime.</p>
<p>The operations <a class="el" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c" title="Vector Shift Right Quadword Immediate.">vec_srqi()</a> is provided by <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a> and <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo.">vec_addudm()</a> is provided by <a class="el" href="vec__int64__ppc_8h.html" title="Header package containing a collection of 128-bit SIMD operations over 64-bit integer elements.">vec_int64_ppc.h</a>. We use PVECLIB operations here to insure that this code is safe to use with older compilers and pre-POWER8 processors.</p>
<p>The zero case requires setting the quad-precision significand and exponent to zero. </p><div class="fragment"><div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig;</div>
<div class="line">q_exp = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) d_exp;</div>
</div><!-- fragment --><p> We know that the double significand and exponent are zero, so just assign them to the quad-precision parts. The sign bit will applied later with the common insert exponent code.</p>
<p>The subnormal case is a bit more complicated. The tricky part is while the double-precision value is subnormal the equivalent quad-precision value is not. So we need to normalize the significand and compute a new exponent. </p><div class="fragment"><div class="line"><span class="comment">// Need to adjust the quad exponent by the f64 denormal exponent</span></div>
<div class="line"><span class="comment">// (-1023) knowing that the f64 sig will have at least 12 leading &#39;0&#39;s</span></div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_denorm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( (16383 - (1023 -12)), 0 );</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> f64_clz;</div>
<div class="line">f64_clz = <a class="code" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a> (d_sig);</div>
<div class="line">d_sig = <a class="code" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a> (d_sig, f64_clz);</div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_denorm, f64_clz);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 15);</div>
</div><!-- fragment --><p> We use a doubleword count leading zeros (ctz) and shift left to normalize the significand so that the first '1'-bit moves to bit-0. Then we compute the quad-precision exponent by subtracting the ctz value from a constant (16383 - (1023 -12)). This represents the quad-precision exponent bias, minus the double-precsion exponent bias, minus the minimum leading zero count for the double-precision subnormal significand.</p>
<p>The NaN/Infinity case requires shifting the significand and setting the exponent to quad-precision max. </p><div class="fragment"><div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 4);</div>
<div class="line">q_exp = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>(0x7fff, 0);</div>
</div><!-- fragment --><p> We need this shift as NaN has a non-zero significand and it might be nonzero in one of the low order bits. Separating out the infinity case (where the significand is zero) is not worth the extra (isnan) test to avoid the shift.</p>
<p>Now all the parts are converted to quad-precision, we are ready to reassemble the QP result. </p><div class="fragment"><div class="line"><span class="comment">// Copy Sign-bit to QP significand before insert.</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_sign);</div>
<div class="line"><span class="comment">// Insert exponent into significand to complete conversion to QP</span></div>
<div class="line">result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
</div><!-- fragment --><p>Putting this all together we get something like: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d_exp, d_sig, q_exp;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_sign;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_delta = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( (0x3fff - 0x3ff), 0 );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line">f64[<a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>] = 0.0; <span class="comment">// clear the right most element to zero.</span></div>
<div class="line"><span class="comment">// Extract the exponent, significand, and sign bit.</span></div>
<div class="line">d_exp = <a class="code" href="vec__f64__ppc_8h.html#acb534c11a544d9e0b61acdecbb62adaa">vec_xvxexpdp</a> (f64);</div>
<div class="line">d_sig = <a class="code" href="vec__f64__ppc_8h.html#af8b42004c11b01c7606d8d6e299e8107">vec_xvxsigdp</a> (f64);</div>
<div class="line">q_sign = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) f64, signmask);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#a6bdfdf013a97ccd6dc20b1447f81d498">vec_all_isfinitef64</a> (f64))</div>
<div class="line">  { <span class="comment">// Not NaN or Inf</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#ab63ac21e968bf199eadd72f94b653905">vec_all_isnormalf64</a> (vec_splat (f64, <a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>)))</div>
<div class="line">      {</div>
<div class="line">        q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 4);</div>
<div class="line">        q_exp = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (d_exp, exp_delta);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      { <span class="comment">// zero or subnormal</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="vec__f64__ppc_8h.html#a27becc842e7270c96c54a00d4a292d54">vec_all_iszerof64</a> (f64))</div>
<div class="line">          {</div>
<div class="line">            q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig;</div>
<div class="line">            q_exp = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) d_exp;</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          { <span class="comment">// Must be subnormal</span></div>
<div class="line">            <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_denorm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( (0x3fff - 1023 -12), 0 );</div>
<div class="line">            <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> f64_clz;</div>
<div class="line">            f64_clz = <a class="code" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a> (d_sig);</div>
<div class="line">            d_sig = <a class="code" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a> (d_sig, f64_clz);</div>
<div class="line">            q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_denorm, f64_clz);</div>
<div class="line">            q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 15);</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  { <span class="comment">// isinf or isnan.</span></div>
<div class="line">    q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 4);</div>
<div class="line">    q_exp = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>(0x7fff, 0);</div>
<div class="line">  }</div>
<div class="line"><span class="comment">// Copy Sign-bit to QP significand before insert.</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_sign);</div>
<div class="line"><span class="comment">// Insert exponent into significand to complete conversion to QP</span></div>
<div class="line">result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
</div><!-- fragment --><p>At this stage we have a functionally correct implementation and now we can look for opportunities for optimization. One issue is the generated code is fairly large (~436 bytes and ~100 instructions). For POWER8 the data class predicates (vec_all_isfinitef64, etc) each require one or more vector constant loads and bit mask operations before the associated vector compares. Also the extract significand operation requires the equivalent of isnormal (with two vector compares) as preparation for conditionally restoring the implied (hidden) bit.</p>
<p>By testing the extracted (exponent and significand) parts directly we can simplify the compare logic and eliminate some (redundant) vector constant loads. For example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d_naninf = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0x7ff, 0 );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d_denorm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0, 0 );</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// The extract sig operation has already tested for finite/subnormal.</span></div>
<div class="line"><span class="comment">// So avoid testing isfinite/issubnormal again by simply testing</span></div>
<div class="line"><span class="comment">// the extracted exponent.</span></div>
<div class="line"><span class="keywordflow">if</span> (__builtin_expect (!<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (d_exp, d_naninf), 1))</div>
<div class="line">  { <span class="comment">// Not Nan or Inf</span></div>
<div class="line">    <span class="keywordflow">if</span> (__builtin_expect (!<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (d_exp, d_denorm), 1))</div>
<div class="line">      {</div>
<div class="line">      <span class="comment">// ... adjust exponent and expand significand</span></div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      { <span class="comment">// Must be zero or subnormal</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (d_sig, d_denorm))</div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// ... copy zero exponent and significand</span></div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          { <span class="comment">// Must be subnormal</span></div>
<div class="line">            <span class="comment">// ... normalize signifcand for QP and adjust exponent</span></div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  { <span class="comment">// isinf or isnan.</span></div>
<div class="line">    <span class="comment">// ... set exponent to QP max and expand significand</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p> The implementation based on this logic is smaller (~300 bytes and ~75 instructions). Performance results TBD.</p>
<h3><a class="anchor" id="f128_softfloat_0_0_2_1"></a>
Convert Doubleword integer to Quad-Precision</h3>
<p>Converting binary integers to floating point is simpler as there are fewer data classes to deal with. Basically zero and non-zero numbers (no signed 0s, infinities or NaNs). Also the conversion from 64-bit integers to 128-bit floating-point is always exact (there is no rounding).</p>
<p>Unsigned doubleword is the simplest case. We only need to test for binary zero. If zero just return a QP +0.0 constant. Otherwise we can treat the binary magnitude as a denormalized number and normalize it. The binary zero test and processing looks like this: </p><div class="fragment"><div class="line">int64[<a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>] = 0UL; <span class="comment">// clear the right most element to zero.</span></div>
<div class="line"><span class="comment">// Quick test for 0UL as this case requires a special exponent.</span></div>
<div class="line">d_sig = int64;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (int64, d_zero))</div>
<div class="line">  { <span class="comment">// Zero sign, exponent and significand.</span></div>
<div class="line">    result = <a class="code" href="vec__f128__ppc_8h.html#ae8002c29875a226d11ec57a42b5b3955">vec_xfer_vui64t_2_bin128</a> (d_zero);</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span> ...</div>
</div><!-- fragment --><p> For the non-zero case we assume the binary point follows the unit bit (bit-63) of the 64-bit magnitude. Then we use count leading zeros to find the first significant bit. This count is used to normalize/shift (left justify) the magnitude and adjust the QP exponent to reflect the binary point following the unit (original doubleword bit 63) bit. So far we are using only doubleword data and instructions. </p><div class="fragment"><div class="line">{ <span class="comment">// We need to produce a normalized QP, so we treat the integer</span></div>
<div class="line">  <span class="comment">// like a denormal, then normalize it.</span></div>
<div class="line">  <span class="comment">// Start with the quad exponent bias + 63 then subtract the count of</span></div>
<div class="line">  <span class="comment">// leading &#39;0&#39;s. The 64-bit sig can have 0-63 leading &#39;0&#39;s.</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_expm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>((0x3fff + 63), 0 );</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> i64_clz = <a class="code" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a> (int64);</div>
<div class="line">  d_sig = <a class="code" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a> (int64, i64_clz);</div>
<div class="line">  q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_expm, i64_clz);</div>
<div class="line">  q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 15);</div>
<div class="line">  result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
<div class="line">}</div>
</div><!-- fragment --><p> The high order bit (after normalization) will become the <em>implicit</em> (hidden) bit in QP format. So we shift the quadword right 15-bits to become the QP significand. This shift includes the low order 64-bits we zeroed out early on and zeros out the sign-bit as a bonus. Finally we use <a class="el" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b" title="Scalar Insert Exponent Quad-Precision.">vec_xsiexpqp()</a> to merge the adjusted exponent and significand.</p>
<p>The signed doubleword conversion is bit more complicated. We deal with zero case in the same way. Otherwise we need to separate the signed doubleword into a sign-bit and unsigned 64-bit magnitude. Which looks something like this: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d_zero = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0, 0 );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line">...</div>
<div class="line">    <span class="comment">// Convert 2s complement to signed magnitude form.</span></div>
<div class="line">    q_sign = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) int64, signmask);</div>
<div class="line">    d_neg  = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (d_zero, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>)int64);</div>
<div class="line">    d_sign = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int64__ppc_8h.html#a560aef2acfdf1db1cf14848ec6cb0c1c">vec_cmpequd</a> ((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) q_sign, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) signmask);</div>
<div class="line">    <span class="comment">// Select the original int64 if positive otherwise the negated value.</span></div>
<div class="line">    d_sig = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) vec_sel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) int64, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) d_neg, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) d_sign);</div>
</div><!-- fragment --><p> The normalization process is basically the same as unsigned but we merge the sign-bit into the significant before inserting the exponent. </p><div class="fragment"><div class="line"><span class="comment">// Count leading zeros and normalize.</span></div>
<div class="line">i64_clz = <a class="code" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a> (d_sig);</div>
<div class="line">d_sig = <a class="code" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a> (d_sig, i64_clz);</div>
<div class="line">q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_expm, i64_clz);</div>
<div class="line">q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) d_sig, 15);</div>
<div class="line"><span class="comment">// Copy Sign-bit to QP significand before insert.</span></div>
<div class="line">q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_sign);</div>
<div class="line"><span class="comment">// Insert exponent into significand to complete conversion to QP</span></div>
<div class="line">result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
</div><!-- fragment --><h3><a class="anchor" id="f128_softfloat_0_0_2_2"></a>
Convert Quad-Precision to Quadword integer</h3>
<p>Convertions between quad-precision and quadword integers is complicated by the fact that the QP significand is only 113-bits while the quadword integer magnitude can be 127/128 bits. It may not be possible to represent the quadword magnitude exactly. Conversions from quad-precision float to integer may have nonzero fractions which require rounding/truncation.</p>
<p>For POWER9 we have the <b>VXS Scalar Convert with round to zero Quad-Precision to Signed/Unsigned Doubleword <em>(xscvqpsdz/xscvqpudz)</em></b> instructions. For POWER10 we have the <b>VXS Scalar Convert with round to zero Quad-Precision to Signed/Unsigned Quadword <em>(xscvqpsqz/xscvqpuqz)</em></b> instructions. Conversion using other rounding modes require using <b>VSX Scalar Round to Quad-Precision Integer <em>(xsrqpi)</em></b> instruction.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>xsrqpi</em> instruction allows for overriding the rounding mode as an immediate operand. So a two instruction sequence can implement any of the four <b>FPSCR<sub>RN</sub></b> rounding modes plus the fifth (Round to Nearest Away) mode specific to floating point integer instructions.</dd></dl>
<p>For this example we will look at Convert with round to zero Quad-Precision to Unsigned Quadword. The POWER10 operation can be implemented as a single xscvqpuqz instruction. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a></div>
<div class="line"><a class="code" href="vec__f128__ppc_8h.html#aaf9d4ad5a60e9ffaa0ca16d29f90c092">vec_xscvqpuqz</a> (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR10)  &amp;&amp; (__GNUC__ &gt;= 10)</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xscvqpuqz %0,%1&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (f128)</div>
<div class="line">      : );</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">...</div>
<div class="line">#endif</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> We use in-line assembler here as there are no current or planed compiler intrinsics for this and the C language only supports conversions between __float128 and __int128 scalars. The scalar conversions returns the __int128 result in GPR pair, while we need the result in vector register.</p>
<dl class="section note"><dt>Note</dt><dd>We could try to implement the POWER9 convert to quadword operation using two xscvqpudz instructions (at 12-cycles each). But this also requires two QP-multiplies (at 24-cycles each), plus xscvudqp/xssubqp (at 12-cycles each). So far it looks like using the POWER8 implementation for POWER9 will actually perform better.</dd></dl>
<p>The POWER8 implementation looks like this: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_exp, q_delta, x_exp;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig;</div>
<div class="line"><a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> b_sign;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_zero = { 0 };</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_ones = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_splat_s32 (-1);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_low = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0x3fff, 0x3fff );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_high = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( (0x3fff+128), (0x3fff+128) );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> exp_127 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( (0x3fff+127), (0x3fff+127) );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_naninf = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>( 0x7fff, 0x7fff );</div>
<div class="line"> </div>
<div class="line">result = q_zero;</div>
<div class="line">q_exp = <a class="code" href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a> (f128);</div>
<div class="line">q_sig = <a class="code" href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">vec_xsxsigqp</a> (f128);</div>
<div class="line">x_exp = <a class="code" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> (q_exp, <a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>);</div>
<div class="line">b_sign = <a class="code" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73">vec_setb_qp</a> (f128);</div>
<div class="line"><span class="keywordflow">if</span> (__builtin_expect (!<a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (x_exp, q_naninf), 1))</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a6264e6ca42126726b0e490754dde0db7">vec_cmpud_all_ge</a> (x_exp, exp_low)</div>
<div class="line">     &amp;&amp; <a class="code" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> ((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>)b_sign, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>)q_zero))</div>
<div class="line">      { <span class="comment">// Greater than or equal to 1.0</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a> (x_exp, exp_high))</div>
<div class="line">          { <span class="comment">// Less than 2**128-1</span></div>
<div class="line">            q_sig = <a class="code" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (q_sig, 15);</div>
<div class="line">            q_delta = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (exp_127, x_exp);</div>
<div class="line">            result = <a class="code" href="vec__int128__ppc_8h.html#a0edd172a5656b842d6586c5078284942">vec_srq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_delta);</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          { <span class="comment">// set result to 2**128-1</span></div>
<div class="line">            result = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_ones;</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      { <span class="comment">// less than 1.0 or negative</span></div>
<div class="line">        result = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  { <span class="comment">// isinf or isnan.</span></div>
<div class="line">    <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> is_inf;</div>
<div class="line">    <span class="comment">// Positive Inf returns all ones</span></div>
<div class="line">    <span class="comment">// else NaN or -Infinity returns zero</span></div>
<div class="line">    is_inf = <a class="code" href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0">vec_cmpequq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_zero);</div>
<div class="line">    <span class="comment">// result = ~NaN | (pos &amp; Inf) -&gt; Inf &amp; (pos &amp; Inf) -&gt; pos &amp; Inf</span></div>
<div class="line">    result = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_andc ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) is_inf, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) b_sign);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> As is the usual for floating-point conversions, we extract the sign, significand, and exponent then test for class and range. We compare the extracted exponent directly using vector doubleword compares. These are faster (on POWER8) than quadword compares but require doubleword splatting the QP exponent and compare constants for correct results. This only requires one additional instruction (xxpermdi) as the vector constants will be loaded as quadwords either way.</p>
<p>The outter test is for NaN/Infinity. These should be rare so we use __builtin_expect(). The implementation returns special values to match the instruction definition.</p>
<p>Once we know the value is finite, we check for greater than or equal to +1.0. Negative or fractional values return quadword zero. Then we check for less than 2<sup>128</sup>. If not we return all ones (2<sup>128</sup> -1).</p>
<p>If the input is in the valid range for unsigned quadword we left-justify the significand then shift the quadword right by (127 - <sub>unbiased</sub>exp). The right shift truncates (round toward zero) any fractional bits. See <a class="el" href="vec__f128__ppc_8h.html#aaf9d4ad5a60e9ffaa0ca16d29f90c092" title="VXS Scalar Convert with round to zero Quad-Precision to Unsigned Quadword.">vec_xscvqpuqz()</a>.</p>
<p>The signed operation follows similar logic with appropriate adjustments for negative values and reduced magnitude range. The doubleword versions of the convert operation follows the same outline with different range constants. See vec_xscvqpsqz(), <a class="el" href="vec__f128__ppc_8h.html#a73ad56c509ea22f26fb2d47217bc5e51" title="VXS Scalar Convert with round to zero Quad-Precision to Unsigned doubleword.">vec_xscvqpudz()</a> and vec_xscvqpsdz().</p>
<h3><a class="anchor" id="f128_softfloat_0_0_2_3"></a>
Convert Quadword integer to Quad-Precision</h3>
<p>TBD</p>
<p>Conversions from doubleword integer to quad-precision float can be represented exactly and do not require any rounding. But conversions from quadword integer to quad-precision float may overflow the 113-bit significand which does require rounding.</p>
<p>For POWER9 we have the <b>VSX Scalar Convert Signed/Unsigned Doubleword to Quad-Precision format <em>(xscvsdqp/xscvudqp)</em></b> instructions. For POWER10 we have the <b>VVSX Scalar Convert with round Signed/Unsigned Quadword to Quad-Precision format <em>(xscvsqqp/xscvuqqp)</em></b> instructions. One of four rounding modes is selected from the 2-bit <b>FPSCR.<sub>RN</sub></b> field. The default rounding mode is <em>Round to Nearest, ties to even</em> which we will use in this example. Conversion using other rounding modes changing the <b>FPSCR.<sub>RN</sub></b> field.</p>
<p>For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8">vec_xscvuqqp</a> (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> int128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR10)  &amp;&amp; (__GNUC__ &gt;= 10)</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xscvuqqp %0,%1&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (int128)</div>
<div class="line">      : );</div>
<div class="line"><span class="preprocessor">#elif defined (_ARCH_PWR9) &amp;&amp; defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> int64 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) int128;</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> hi64, lo64;</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> two64 = 0x1.0p64;</div>
<div class="line">  hi64 = int64[<a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>];</div>
<div class="line">  lo64 = int64[<a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>];</div>
<div class="line">  result = (hi64 * two64) + lo64;</div>
<div class="line"><span class="preprocessor">#elif  defined (_ARCH_PWR8)</span></div>
<div class="line">...</div>
<div class="line">#endif</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The POWER10 implementation uses the <b>xscvuqqp</b> instruction. While POWER9 implementation uses <b>xscvudqp</b> instructions to convert the high/low 64-bit halves of the quadword integer. To complete the conversion we need to multiply the converted high 64-bits by 2**64 than add the lower converted 64-bits. The compiler should generate something like this: </p><div class="fragment"><div class="line">&lt;test_vec_xscvuqqp_PWR9&gt;:</div>
<div class="line">     addis   r9,r2,0 ## R_PPC64_TOC16_HA   .rodata.<span class="stringliteral">&quot;0x1.0p64&quot;</span></div>
<div class="line">     addi    r9,r9,0 ## R_PPC64_TOC16_LO   .rodata.<span class="stringliteral">&quot;0x1.0p64&quot;</span></div>
<div class="line">     xxspltd v0,v2,1</div>
<div class="line">     xscvudqp v2,v2</div>
<div class="line">     xscvudqp v0,v0</div>
<div class="line">     lxv     v1,0(r9)</div>
<div class="line">     xsmaddqp v2,v0,v1</div>
<div class="line">     blr</div>
</div><!-- fragment --><p>The POWER8 implementation looks like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#elif  defined (_ARCH_PWR8)</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_exp;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_zero = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) { 0 };</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> lowmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>( 0, 0, 0, 1);</div>
<div class="line"> </div>
<div class="line">  q_sig = int128;</div>
<div class="line">  <span class="comment">// Quick test for 0UL as this case requires a special exponent.</span></div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a> (q_sig, q_zero))</div>
<div class="line">    {</div>
<div class="line">      result = <a class="code" href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">vec_xfer_vui128t_2_bin128</a> (q_zero);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    { <span class="comment">// We need to produce a normal QP, so we treat the QW integer</span></div>
<div class="line">      <span class="comment">// like a denormal, then normalize it.</span></div>
<div class="line">      <span class="comment">// Start with the quad exponent bias + 127 then subtract the count of</span></div>
<div class="line">      <span class="comment">// leading &#39;0&#39;s. The 128-bit sig can have 0-127 leading &#39;0&#39;s.</span></div>
<div class="line">      <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_expm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>(0, (0x3fff + 127));</div>
<div class="line">      <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> i64_clz = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49">vec_clzq</a> (q_sig);</div>
<div class="line">      q_sig = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) i64_clz);</div>
<div class="line">      q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_expm, i64_clz);</div>
<div class="line">      <span class="comment">// This is the part that might require rounding.</span></div>
<div class="line">      <span class="comment">// For example Round to zero</span></div>
<div class="line">      <span class="comment">// Shift right 15-bits to normalize and truncate</span></div>
<div class="line">      q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
<div class="line">      <span class="comment">//...</span></div>
<div class="line">      q_exp = <a class="code" href="vec__int64__ppc_8h.html#a42d2b39711c06106097ef869a20420b6">vec_swapd</a> (q_exp);</div>
<div class="line">      result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> In this example the Significand (including the L-bit) is right justified in the high-order 113-bits of q_sig. The guard, round, and sticky (GRX) bits are in the low-order 15 bits. The sticky-bits are the last 13 bits and are logically ORed (or added to 0x1fff) to produce the X-bit.</p>
<p>The signed quadword conversion is bit more complicated for both POWER9/8. For example: </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__f128__ppc_8h.html#a27bfd64d7eefd8e84619950f19f827ba">vec_xscvsqqp</a> (<a class="code" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a> int128)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"><span class="preprocessor">#if defined (_ARCH_PWR10)  &amp;&amp; (__GNUC__ &gt;= 10)</span></div>
<div class="line">  __asm__(</div>
<div class="line">      <span class="stringliteral">&quot;xscvsqqp %0,%1&quot;</span></div>
<div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div>
<div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (int128)</div>
<div class="line">      : );</div>
<div class="line"><span class="preprocessor">#elif defined (_ARCH_PWR9) &amp;&amp; defined (__FLOAT128__) &amp;&amp; (__GNUC__ &gt; 7)</span></div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> hi64, lo64, i_sign;</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> two64 = 0x1.0p64;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_sign;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_neg;</div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> b_sign;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line">  <span class="comment">// Collect the sign bit of the input value.</span></div>
<div class="line">  q_sign = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) int128, signmask);</div>
<div class="line">  <span class="comment">// Convert 2s complement to unsigned magnitude form.</span></div>
<div class="line">  q_neg  = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__int128__ppc_8h.html#ac263f88b177c2f3db909ca92e41e3ff9">vec_negsq</a> (int128);</div>
<div class="line">  b_sign = <a class="code" href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802">vec_setb_sq</a> (int128);</div>
<div class="line">  q_sig = <a class="code" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) int128, q_neg, b_sign);</div>
<div class="line">  <span class="comment">// generate a signed 0.0 to use with vec_copysignf128</span></div>
<div class="line">  i_sign = <a class="code" href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a> (q_sign);</div>
<div class="line">  <span class="comment">// Convert the unsigned int128 magnitude to __binary128</span></div>
<div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> int64 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) q_sig;</div>
<div class="line">  hi64 = int64[<a class="code" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>];</div>
<div class="line">  lo64 = int64[<a class="code" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>];</div>
<div class="line">  result = (hi64 * two64) + lo64;</div>
<div class="line">  <span class="comment">// copy the __int128&#39;s sign into the __binary128 result</span></div>
<div class="line">  result = <a class="code" href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e">vec_copysignf128</a> (result, i_sign);</div>
<div class="line"><span class="preprocessor">#elif  defined (_ARCH_PWR8)</span></div>
<div class="line">...</div>
<div class="line">#endif</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> For POWER9 we can not just used the signed doubleword conversions for this case. First we convert the signed quadword into a sign bool and unsigned magnitude. Then perform the unsigned conversion to QP format as for <a class="el" href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8" title="VXS Scalar Convert Unsigned-Quadword to Quad-Precision format.">vec_xscvuqqp()</a>, And finally use <a class="el" href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e" title="Copy the sign bit from f128y and merge with the magnitude from f128x. The merged result is returned a...">vec_copysignf128()</a> to insert the original sign into the QP result.</p>
<p>Similarly for POWER8:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#elif  defined (_ARCH_PWR8)</span></div>
<div class="line"> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_exp;</div>
<div class="line"> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_sig;</div>
<div class="line"> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_neg;</div>
<div class="line"> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> q_sign;</div>
<div class="line"> <a class="code" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> b_sign;</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> q_zero = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) { 0 };</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> lowmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>( 0, 0, 0, 1);</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(0x80000000, 0, 0, 0);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Quick test for 0UL as this case requires a special exponent.</span></div>
<div class="line"> <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) int128, q_zero))</div>
<div class="line">   {</div>
<div class="line">     result = <a class="code" href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">vec_xfer_vui128t_2_bin128</a> (q_zero);</div>
<div class="line">   }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">   { <span class="comment">// We need to produce a normal QP, so we treat the integer like a</span></div>
<div class="line">     <span class="comment">// denormal, then normalize it.</span></div>
<div class="line">     <span class="comment">// Collect the sign bit of the input value.</span></div>
<div class="line">     q_sign = vec_and ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) int128, signmask);</div>
<div class="line">     <span class="comment">// Convert 2s complement to signed magnitude form.</span></div>
<div class="line">     q_neg  = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__int128__ppc_8h.html#ac263f88b177c2f3db909ca92e41e3ff9">vec_negsq</a> (int128);</div>
<div class="line">     b_sign = <a class="code" href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802">vec_setb_sq</a> (int128);</div>
<div class="line">     q_sig = <a class="code" href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) int128, q_neg, b_sign);</div>
<div class="line">     <span class="comment">// Start with the quad exponent bias + 127 then subtract the count of</span></div>
<div class="line">     <span class="comment">// leading &#39;0&#39;s. The 128-bit sig can have 0-127 leading &#39;0&#39;s.</span></div>
<div class="line">     <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> q_expm = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>(0, (0x3fff + 127));</div>
<div class="line">     <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> i64_clz = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49">vec_clzq</a> (q_sig);</div>
<div class="line">     q_sig = <a class="code" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (q_sig, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) i64_clz);</div>
<div class="line">     q_exp = <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (q_expm, i64_clz);</div>
<div class="line">     <span class="comment">// This is the part that might require rounding.</span></div>
<div class="line">     <span class="comment">// For example Round to zero</span></div>
<div class="line">     <span class="comment">// Shift right 15-bits to normalize and truncate</span></div>
<div class="line">     q_sig = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) q_sig, 15);</div>
<div class="line"> </div>
<div class="line">     q_exp = <a class="code" href="vec__int64__ppc_8h.html#a42d2b39711c06106097ef869a20420b6">vec_swapd</a> (q_exp);</div>
<div class="line">     <span class="comment">// Copy Sign-bit to QP significand before insert.</span></div>
<div class="line">     q_sig = (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) vec_or ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) q_sig, q_sign);</div>
<div class="line">     result = <a class="code" href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a> (q_sig, q_exp);</div>
<div class="line">   }</div>
</div><!-- fragment --><h3><a class="anchor" id="f128_softfloat_0_0_2_x"></a>
Convert Quad-Precision to Double-Precision</h3>
<p>TBD</p>
<h3><a class="anchor" id="f128_softfloat_0_0_2_y"></a>
Round to Quad-Precision Integer</h3>
<p>TBD</p>
<h1><a class="anchor" id="f128_examples_0_0"></a>
Examples</h1>
<p>For example: using the the classification functions for implementing the math library function sine and cosine. The Posix specification requires that special input values are processed without raising extraneous floating point exceptions and return specific floating point values in response. For example the sin() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>value</em>.</li>
<li>If the input <em>value</em> is subnormal then return <em>value</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a NaN.</li>
<li>Otherwise compute and return sin(value).</li>
</ul>
<p>The following code example uses functions from this header to address the POSIX requirements for special values input to sinf128(): </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line">test_sinf128 (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> value)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">vec_all_isnormalf128</a> (value))</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// body of taylor series.</span></div>
<div class="line">      ...</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (value))</div>
<div class="line">        result = <a class="code" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ();</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        result = value;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For another example the cos() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>1.0</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a NaN.</li>
<li>Otherwise compute and return cos(value).</li>
</ul>
<p>The following code example uses functions from this header to address the Posix requirements for special values input to cosf128(): </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div>
<div class="line">test_cosf128 (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> value)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">vec_all_isfinitef128</a> (value))</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">vec_all_iszerof128</a> (value))</div>
<div class="line">        result = 1.0Q;</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// body of taylor series ...</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (value))</div>
<div class="line">        result = <a class="code" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ();</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        result = value;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Neither example raises floating point exceptions or sets <b>errno</b>, as appropriate for a vector math library.</p>
<h1><a class="anchor" id="f128_perf_0_0"></a>
Performance data</h1>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="add641f5a217eff45f0e836fa98613584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add641f5a217eff45f0e836fa98613584">&#9670;&nbsp;</a></span>vec_absf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_absf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute Quad-Precision. </p>
<p>Clear the sign bit of the __float128 input and return the resulting positive __float128 value.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value containing a signed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128 and a positive sign of f128. </dd></dl>

</div>
</div>
<a id="a946ffd501b32f3ec96563ab101afbfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946ffd501b32f3ec96563ab101afbfad">&#9670;&nbsp;</a></span>vec_all_isfinitef128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isfinitef128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary128 finite value has an exponent between 0x0000 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value. Using the !vec_all_eq compare conditional verify this condition and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="a66fc4e7c94d0b30bb3515931aaf723da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fc4e7c94d0b30bb3515931aaf723da">&#9670;&nbsp;</a></span>vec_all_isinff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isinff128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. Using the vec_all_eq compare conditional verifies both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="af06b73ac57985011c558670adc283e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06b73ac57985011c558670adc283e89">&#9670;&nbsp;</a></span>vec_all_isnanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnanf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is Not a Number (NaN). </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. Using the combined vec_all_eq / vec_any_gt compare conditional verify both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6-29 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="afc830b382bd45dc0ff815024c1bfb26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc830b382bd45dc0ff815024c1bfb26d">&#9670;&nbsp;</a></span>vec_all_isnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary128 normal value has an exponent between 0x0001 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). Using the combined vec_all_ne compares conditional verify both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-29 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="adf1a94cccdb3f106a0e6399e2f034718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1a94cccdb3f106a0e6399e2f034718">&#9670;&nbsp;</a></span>vec_all_issubnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_issubnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is subnormal (denormal). </p>
<p>A IEEE Binary128 subnormal has an exponent of 0x0000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-29 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary128 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if the __float128 value is subnormal. </dd></dl>

</div>
</div>
<a id="a2bee3fac5a163513bae170a54ac641ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bee3fac5a163513bae170a54ac641ca">&#9670;&nbsp;</a></span>vec_all_isunorderedf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isunorderedf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if either __float128 value (vra, vrb) is NaN. </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. The sign bit is ignored. For POWER9 and later we use scalar_test_data_class(). Otherwise mask off the sign bit and compare greater than unsigned quadword to the integer equivalent of Quad-Precision infinity.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">16-25 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if either __float128 value (vra, vrb) is NaN. </dd></dl>

</div>
</div>
<a id="ac554a9d0d12fca036772aaaee5908414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac554a9d0d12fca036772aaaee5908414">&#9670;&nbsp;</a></span>vec_all_iszerof128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_iszerof128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is +-0.0. </p>
<p>A IEEE Binary128 zero has an exponent of 0x0000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-20 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if the __float128 value is +/- zero. </dd></dl>

</div>
</div>
<a id="aae0e62b9910ec833dfc20719d09e526e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0e62b9910ec833dfc20719d09e526e">&#9670;&nbsp;</a></span>vec_and_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_and_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value ANDed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="a796440333ee623aa782ef3eb5a021587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796440333ee623aa782ef3eb5a021587">&#9670;&nbsp;</a></span>vec_andc_bin128_2_vui128t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_andc_bin128_2_vui128t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector __int128 and logical AND Compliment with mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned __int128 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value ANDed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="aedfcf3adea80e0407b40c6ec0e851aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfcf3adea80e0407b40c6ec0e851aab">&#9670;&nbsp;</a></span>vec_andc_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_andc_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value ANDed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="aec73dba497304699389a168256f32d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec73dba497304699389a168256f32d29">&#9670;&nbsp;</a></span>vec_cmpeqtoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpeqtoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa == vfb, otherwise all '0's. Zeros, Infinities and NaN of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or a VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a7e3f85b4c3fe43ae58df0c72d1f29920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3f85b4c3fe43ae58df0c72d1f29920">&#9670;&nbsp;</a></span>vec_cmpequqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpequqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa == vfb, otherwise all '0's. Zeros of either sign compare equal. Infinities of the same sign compare equal. A NaN in either or both operands compare unequal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">18-30 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a83177380e5feaacb1da72c99df1c6d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83177380e5feaacb1da72c99df1c6d82">&#9670;&nbsp;</a></span>vec_cmpequzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpequzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa == vfb, otherwise all '0's. Zeros of either sign compare equal. Infinities and NaNs of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or a VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="aa40f7a997a4c92eb55203444434c070e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40f7a997a4c92eb55203444434c070e">&#9670;&nbsp;</a></span>vec_cmpgetoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgetoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than or Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt;= vfb, otherwise all '0's. Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than or equal. </dd></dl>

</div>
</div>
<a id="a870bc0f51bb3931039fec799a7c3605a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870bc0f51bb3931039fec799a7c3605a">&#9670;&nbsp;</a></span>vec_cmpgeuqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgeuqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than or Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt;= vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than or equal. </dd></dl>

</div>
</div>
<a id="a6b31351604fbca85ace1c1efc8bd6506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b31351604fbca85ace1c1efc8bd6506">&#9670;&nbsp;</a></span>vec_cmpgeuzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgeuzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than Or Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt;= vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than or equal. </dd></dl>

</div>
</div>
<a id="ae320639a93f8bc42359d9214a5e9c17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae320639a93f8bc42359d9214a5e9c17e">&#9670;&nbsp;</a></span>vec_cmpgttoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgttoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt; vfb, otherwise all '0's. Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than. </dd></dl>

</div>
</div>
<a id="a4bd8774bd68a914ac0fe3f66d16a8965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd8774bd68a914ac0fe3f66d16a8965">&#9670;&nbsp;</a></span>vec_cmpgtuqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgtuqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt; vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than. </dd></dl>

</div>
</div>
<a id="a6fbd885123cdb812bf19d2758cde202f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbd885123cdb812bf19d2758cde202f">&#9670;&nbsp;</a></span>vec_cmpgtuzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpgtuzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &gt; vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare greater than. </dd></dl>

</div>
</div>
<a id="a2034138934ee70e2ed25978ecb18ebc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2034138934ee70e2ed25978ecb18ebc0">&#9670;&nbsp;</a></span>vec_cmpletoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpletoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than or Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt;= vfb, otherwise all '0's. Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than or equal. </dd></dl>

</div>
</div>
<a id="a4a72e3eb8f3d96e537e940cc7583b3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a72e3eb8f3d96e537e940cc7583b3c7">&#9670;&nbsp;</a></span>vec_cmpleuqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpleuqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than or Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt;= vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than or equal. </dd></dl>

</div>
</div>
<a id="ae776b348d6c4c4a45966b451aa72072c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae776b348d6c4c4a45966b451aa72072c">&#9670;&nbsp;</a></span>vec_cmpleuzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpleuzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than or Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt;= vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than or equal. </dd></dl>

</div>
</div>
<a id="a82c672a1a0bcd3005acdfff33e70e782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c672a1a0bcd3005acdfff33e70e782">&#9670;&nbsp;</a></span>vec_cmplttoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmplttoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt; vfb, otherwise all '0's. Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than. </dd></dl>

</div>
</div>
<a id="a388307f4693587b9e49148fbe95d8da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388307f4693587b9e49148fbe95d8da5">&#9670;&nbsp;</a></span>vec_cmpltuqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpltuqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt; vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than. </dd></dl>

</div>
</div>
<a id="a1e3242d44d78984694295087f9f415e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3242d44d78984694295087f9f415e8">&#9670;&nbsp;</a></span>vec_cmpltuzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpltuzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa &lt; vfb, otherwise all '0's. Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Greater Than Quad-Precision instruction. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare less than. </dd></dl>

</div>
</div>
<a id="aa2a23cbeeb063d30316ab3e7bdd77fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a23cbeeb063d30316ab3e7bdd77fd7">&#9670;&nbsp;</a></span>vec_cmpnetoqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpnetoqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Not Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa != vfb, otherwise all '0's. Zeros, Infinities and NaN of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or a VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare not equal. </dd></dl>

</div>
</div>
<a id="ab3e270eb83aa8d90a2459b0097fec944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e270eb83aa8d90a2459b0097fec944">&#9670;&nbsp;</a></span>vec_cmpneuqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpneuqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Not Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa == vfb, otherwise all '0's. Zeros of either sign compare equal. Infinities of the same sign compare equal. A NaN in either or both operands compare unequal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or (POWER10) VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">18-30 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare not equal. </dd></dl>

</div>
</div>
<a id="a4ffa4be24c8714347ded9340de33e999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffa4be24c8714347ded9340de33e999">&#9670;&nbsp;</a></span>vec_cmpneuzqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_cmpneuzqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Not Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return all '1's, if vfa != vfb, otherwise all '0's. Zeros of either sign compare equal. Infinities and NaNs of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision or a VSX Scalar Compare Equal Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting __binary128 compare not equal. </dd></dl>

</div>
</div>
<a id="ab50ec5ca14b23861c520e99f9b24a11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50ec5ca14b23861c520e99f9b24a11f">&#9670;&nbsp;</a></span>vec_cmpqp_all_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa == vfb, otherwise 0. Zeros of either sign compare equal. Infinities of the same sign compare equal. A NaN in either or both operands compare unequal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">18-30 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a01aef626eb6cd826f5874f3324dd7217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01aef626eb6cd826f5874f3324dd7217">&#9670;&nbsp;</a></span>vec_cmpqp_all_ge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_ge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than Or Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt;= vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than. </dd></dl>

</div>
</div>
<a id="a253c27dd7f4fe852a4f0c6dce45d886b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253c27dd7f4fe852a4f0c6dce45d886b">&#9670;&nbsp;</a></span>vec_cmpqp_all_gt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt; vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than. </dd></dl>

</div>
</div>
<a id="a19dca4ec505a30c52361dff6300fdba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dca4ec505a30c52361dff6300fdba7">&#9670;&nbsp;</a></span>vec_cmpqp_all_le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_le </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less Than Or Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt;= vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 less than or equal. </dd></dl>

</div>
</div>
<a id="a630f6cef8a6cdcc6dd22d3c1ece138b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630f6cef8a6cdcc6dd22d3c1ece138b7">&#9670;&nbsp;</a></span>vec_cmpqp_all_lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less Than (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt; vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities of different signs compare ordered. A NaN in either or both operands compare unordered.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 less than. </dd></dl>

</div>
</div>
<a id="a3d858ca0228e20b1e7f3bec686021fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d858ca0228e20b1e7f3bec686021fb6">&#9670;&nbsp;</a></span>vec_cmpqp_all_ne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_ne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Not-Equal (Unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa == vfb, otherwise 0. Zeros of either sign compare equal. Infinities of the same sign compare equal. A NaN in either or both operands compare unequal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to NaN comparison and setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">18-30 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare not-equal. </dd></dl>

</div>
</div>
<a id="a44c233f656fb0ef554dfbdfb23e66954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c233f656fb0ef554dfbdfb23e66954">&#9670;&nbsp;</a></span>vec_cmpqp_all_toeq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_toeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa == vfb, otherwise 0. Zeros, Infinities and NaN of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a9a4f2f83695c9980679e8a2488ed2c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4f2f83695c9980679e8a2488ed2c55">&#9670;&nbsp;</a></span>vec_cmpqp_all_toge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_toge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than Or Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt;= vfb, otherwise 0 (false). Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than or equal. </dd></dl>

</div>
</div>
<a id="a926a5e7b9a23e7464d70d9fa6ae49dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926a5e7b9a23e7464d70d9fa6ae49dda">&#9670;&nbsp;</a></span>vec_cmpqp_all_togt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_togt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt; vfb, otherwise 0 (false). Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than. </dd></dl>

</div>
</div>
<a id="a8171c3fa6a0ecdf7b19be3df8227cbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8171c3fa6a0ecdf7b19be3df8227cbf6">&#9670;&nbsp;</a></span>vec_cmpqp_all_tole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_tole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare All Less Than Or Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt;= vfb, otherwise 0 (false). Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare less than or equal. </dd></dl>

</div>
</div>
<a id="a9d466774a32ef558f6e3ea64dd6b3cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d466774a32ef558f6e3ea64dd6b3cdd">&#9670;&nbsp;</a></span>vec_cmpqp_all_tolt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_tolt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare All Less Than (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt; vfb, otherwise 0 (false). Zeros, Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">26-35 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare less than. </dd></dl>

</div>
</div>
<a id="ad8d272e77ab3c69808ad3efac20afb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d272e77ab3c69808ad3efac20afb36">&#9670;&nbsp;</a></span>vec_cmpqp_all_tone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_tone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Not-Equal (Total-order) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa != vfb, otherwise 0. Zeros, Infinities and NaN of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to signed zero, or NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare not-equal. </dd></dl>

</div>
</div>
<a id="a4c7d9eb6f3ee5d504bddd9f4b9171bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7d9eb6f3ee5d504bddd9f4b9171bfd">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzeq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa == vfb, otherwise 0. Zeros of either sign compare equal. Infinities and NaNs of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a59a13069849f5ac559db634deab32d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a13069849f5ac559db634deab32d0e">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than Or Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt;= vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than or equal. </dd></dl>

</div>
</div>
<a id="ab0dcb860a9015e36ade2d6a9fac55c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dcb860a9015e36ade2d6a9fac55c62">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzgt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzgt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &gt; vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 greater than. </dd></dl>

</div>
</div>
<a id="a75d444218effcb971289efb1e02a3dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d444218effcb971289efb1e02a3dc9">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less Than Or Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt;= vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 less than or equal. </dd></dl>

</div>
</div>
<a id="a95dde3d0847b947b1f422afef46fbfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95dde3d0847b947b1f422afef46fbfc6">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzlt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzlt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less Than (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1 (true), if vfa &lt; vfb, otherwise 0 (false). Zeros of either sign are converted to +0. Infinities and NaNs are compared as signed values. Infinities and NaNs have the highest/lowest magnitudes.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise comparands are converted to unsigned integer magnitudes before using vector __int128 comparison to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative to NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">28-37 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 less than. </dd></dl>

</div>
</div>
<a id="aa147fd8c1d3da47a2786b6b745a9e1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa147fd8c1d3da47a2786b6b745a9e1a6">&#9670;&nbsp;</a></span>vec_cmpqp_all_uzne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_all_uzne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Not-Equal (Zero-unordered) Quad-Precision. </p>
<p>Compare Binary-float 128-bit values and return 1, if vfa != vfb, otherwise 0. Zeros of either sign compare equal. Infinities and NaNs of the same sign compare equal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use a VSX Scalar Compare Unordered Quad-Precision. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the IEEE standard relative NaN comparison. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 compare equal. </dd></dl>

</div>
</div>
<a id="a1e6c52eb3208f4d9ed851ee48f773d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6c52eb3208f4d9ed851ee48f773d68">&#9670;&nbsp;</a></span>vec_cmpqp_exp_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_exp_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Quad-Precision Exponents for Equal. </p>
<p>Compare the exponents of two Binary-float 128-bit values and return 1, if vfa<sup>exp</sup> == vfb<sup>exp</sup>, otherwise 0. A NaN in either or both operands compare unequal.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use the VSX Scalar Compare Exponents Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 exponent compare equal. </dd></dl>

</div>
</div>
<a id="abf2d90d67cb3f605fbc9598f133b0305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2d90d67cb3f605fbc9598f133b0305">&#9670;&nbsp;</a></span>vec_cmpqp_exp_gt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_exp_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Exponents Quad-Precision for Greater Than. </p>
<p>Compare the exponents of two Binary-float 128-bit values and return 1, if vfa<sup>exp</sup> &gt; vfb<sup>exp</sup>, otherwise 0. A NaN in either or both operands returns 0.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use the VSX Scalar Compare Exponents Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 exponent compare greater than. </dd></dl>

</div>
</div>
<a id="a3eb9b92be998695424107de6a60890a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb9b92be998695424107de6a60890a8">&#9670;&nbsp;</a></span>vec_cmpqp_exp_lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_exp_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Exponents Quad-Precision for Less Than. </p>
<p>Compare the exponents of two Binary-float 128-bit values and return 1, if vfa<sup>exp</sup> &lt; vfb<sup>exp</sup>, otherwise 0. A NaN in either or both operands returns 0.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use the VSX Scalar Compare Exponents Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 exponent compare equal. </dd></dl>

</div>
</div>
<a id="a3014214c103453a34372cc52e6d79073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3014214c103453a34372cc52e6d79073">&#9670;&nbsp;</a></span>vec_cmpqp_exp_unordered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpqp_exp_unordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Exponents Quad-Precision for Unordered. </p>
<p>Compare two Binary-float 128-bit values and return 1, if either or both operands are NaN, otherwise 0.</p>
<p>For POWER9 (PowerISA 3.0B) or later, use the VSX Scalar Compare Exponents Quad-Precision instruction. Otherwise use vector __int128 arithmetic and logical operations to implement the equivalent Quad-precision floating-point operation. This leverages operations from <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes an instruction that does implement the IEEE standard, the implementation may use that. This relaxed implementation may be useful for implementations on POWER8 and earlier. Especially for soft-float implementations where it is known these special cases do not occur.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int boolean reflecting __binary128 unordered. </dd></dl>

</div>
</div>
<a id="a0a30726ccfb216e4d2e1ede3854ab96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a30726ccfb216e4d2e1ede3854ab96b">&#9670;&nbsp;</a></span>vec_const_huge_valf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_huge_valf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a positive infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>const __float128 positive infinity. </dd></dl>

</div>
</div>
<a id="a9c68f73f69c4776bb054d42915e7103d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c68f73f69c4776bb054d42915e7103d">&#9670;&nbsp;</a></span>vec_const_inff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_inff128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a positive infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 positive infinity. </dd></dl>

</div>
</div>
<a id="af7fb1013dfcf633156cd7f855a11fb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fb1013dfcf633156cd7f855a11fb56">&#9670;&nbsp;</a></span>vec_const_nanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_nanf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a quiet NaN. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 quiet NaN. </dd></dl>

</div>
</div>
<a id="aac806c62ebaae6ab8faca87794cb917c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac806c62ebaae6ab8faca87794cb917c">&#9670;&nbsp;</a></span>vec_const_nansf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_nansf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a signaling NaN. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 signaling NaN. </dd></dl>

</div>
</div>
<a id="adfb73eac40698921735bad8ac4ce560e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb73eac40698921735bad8ac4ce560e">&#9670;&nbsp;</a></span>vec_copysignf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_copysignf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the sign bit from f128y and merge with the magnitude from f128x. The merged result is returned as a __float128 value. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128x</td><td>a __float128 value containing the magnitude. </td></tr>
    <tr><td class="paramname">f128y</td><td>a __float128 value containing the sign bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128x and the sign of f128y. </dd></dl>

</div>
</div>
<a id="ad1668ff13922ca04059f1844a7a1464f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1668ff13922ca04059f1844a7a1464f">&#9670;&nbsp;</a></span>vec_isfinitef128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isfinitef128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary128 finite value has an exponent between 0x0000 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value. Using the vec_cmpeq conditional to generate the predicate mask for NaN / Inf and then invert this for the finite condition. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="aebd9706acb775392282cfe4d4e3a03aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd9706acb775392282cfe4d4e3a03aa">&#9670;&nbsp;</a></span>vec_isinf_signf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_isinf_signf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true (nonzero) value if the __float128 value is infinity. For infinity indicate the sign as +1 for positive infinity and -1 for negative infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. Using the vec_all_eq compare conditional verifies both conditions. A subsequent vec_any_gt checks the sign bit and set the result appropriately. The sign bit is ignored.</p>
<p>This sequence avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">12-32 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3-12 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 if not infinity and +1/-1 otherwise. </dd></dl>

</div>
</div>
<a id="a94f9c7429c2ebd9b9f32ad6e98689ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f9c7429c2ebd9b9f32ad6e98689ebb">&#9670;&nbsp;</a></span>vec_isinff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isinff128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a 128-bit vector boolean true if the __float128 value is infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s.. </dd></dl>

</div>
</div>
<a id="a11c410994f958a6b4ac9583878a55a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c410994f958a6b4ac9583878a55a72">&#9670;&nbsp;</a></span>vec_isnanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isnanf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN). </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. The sign bit is ignored. For POWER9 and later we use scalar_test_data_class(). Otherwise mask off the sign bit and compare greater than unsigned quadword to the integer equivalent of Quad-Precision infinity.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">14-23 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="aa25185c83b69f6af3f3d9399199c8a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25185c83b69f6af3f3d9399199c8a57">&#9670;&nbsp;</a></span>vec_isnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary128 normal value has an exponent between 0x0001 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). The sign bit is ignored.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="a9670e4655a9c7888c80343780cd7abf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9670e4655a9c7888c80343780cd7abf9">&#9670;&nbsp;</a></span>vec_issubnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_issubnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true value, if the __float128 value is subnormal (denormal). </p>
<p>A IEEE Binary128 subnormal has an exponent of 0x0000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">16-25 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="aec9148af78b075f253c9848945df6135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9148af78b075f253c9848945df6135">&#9670;&nbsp;</a></span>vec_isunorderedf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isunorderedf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true value, if either __float128 value (vra, vrb) is NaN. </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. The sign bit is ignored. For POWER9 and later we use scalar_test_data_class(). Otherwise mask off the sign bit and compare greater than unsigned quadword to the integer equivalent of Quad-Precision infinity.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">16-25 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
    <tr><td class="paramname">vfb</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean _int128. </dd></dl>

</div>
</div>
<a id="a598a822d22b02ba0d2c2a1095a4e700d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598a822d22b02ba0d2c2a1095a4e700d">&#9670;&nbsp;</a></span>vec_iszerof128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_iszerof128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true value, if the value that is +-0.0. </p>
<p>A IEEE Binary64 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">8-17 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a7c2297dc22a6a3120491e1721648c0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2297dc22a6a3120491e1721648c0e7">&#9670;&nbsp;</a></span>vec_nabsf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_nabsf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negative Absolute value Quad-Precision. </p>
<p>Unconditionally set sign bit of the __float128 input and return the resulting positive __float128 value.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value containing a signed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128 and a negative sign. </dd></dl>

</div>
</div>
<a id="a3323b6fb0b379a21f3dd70f7f204bd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3323b6fb0b379a21f3dd70f7f204bd2a">&#9670;&nbsp;</a></span>vec_negf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_negf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate the sign bit of a __float128 input and return the resulting __float128 value. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value containing a signed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128 and the opposite sign of f128. </dd></dl>

</div>
</div>
<a id="a2843ee28bf45b6e7589f2b1d073a2187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2843ee28bf45b6e7589f2b1d073a2187">&#9670;&nbsp;</a></span>vec_sel_bin128_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_sel_bin128_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">vfb</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector bool __int128 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit of vfa or vfb depending on the mask. </dd></dl>

</div>
</div>
<a id="a47637906e95a7c94cffc093bc2e57dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47637906e95a7c94cffc093bc2e57dbf">&#9670;&nbsp;</a></span>vec_self128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_self128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>vfb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select and Transfer from one of two __binary128 scalars under a 128-bit mask. The result is a __binary128 of the selected value. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfa</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">vfb</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector bool __int128 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit of vfa or vfb depending on the mask. </dd></dl>

</div>
</div>
<a id="a4d5b388cfc9af26418bdd4ec8e4e6f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5b388cfc9af26418bdd4ec8e4e6f73">&#9670;&nbsp;</a></span>vec_setb_qp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_setb_qp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Set Bool from Quadword Floating-point. </p>
<p>If the quadword's sign bit is '1' then return a vector bool __int128 that is all '1's. Otherwise return all '0's.</p>
<p>The resulting mask can be used in vector masking and select operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation will set the sign mask regardless of data class. For POWER9 the Scalar Test Data Class instructions copy the sign bit to CR bit 0 which distinguishes between +/- NaN.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4 - 6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a 128-bit vector treated a signed __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector bool of all '1's if the sign bit is '1'. Otherwise all '0's. </dd></dl>

</div>
</div>
<a id="a4ca7749d334c2a2c17a4d2a98b5bf755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca7749d334c2a2c17a4d2a98b5bf755">&#9670;&nbsp;</a></span>vec_signbitf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_signbitf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return int boolean true if the __float128 value is negative (sign bit is '1'). </p>
<p>For POWER9 use scalar_test_neg (a special case of scalar_test_data_class). For POWER8 and earlier, vec_and with a signmask and then vec_all_eq compare with that mask generates the boolean of the sign bit.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-10 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a int boolean indicating the sign bit. </dd></dl>

</div>
</div>
<a id="aec6e44a75847d3d3e5611b89eed71c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6e44a75847d3d3e5611b89eed71c0a">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui128t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_xfer_bin128_2_vui128t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector __int128. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector __int128. </dd></dl>

</div>
</div>
<a id="aff0629194f4f63bb083c271844459072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0629194f4f63bb083c271844459072">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui16t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_xfer_bin128_2_vui16t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector short int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector short int. </dd></dl>

</div>
</div>
<a id="a8043c2c5ac35d2b0a8bd8f33779c91a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8043c2c5ac35d2b0a8bd8f33779c91a6">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_xfer_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="acac5809f5f651e45113de8410664f2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac5809f5f651e45113de8410664f2c7">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui64t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xfer_bin128_2_vui64t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector long long int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector long long int. </dd></dl>

</div>
</div>
<a id="a57dc5b9171d5ce3d49f0f12795659c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57dc5b9171d5ce3d49f0f12795659c1a">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui8t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_xfer_bin128_2_vui8t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector char. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector char. </dd></dl>

</div>
</div>
<a id="a91b99b632646aaca91de6834e2b1da26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b99b632646aaca91de6834e2b1da26">&#9670;&nbsp;</a></span>vec_xfer_vui128t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui128t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned __int128 to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned __int128 value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="a3dec5c23a659b2fca1c219fe783f88eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dec5c23a659b2fca1c219fe783f88eb">&#9670;&nbsp;</a></span>vec_xfer_vui16t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui16t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned short to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned short value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="af0596ab318ba6d1ec5e7ed40871255a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0596ab318ba6d1ec5e7ed40871255a9">&#9670;&nbsp;</a></span>vec_xfer_vui32t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui32t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned int to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="ae8002c29875a226d11ec57a42b5b3955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8002c29875a226d11ec57a42b5b3955">&#9670;&nbsp;</a></span>vec_xfer_vui64t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui64t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned long long to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned long long value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="a047b7dc5b55b2d13e2fd826c63872ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047b7dc5b55b2d13e2fd826c63872ea9">&#9670;&nbsp;</a></span>vec_xfer_vui8t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui8t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned char to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned char value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="a7de75d3d010fe5ac7310322e2abea122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de75d3d010fe5ac7310322e2abea122">&#9670;&nbsp;</a></span>vec_xor_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_xor_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
    <tr><td class="paramname">mask</td><td>a vector unsigned int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value ANDed with mask as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="a1a8ceb0eb2c47892371a12502d14f170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8ceb0eb2c47892371a12502d14f170">&#9670;&nbsp;</a></span>vec_xscvdpqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xscvdpqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a>&#160;</td>
          <td class="paramname"><em>f64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VXS Scalar Convert Double-Precision to Quad-Precision format. </p>
<p>The left most double-precision element of vector f64 is converted to quad-precision format.</p>
<p>For POWER9 use the xscvdpqp instruction. For POWER8 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to Signaling NaN and setting the FPSCR. However if the hardware target includes the xscvdpqp instruction, the implementation may use that.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f64</td><td>a vector double. The left most element is converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value. </dd></dl>

</div>
</div>
<a id="a5e3c778a7c90b6e6a2d89cd5a1012061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3c778a7c90b6e6a2d89cd5a1012061">&#9670;&nbsp;</a></span>vec_xscvqpdpo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a> vec_xscvqpdpo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VXS Scalar Convert with round Quad-Precision to Double-Precision (using round to odd). </p>
<p>The quad-precision element of vector f128 is converted to double-precision. The Floating point value is rounded to odd before conversion. The result is placed in doubleword element 0 while element 1 is set to zero.</p>
<p>For POWER9 use the xscvqpdpo instruction. For POWER8 and earlier use vector instructions generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes the xscvqpdpo instruction, the implementation may use that.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">12 </td><td class="markdownTableBodyLeft">1/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector unsigned long long value. </dd></dl>

</div>
</div>
<a id="a73ad56c509ea22f26fb2d47217bc5e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ad56c509ea22f26fb2d47217bc5e51">&#9670;&nbsp;</a></span>vec_xscvqpudz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xscvqpudz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VXS Scalar Convert with round to zero Quad-Precision to Unsigned doubleword. </p>
<p>The quad-precision element of vector f128 is converted to an unsigned doubleword integer. The Floating point value is rounded toward zero before conversion. The result is placed in element 0 while element 1 is set to zero.</p>
<p>For POWER9 use the xscvqpudz instruction. For POWER8 and earlier use vector instructions generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes the xscvqpudz instruction, the implementation may use that.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector unsigned long long value. </dd></dl>

</div>
</div>
<a id="aaf9d4ad5a60e9ffaa0ca16d29f90c092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9d4ad5a60e9ffaa0ca16d29f90c092">&#9670;&nbsp;</a></span>vec_xscvqpuqz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_xscvqpuqz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VXS Scalar Convert with round to zero Quad-Precision to Unsigned Quadword. </p>
<p>The quad-precision element of vector f128 is converted to an unsigned quadword integer. The Floating point value is rounded toward zero before conversion.</p>
<p>For POWER10 use the xscvqpuqz instruction. For POWER9 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>This operation <em>may not</em> follow the PowerISA relative to setting the FPSCR. However if the hardware target includes the xscvqpuqz instruction, the implementation may use that.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>128-bit vector treated as a scalar __binary128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector unsigned __int128 value. </dd></dl>

</div>
</div>
<a id="acc58cb3be351ea2bf163aeb8dbb5709c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc58cb3be351ea2bf163aeb8dbb5709c">&#9670;&nbsp;</a></span>vec_xscvsdqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xscvsdqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>int64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VXS Scalar Convert Signed-Doubleword to Quad-Precision format. </p>
<p>The left most signed doubleword element of vector int64 is converted to quad-precision format.</p>
<p>For POWER9 use the xscvsdqp instruction. For POWER8 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>At this point we are not trying to comply with PowerISA by setting any FPSCR bits associated with Quad-Precision convert. If such is required, FR and/or FI can be set using the Move To FPSCR Bit 0 (mtfsb0) instruction.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int64</td><td>a vector signed long long. The left most element is converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value. </dd></dl>

</div>
</div>
<a id="a27bfd64d7eefd8e84619950f19f827ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bfd64d7eefd8e84619950f19f827ba">&#9670;&nbsp;</a></span>vec_xscvsqqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xscvsqqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a>&#160;</td>
          <td class="paramname"><em>int128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VXS Scalar Convert Signed-Quadword to Quad-Precision format. </p>
<p>The signed quadword element of vector int128 is converted to quad-precision format. If the conversion is not exact the default rounding mode is "round to Nearest, ties to even".</p>
<p>For POWER10 use the xscvuqqp instruction. POWER9 only supports doubleword converts so use a combination of two xscvudqp and xsmaddqp instructions. For POWER8 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>The POWER8 implementation ignores the hardware rounding mode <b>FPSCR<sub>RN</sub></b>.</dd>
<dd>
At this point we are not trying to comply with PowerISA by setting any FPSCR bits associated with Quad-Precision convert. If such is required, FPFR, FR and FI can be set using the Move To FPSCR Bit 0/1 (mtfsb[0|1]) instruction.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">44-53 </td><td class="markdownTableBodyLeft">1/13cycles  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int128</td><td>a vector signed __int128 which is converted to QP format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value. </dd></dl>

</div>
</div>
<a id="a1eadadc05fe1873deadaef16926f6c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eadadc05fe1873deadaef16926f6c86">&#9670;&nbsp;</a></span>vec_xscvudqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xscvudqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>int64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VXS Scalar Convert Unsigned-Doubleword to Quad-Precision format. </p>
<p>The left most unsigned doubleword element of vector int64 is converted to quad-precision format.</p>
<p>For POWER9 use the xscvudqp instruction. For POWER8 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>At this point we are not trying to comply with PowerISA by setting any FPSCR bits associated with Quad-Precision convert. If such is required, FR and/or FI can be set using the Move To FPSCR Bit 0 (mtfsb0) instruction.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int64</td><td>a vector unsigned long long. The left most element is converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value. </dd></dl>

</div>
</div>
<a id="a24b1f22552fd177d10af1dbc0f43d5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b1f22552fd177d10af1dbc0f43d5f8">&#9670;&nbsp;</a></span>vec_xscvuqqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xscvuqqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>int128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VXS Scalar Convert Unsigned-Quadword to Quad-Precision format. </p>
<p>The unsigned quadword element of vector int128 is converted to quad-precision format. If the conversion is not exact the default rounding mode is "round to Nearest, ties to even".</p>
<p>For POWER10 use the xscvuqqp instruction. POWER9 only supports doubleword converts so use a combination of two xscvudqp and xsmaddqp instructions. For POWER8 and earlier use vector instruction generated by PVECLIB operations.</p>
<dl class="section note"><dt>Note</dt><dd>The POWER8 implementation ignores the hardware rounding mode <b>FPSCR<sub>RN</sub></b>.</dd>
<dd>
At this point we are not trying to comply with PowerISA by setting any FPSCR bits associated with Quad-Precision convert. If such is required, FPFR, FR and FI can be set using the Move To FPSCR Bit 0/1 (mtfsb[0|1]) instruction.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">? </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">38-47 </td><td class="markdownTableBodyLeft">1/13cycles  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int128</td><td>a vector unsigned __int128 which is converted to QP format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value. </dd></dl>

</div>
</div>
<a id="af95c675ceebc0627c777d2c7e2daef0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95c675ceebc0627c777d2c7e2daef0b">&#9670;&nbsp;</a></span>vec_xsiexpqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xsiexpqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar Insert Exponent Quad-Precision. </p>
<p>Merge the sign (bit 0) and significand (bits 16:127) from sig with the 15-bit exponent from exp (bits 49:63). The exponent is moved to bits 1:15 of the final result. The result is returned as a Quad_precision floating point value.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xsiexpqp instruction, This instruction requires a POWER9-enabled compiler targeting -mcpu=power9 and is not available for older compilers nor POWER8 and earlier. We can't use the built-in scalar_insert_exp because it requires scalar (GPR) inputs and vec_insert_exp is not defined for Quad-Precision. We expect (in context) inputs will be in VRs. This operation provides implementations for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">2-11 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>vector __int128 containing the Sign Bit and 112-bit significand. </td></tr>
    <tr><td class="paramname">exp</td><td>vector unsigned long long element 0 containing the 15-bit exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __binary128 value where the exponent bits (1:15) of sig are replaced from bits 49:63 of exp. </dd></dl>

</div>
</div>
<a id="a3d78e42d9cc58491fa46149bf5798167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d78e42d9cc58491fa46149bf5798167">&#9670;&nbsp;</a></span>vec_xsxexpqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xsxexpqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar Extract Exponent Quad-Precision. </p>
<p>Extract the quad-precision exponent (bits 1:15) and right justify it to (bits 49:63 of) doubleword 0 of the result vector. The result is returned as vector long long integer value.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xsxexpqp instruction. This instruction requires a POWER9-enabled compiler targeting -mcpu=power9 and is not available for older compilers nor POWER8 and earlier. We can't use the built-in scalar_extract_exp because it returns scalar (GPR) results and vec_extract_exp is not defined for Quad-Precision. We expect (in context) results are needed in VRs. This operation provides implementations for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">4-13 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">4/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>__binary128 scalar value in a vector register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long long element 0 containing the 15-bit exponent </dd></dl>

</div>
</div>
<a id="ab1eb10beac182e936d7e49d491c34fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1eb10beac182e936d7e49d491c34fe0">&#9670;&nbsp;</a></span>vec_xsxsigqp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_xsxsigqp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar Extract Significand Quad-Precision. </p>
<p>Extract the quad-precision significand (bits 16:127) and restore the implied (hidden) bit (bit 15) if the quad-precition value is normal (not zero, subnormal, Infinity or NaN). The result is returned as vector __int128 integer value with up to 113 bits of significance.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to the POWER9 xsxsigqp instruction. This instruction requires a POWER9-enabled compiler targeting -mcpu=power9 and is not available for older compilers nor POWER8 and earlier. We can't use the built-in scalar_extract_sig because it returns scalar (GPR) results and vec_extract_sig is not defined for Quad-Precision. We expect (in context) results are needed in VRs. This operation provides implementations for all VSX-enabled platforms.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">processor </th><th class="markdownTableHeadCenter">Latency </th><th class="markdownTableHeadLeft">Throughput  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">power8 </td><td class="markdownTableBodyCenter">10-19 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">power9 </td><td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">2/cycle  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>__binary128 scalar value in a vector register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector __int128 containing the significand. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="avec__int128__ppc_8h_html_a7f9ebc5ad32b151a3e08136d51aad4dc"><div class="ttname"><a href="vec__int128__ppc_8h.html#a7f9ebc5ad32b151a3e08136d51aad4dc">vec_cmpltuq</a></div><div class="ttdeci">static vb128_t vec_cmpltuq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare Less Than Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:3000</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_ad4ce43dcbc14fb34623d5ece8073b86e"><div class="ttname"><a href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a></div><div class="ttdeci">static vb128_t vec_cmpgtuq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare Greater Than Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2821</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_af0596ab318ba6d1ec5e7ed40871255a9"><div class="ttname"><a href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a></div><div class="ttdeci">static __binary128 vec_xfer_vui32t_2_bin128(vui32_t f128)</div><div class="ttdoc">Transfer a vector unsigned int to __binary128 scalar.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2311</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a6bafb410404d4f1e10a99263b57d1df0"><div class="ttname"><a href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a></div><div class="ttdeci">static vui128_t vec_subuqm(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Subtract Unsigned Quadword Modulo.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6866</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_ac263f88b177c2f3db909ca92e41e3ff9"><div class="ttname"><a href="vec__int128__ppc_8h.html#ac263f88b177c2f3db909ca92e41e3ff9">vec_negsq</a></div><div class="ttdeci">static vi128_t vec_negsq(vi128_t int128)</div><div class="ttdoc">Vector Negate Signed Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:5828</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_acb534c11a544d9e0b61acdecbb62adaa"><div class="ttname"><a href="vec__f64__ppc_8h.html#acb534c11a544d9e0b61acdecbb62adaa">vec_xvxexpdp</a></div><div class="ttdeci">static vui64_t vec_xvxexpdp(vf64_t vrb)</div><div class="ttdoc">Vector Extract Exponent Double-Precision.</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:1691</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a3975205947785b1745a791ef12256e9a"><div class="ttname"><a href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a></div><div class="ttdeci">#define VEC_BYTE_H</div><div class="ttdoc">Element index for highest order byte.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:350</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_ae8002c29875a226d11ec57a42b5b3955"><div class="ttname"><a href="vec__f128__ppc_8h.html#ae8002c29875a226d11ec57a42b5b3955">vec_xfer_vui64t_2_bin128</a></div><div class="ttdeci">static __binary128 vec_xfer_vui64t_2_bin128(vui64_t f128)</div><div class="ttdoc">Transfer a vector unsigned long long to __binary128 scalar.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2334</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a16cdf519bbbf190c311bd27d3e254208"><div class="ttname"><a href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></div><div class="ttdeci">__vector __bool __int128 vb128_t</div><div class="ttdoc">vector of one 128-bit bool __int128 element.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:240</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a24b1f22552fd177d10af1dbc0f43d5f8"><div class="ttname"><a href="vec__f128__ppc_8h.html#a24b1f22552fd177d10af1dbc0f43d5f8">vec_xscvuqqp</a></div><div class="ttdeci">static __binary128 vec_xscvuqqp(vui128_t int128)</div><div class="ttdoc">VXS Scalar Convert Unsigned-Quadword to Quad-Precision format.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:6439</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a55dcb361982b9da13b02373d720d6c7d"><div class="ttname"><a href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a></div><div class="ttdeci">static int vec_cmpud_all_lt(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare all Less than Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:1973</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_af95c675ceebc0627c777d2c7e2daef0b"><div class="ttname"><a href="vec__f128__ppc_8h.html#af95c675ceebc0627c777d2c7e2daef0b">vec_xsiexpqp</a></div><div class="ttdeci">static __binary128 vec_xsiexpqp(vui128_t sig, vui64_t exp)</div><div class="ttdoc">Scalar Insert Exponent Quad-Precision.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:6578</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_ae4520a89b9b5a292a3e647a6d5b712ad"><div class="ttname"><a href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a></div><div class="ttdeci">#define CONST_VINT128_W(__w0, __w1, __w2, __w3)</div><div class="ttdoc">Arrange word elements of a unsigned int initializer in high-&gt;low order. May require an explicit cast.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:304</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_af4ffb9244d1aa4482b683d35c3544194"><div class="ttname"><a href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a></div><div class="ttdeci">#define CONST_VINT64_DW(__dw0, __dw1)</div><div class="ttdoc">Arrange elements of dword initializer in high-&gt;low order.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:295</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_afb47075b07673afbf78f8c60298f3712"><div class="ttname"><a href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="ttdeci">__vector unsigned short vui16_t</div><div class="ttdoc">vector of 16-bit unsigned short elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:204</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a2c2c01f3aa165fedba47600f87067768"><div class="ttname"><a href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a></div><div class="ttdeci">static int vec_cmpuq_all_eq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare all Equal Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:3398</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a3b2bbf9f23490ccca3bdc08bc1dc7831"><div class="ttname"><a href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a></div><div class="ttdeci">__vector __int128 vi128_t</div><div class="ttdoc">vector of one 128-bit signed __int128 element.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:235</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a8a7660b170e71ec58ee95a79cd1c47d5"><div class="ttname"><a href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a></div><div class="ttdeci">static int vec_cmpud_all_eq(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare all Equal Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:1855</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a11c410994f958a6b4ac9583878a55a72"><div class="ttname"><a href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">vec_isnanf128</a></div><div class="ttdeci">static vb128_t vec_isnanf128(__binary128 f128)</div><div class="ttdoc">Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:5380</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a946ffd501b32f3ec96563ab101afbfad"><div class="ttname"><a href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">vec_all_isfinitef128</a></div><div class="ttdeci">static int vec_all_isfinitef128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is Finite (Not NaN nor Inf).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2422</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a443a43ae34ab3b78564d2a8277503cac"><div class="ttname"><a href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div><div class="ttdeci">vf128_t __binary128</div><div class="ttdoc">Define __binary128 if not defined by the compiler. Same as __float128 for PPC.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:1783</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a52a773b6353c69a546bdc2e8686a50ec"><div class="ttname"><a href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div><div class="ttdeci">__vector unsigned long long vui64_t</div><div class="ttdoc">vector of 64-bit unsigned long long elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:208</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a671e86d52ad53adce6a558476c7ffc0c"><div class="ttname"><a href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a></div><div class="ttdeci">static vui64_t vec_splatd(vui64_t vra, const int ctl)</div><div class="ttdoc">Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of ...</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:3004</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_aed458e4755a6589049b936cf9f24f6f8"><div class="ttname"><a href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a></div><div class="ttdeci">__vector unsigned char vui8_t</div><div class="ttdoc">vector of 8-bit unsigned char elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:202</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_aaf9d4ad5a60e9ffaa0ca16d29f90c092"><div class="ttname"><a href="vec__f128__ppc_8h.html#aaf9d4ad5a60e9ffaa0ca16d29f90c092">vec_xscvqpuqz</a></div><div class="ttdeci">static vui128_t vec_xscvqpuqz(__binary128 f128)</div><div class="ttdoc">VXS Scalar Convert with round to zero Quad-Precision to Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:6059</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a0b7aee3c81538f5537680b610d934500"><div class="ttname"><a href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a></div><div class="ttdeci">static vui64_t vec_subudm(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Subtract Unsigned Doubleword Modulo.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:3236</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a0fb3ddc8b334ae25119a02e749884290"><div class="ttname"><a href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a></div><div class="ttdeci">static vui64_t vec_vsld(vui64_t vra, vui64_t vrb)</div><div class="ttdoc">Vector Shift Left Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:3728</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_ab1eb10beac182e936d7e49d491c34fe0"><div class="ttname"><a href="vec__f128__ppc_8h.html#ab1eb10beac182e936d7e49d491c34fe0">vec_xsxsigqp</a></div><div class="ttdeci">static vui128_t vec_xsxsigqp(__binary128 f128)</div><div class="ttdoc">Scalar Extract Significand Quad-Precision.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:6676</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_ac05c640c6a42770cb95466ff4a2d903c"><div class="ttname"><a href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a></div><div class="ttdeci">static vui128_t vec_srqi(vui128_t vra, const unsigned int shb)</div><div class="ttdoc">Vector Shift Right Quadword Immediate.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6581</div></div>
<div class="ttc" id="avec__int16__ppc_8h_html_a292973c417034f4b8813765b63ca03c2"><div class="ttname"><a href="vec__int16__ppc_8h.html#a292973c417034f4b8813765b63ca03c2">vec_srhi</a></div><div class="ttdeci">static vui16_t vec_srhi(vui16_t vra, const unsigned int shb)</div><div class="ttdoc">Vector Shift Right Halfword Immediate.</div><div class="ttdef"><b>Definition:</b> vec_int16_ppc.h:1093</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a066cc120c198773a2f8dfd17480b7a49"><div class="ttname"><a href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49">vec_clzq</a></div><div class="ttdeci">static vui128_t vec_clzq(vui128_t vra)</div><div class="ttdoc">Vector Count Leading Zeros Quadword for unsigned __int128 elements.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2512</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_aee5c5b2998ef105b4c6f39739748ffa8"><div class="ttname"><a href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a></div><div class="ttdeci">static vui128_t vec_muludq(vui128_t *mulu, vui128_t a, vui128_t b)</div><div class="ttdoc">Vector Multiply Unsigned Double Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:5328</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_ad7aaadba249ce46c4c94f78df1020da3"><div class="ttname"><a href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a></div><div class="ttdeci">static vui128_t vec_addcuq(vui128_t a, vui128_t b)</div><div class="ttdoc">Vector Add &amp; write Carry Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2162</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_aaf7a8e92d8ba681dac3d2ec3259c0820"><div class="ttname"><a href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a></div><div class="ttdeci">__vector unsigned __int128 vui128_t</div><div class="ttdoc">vector of one 128-bit unsigned __int128 element.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:237</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_ab63ac21e968bf199eadd72f94b653905"><div class="ttname"><a href="vec__f64__ppc_8h.html#ab63ac21e968bf199eadd72f94b653905">vec_all_isnormalf64</a></div><div class="ttdeci">static int vec_all_isnormalf64(vf64_t vf64)</div><div class="ttdoc">Return true if all 2x64-bit vector double values are normal (Not NaN, Inf, denormal,...</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:388</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_a27becc842e7270c96c54a00d4a292d54"><div class="ttname"><a href="vec__f64__ppc_8h.html#a27becc842e7270c96c54a00d4a292d54">vec_all_iszerof64</a></div><div class="ttdeci">static int vec_all_iszerof64(vf64_t vf64)</div><div class="ttdoc">Return true if all 2x64-bit vector double values are +-0.0.</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:480</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a03cdec54548bd95e04d4835d96b1bea4"><div class="ttname"><a href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a></div><div class="ttdeci">static vui64_t vec_clzd(vui64_t vra)</div><div class="ttdoc">Vector Count Leading Zeros Doubleword for unsigned long long elements.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:975</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a82d83d78ff2330205a8d74741b34a1be"><div class="ttname"><a href="vec__int128__ppc_8h.html#a82d83d78ff2330205a8d74741b34a1be">vec_cmpltsq</a></div><div class="ttdeci">static vb128_t vec_cmpltsq(vi128_t vra, vi128_t vrb)</div><div class="ttdoc">Vector Compare Less Than Signed Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2951</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a66fc4e7c94d0b30bb3515931aaf723da"><div class="ttname"><a href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a></div><div class="ttdeci">static int vec_all_isinff128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is infinity.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2454</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_af74036e39e72e0f3c29706d30fbb96d1"><div class="ttname"><a href="vec__int128__ppc_8h.html#af74036e39e72e0f3c29706d30fbb96d1">vec_setb_cyq</a></div><div class="ttdeci">static vb128_t vec_setb_cyq(vui128_t vcy)</div><div class="ttdoc">Vector Set Bool from Quadword Carry.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6103</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_aedfcf3adea80e0407b40c6ec0e851aab"><div class="ttname"><a href="vec__f128__ppc_8h.html#aedfcf3adea80e0407b40c6ec0e851aab">vec_andc_bin128_2_vui32t</a></div><div class="ttdeci">static vui32_t vec_andc_bin128_2_vui32t(__binary128 f128, vui32_t mask)</div><div class="ttdoc">Transfer a quadword from a __binary128 scalar to a vector int and logical AND Compliment with mask.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:1937</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a4d5b388cfc9af26418bdd4ec8e4e6f73"><div class="ttname"><a href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73">vec_setb_qp</a></div><div class="ttdeci">static vb128_t vec_setb_qp(__binary128 f128)</div><div class="ttdoc">Vector Set Bool from Quadword Floating-point.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:5661</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_af8b42004c11b01c7606d8d6e299e8107"><div class="ttname"><a href="vec__f64__ppc_8h.html#af8b42004c11b01c7606d8d6e299e8107">vec_xvxsigdp</a></div><div class="ttdeci">static vui64_t vec_xvxsigdp(vf64_t vrb)</div><div class="ttdoc">Vector Extract Significand Double-Precision.</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:1740</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_af21d01bb19f0ea8605d8c37035837802"><div class="ttname"><a href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802">vec_setb_sq</a></div><div class="ttdeci">static vb128_t vec_setb_sq(vi128_t vra)</div><div class="ttdoc">Vector Set Bool from Signed Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6170</div></div>
<div class="ttc" id="avec__f64__ppc_8h_html_a6bdfdf013a97ccd6dc20b1447f81d498"><div class="ttname"><a href="vec__f64__ppc_8h.html#a6bdfdf013a97ccd6dc20b1447f81d498">vec_all_isfinitef64</a></div><div class="ttdeci">static int vec_all_isfinitef64(vf64_t vf64)</div><div class="ttdoc">Return true if all 2x64-bit vector double values are Finite (Not NaN nor Inf).</div><div class="ttdef"><b>Definition:</b> vec_f64_ppc.h:253</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a9d8b8de825b673b53cd50458dfc6efa8"><div class="ttname"><a href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a></div><div class="ttdeci">#define VEC_DW_L</div><div class="ttdoc">Element index for low order dword.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:324</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a27bfd64d7eefd8e84619950f19f827ba"><div class="ttname"><a href="vec__f128__ppc_8h.html#a27bfd64d7eefd8e84619950f19f827ba">vec_xscvsqqp</a></div><div class="ttdeci">static __binary128 vec_xscvsqqp(vi128_t int128)</div><div class="ttdoc">VXS Scalar Convert Signed-Quadword to Quad-Precision format.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:6298</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a7197cd5c6e946211f2718b5e8464cdc0"><div class="ttname"><a href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0">vec_cmpequq</a></div><div class="ttdeci">static vb128_t vec_cmpequq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Compare Equal Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2637</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_a2ff4a776536870e01b7c9e454586544b"><div class="ttname"><a href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div><div class="ttdeci">__vector unsigned int vui32_t</div><div class="ttdoc">vector of 32-bit unsigned int elements.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:206</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_adfb73eac40698921735bad8ac4ce560e"><div class="ttname"><a href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e">vec_copysignf128</a></div><div class="ttdeci">static __binary128 vec_copysignf128(__binary128 f128x, __binary128 f128y)</div><div class="ttdoc">Copy the sign bit from f128y and merge with the magnitude from f128x. The merged result is returned a...</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2664</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_aaa33904ec4de42f54cceab34adb303c5"><div class="ttname"><a href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a></div><div class="ttdeci">static vui128_t vec_sldqi(vui128_t vrw, vui128_t vrx, const unsigned int shb)</div><div class="ttdoc">Vector Shift Left Double Quadword Immediate.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6243</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_aae0e62b9910ec833dfc20719d09e526e"><div class="ttname"><a href="vec__f128__ppc_8h.html#aae0e62b9910ec833dfc20719d09e526e">vec_and_bin128_2_vui32t</a></div><div class="ttdeci">static vui32_t vec_and_bin128_2_vui32t(__binary128 f128, vui32_t mask)</div><div class="ttdoc">Transfer a quadword from a __binary128 scalar to a vector int and logical AND with a mask.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:1892</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a539de2a4426a84102471306acc571ce8"><div class="ttname"><a href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a></div><div class="ttdeci">static vui128_t vec_adduqm(vui128_t a, vui128_t b)</div><div class="ttdoc">Vector Add Unsigned Quadword Modulo.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:2333</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a6264e6ca42126726b0e490754dde0db7"><div class="ttname"><a href="vec__int64__ppc_8h.html#a6264e6ca42126726b0e490754dde0db7">vec_cmpud_all_ge</a></div><div class="ttdeci">static int vec_cmpud_all_ge(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare all Greater Than or Equal Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:1885</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a3d78e42d9cc58491fa46149bf5798167"><div class="ttname"><a href="vec__f128__ppc_8h.html#a3d78e42d9cc58491fa46149bf5798167">vec_xsxexpqp</a></div><div class="ttdeci">static vui64_t vec_xsxexpqp(__binary128 f128)</div><div class="ttdoc">Scalar Extract Exponent Quad-Precision.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:6627</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a28052c1907d1f733c9dda8a48039e546"><div class="ttname"><a href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a></div><div class="ttdeci">static vui64_t vec_addudm(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Add Unsigned Doubleword Modulo.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:923</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_afc830b382bd45dc0ff815024c1bfb26d"><div class="ttname"><a href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">vec_all_isnormalf128</a></div><div class="ttdeci">static int vec_all_isnormalf128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2532</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a0edd172a5656b842d6586c5078284942"><div class="ttname"><a href="vec__int128__ppc_8h.html#a0edd172a5656b842d6586c5078284942">vec_srq</a></div><div class="ttdeci">static vui128_t vec_srq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Shift Right Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6541</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_a91b99b632646aaca91de6834e2b1da26"><div class="ttname"><a href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">vec_xfer_vui128t_2_bin128</a></div><div class="ttdeci">static __binary128 vec_xfer_vui128t_2_bin128(vui128_t f128)</div><div class="ttdoc">Transfer a vector unsigned __int128 to __binary128 scalar.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2357</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a42d2b39711c06106097ef869a20420b6"><div class="ttname"><a href="vec__int64__ppc_8h.html#a42d2b39711c06106097ef869a20420b6">vec_swapd</a></div><div class="ttdeci">static vui64_t vec_swapd(vui64_t vra)</div><div class="ttdoc">Vector doubleword swap. Exchange the high and low doubleword elements of a vector.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:3279</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_af7fb1013dfcf633156cd7f855a11fb56"><div class="ttname"><a href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a></div><div class="ttdeci">static __binary128 vec_const_nanf128()</div><div class="ttdoc">return a quiet NaN.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2714</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_af06b73ac57985011c558670adc283e89"><div class="ttname"><a href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a></div><div class="ttdeci">static int vec_all_isnanf128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is Not a Number (NaN).</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2488</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a070fe972995f3954362835f5b72e5ff6"><div class="ttname"><a href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a></div><div class="ttdeci">static vui128_t vec_slqi(vui128_t vra, const unsigned int shb)</div><div class="ttdoc">Vector Shift Left Quadword Immediate.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6342</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a49fe2c36fca9911ab99a1f8abb53f0ff"><div class="ttname"><a href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a></div><div class="ttdeci">static vui128_t vec_slq(vui128_t vra, vui128_t vrb)</div><div class="ttdoc">Vector Shift Left Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6301</div></div>
<div class="ttc" id="avec__int64__ppc_8h_html_a560aef2acfdf1db1cf14848ec6cb0c1c"><div class="ttname"><a href="vec__int64__ppc_8h.html#a560aef2acfdf1db1cf14848ec6cb0c1c">vec_cmpequd</a></div><div class="ttdeci">static vb64_t vec_cmpequd(vui64_t a, vui64_t b)</div><div class="ttdoc">Vector Compare Equal Unsigned Doubleword.</div><div class="ttdef"><b>Definition:</b> vec_int64_ppc.h:1113</div></div>
<div class="ttc" id="avec__common__ppc_8h_html_adb2bc7bad8fc5c335244ac6f877f3c8f"><div class="ttname"><a href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a></div><div class="ttdeci">#define VEC_DW_H</div><div class="ttdoc">Element index for high order dword.</div><div class="ttdef"><b>Definition:</b> vec_common_ppc.h:322</div></div>
<div class="ttc" id="avec__f128__ppc_8h_html_ac554a9d0d12fca036772aaaee5908414"><div class="ttname"><a href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">vec_all_iszerof128</a></div><div class="ttdeci">static int vec_all_iszerof128(__binary128 f128)</div><div class="ttdoc">Return true if the __float128 value is +-0.0.</div><div class="ttdef"><b>Definition:</b> vec_f128_ppc.h:2631</div></div>
<div class="ttc" id="avec__int128__ppc_8h_html_a5949bfddc954f2a50922abfbd32176cd"><div class="ttname"><a href="vec__int128__ppc_8h.html#a5949bfddc954f2a50922abfbd32176cd">vec_seluq</a></div><div class="ttdeci">static vui128_t vec_seluq(vui128_t vra, vui128_t vrb, vb128_t vrc)</div><div class="ttdoc">Vector Select Unsigned Quadword.</div><div class="ttdef"><b>Definition:</b> vec_int128_ppc.h:6076</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 27 2021 16:15:49 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
