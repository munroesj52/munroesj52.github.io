<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="vec__int512__ppc_8h">
    <title>vec_int512_ppc.h File Reference</title>
    <programlisting>#include &lt;pveclib/vec_int128_ppc.h&gt;</programlisting>
        <section>
            <title> Classes </title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="struct____VEC__U__256">__VEC_U_256</link></para>
<para><emphasis>A vector representation of a 256-bit unsigned integer.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="struct____VEC__U__512">__VEC_U_512</link></para>
<para><emphasis>A vector representation of a 512-bit unsigned integer.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="struct____VEC__U__640">__VEC_U_640</link></para>
<para><emphasis>A vector representation of a 640-bit unsigned integer.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="union____VEC__U__512x1">__VEC_U_512x1</link></para>
<para><emphasis>A vector representation of a 512-bit unsigned integer
and a 128-bit carry-out.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="struct____VEC__U__1024">__VEC_U_1024</link></para>
<para><emphasis>A vector representation of a 1024-bit unsigned integer.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="struct____VEC__U__1152">__VEC_U_1152</link></para>
<para><emphasis>A vector representation of a 1152-bit unsigned integer.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="struct____VEC__U__2048">__VEC_U_2048</link></para>
<para><emphasis>A vector representation of a 2048-bit unsigned integer.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="union____VEC__U__1024x512">__VEC_U_1024x512</link></para>
<para><emphasis>A vector representation of a 1024-bit unsigned integer
as two 512-bit fields.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="union____VEC__U__2048x512">__VEC_U_2048x512</link></para>
<para><emphasis>A vector representation of a 2048-bit unsigned integer
as 4 x 512-bit integer fields.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="struct____VEC__U__2176">__VEC_U_2176</link></para>
<para><emphasis>A vector representation of a 2176-bit unsigned integer.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="struct____VEC__U__4096">__VEC_U_4096</link></para>
<para><emphasis>A vector representation of a 4096-bit unsigned integer.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>struct <link linkend="union____VEC__U__4096x512">__VEC_U_4096x512</link></para>
<para><emphasis>A vector representation of a 4096-bit unsigned integer
as 8 x 512-bit integer fields.</emphasis></para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title>Macros</title>
            <para>
                <itemizedlist>
                    <listitem>
                            <para>#define <link linkend="vec__int512__ppc_8h_1aac9d31829610c29b0f5558bfb1f18e4a">CONST_VINT512_Q</link> {__q3, __q2, __q1, __q0}<para><emphasis>Generate a 512-bit vector unsigned integer constant from
    4 x quadword constants.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                            <para>#define <link linkend="vec__int512__ppc_8h_1a9376cb8baadb875605593f95422a1902">COMPILE_FENCE</link> __asm (&quot;;&quot;:::)<para><emphasis>A compiler fence to prevent excessive code motion.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                            <para>#define <link linkend="vec__int512__ppc_8h_1a77eca5d7bebe0f30894fe9669c01b7a7">__VEC_PWR_IMP</link> FNAME ## _PWR7<para><emphasis>Macro to add platform suffix for static calls.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title>Functions</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__640">__VEC_U_640</link> <link linkend="vec__int512__ppc_8h_1abf330c11973fdef2cccefa199c3473b9">vec_add512cu</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> a, <link linkend="struct____VEC__U__512">__VEC_U_512</link> b)<para><emphasis>Vector Add 512-bit Unsigned Integer &amp; Write Carry.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__640">__VEC_U_640</link> <link linkend="vec__int512__ppc_8h_1a65346bdb9a4a7cc51bcca3e26443936a">vec_add512ecu</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> a, <link linkend="struct____VEC__U__512">__VEC_U_512</link> b, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> c)<para><emphasis>Vector Add Extended 512-bit Unsigned Integer &amp; Write Carry.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__512">__VEC_U_512</link> <link linkend="vec__int512__ppc_8h_1a386ebc9ccc979fc415b8d6d66ef2e31c">vec_add512eum</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> a, <link linkend="struct____VEC__U__512">__VEC_U_512</link> b, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> c)<para><emphasis>Vector Add Extended 512-bit Unsigned Integer Modulo.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__512">__VEC_U_512</link> <link linkend="vec__int512__ppc_8h_1a7508430b3dbea4d708c1e45de93dca04">vec_add512um</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> a, <link linkend="struct____VEC__U__512">__VEC_U_512</link> b)<para><emphasis>Vector Add 512-bit Unsigned Integer Modulo.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__512">__VEC_U_512</link> <link linkend="vec__int512__ppc_8h_1a07a919fc91b93cf47cd48c9dd2a79ae6">vec_add512ze</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> a, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> c)<para><emphasis>Vector Add 512-bit to Zero Extended Unsigned
Integer Modulo.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__512">__VEC_U_512</link> <link linkend="vec__int512__ppc_8h_1a3f54578765372cc100062d52caaba70c">vec_add512ze2</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> a, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> c1, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> c2)<para><emphasis>Vector Add 512-bit to Zero Extended2 Unsigned
Integer Modulo.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__256">__VEC_U_256</link> <link linkend="vec__int512__ppc_8h_1a958e029fc824ec3a73ad9550bf7ea506">vec_mul128x128_inline</link> (
<link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> a, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> b)<para><emphasis>Vector 128x128bit Unsigned Integer Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__512">__VEC_U_512</link> <link linkend="vec__int512__ppc_8h_1a92120de408d445766efcd709d73840d9">vec_mul256x256_inline</link> (
<link linkend="struct____VEC__U__256">__VEC_U_256</link> m1, <link linkend="struct____VEC__U__256">__VEC_U_256</link> m2)<para><emphasis>Vector 256x256-bit Unsigned Integer Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__640">__VEC_U_640</link> <link linkend="vec__int512__ppc_8h_1ad10d62fe43f329c396b6486402f4f7af">vec_mul512x128_inline</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> m1, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> m2)<para><emphasis>Vector 512x128-bit Unsigned Integer Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__640">__VEC_U_640</link> <link linkend="vec__int512__ppc_8h_1a9f2101271dd5d072a8406bbed160b9c8">vec_madd512x128a128_inline</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> m1, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> m2, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> a1)<para><emphasis>Vector 512x128-bit Multiply-Add Unsigned Integer.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__640">__VEC_U_640</link> <link linkend="vec__int512__ppc_8h_1ac9f6153c72e2194f14627ffca1b26c17">vec_madd512x128a512_inline</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> m1, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> m2, <link linkend="struct____VEC__U__512">__VEC_U_512</link> a2)<para><emphasis>Vector 512x128-bit Multiply-Add Unsigned Integer.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__640">__VEC_U_640</link> <link linkend="vec__int512__ppc_8h_1a68ccbd4fd74977eb3f69276c6b934c26">vec_madd512x128a128a512_inline</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> m1, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> m2, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> a1, <link linkend="struct____VEC__U__512">__VEC_U_512</link> a2)<para><emphasis>Vector 512x128-bit Multiply-Add Unsigned Integer.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__1024">__VEC_U_1024</link> <link linkend="vec__int512__ppc_8h_1a6f917597902625a8218ba41fc6dca426">vec_mul512x512_inline</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> m1, <link linkend="struct____VEC__U__512">__VEC_U_512</link> m2)<para><emphasis>Vector 512x512-bit Unsigned Integer Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static <link linkend="struct____VEC__U__1024">__VEC_U_1024</link> <link linkend="vec__int512__ppc_8h_1a666241f67c39d7fae639235edfb8c3b5">vec_madd512x512a512_inline</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> m1, <link linkend="struct____VEC__U__512">__VEC_U_512</link> m2, <link linkend="struct____VEC__U__512">__VEC_U_512</link> a1)<para><emphasis>Vector 512-bit Unsigned Integer Multiply-Add.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="struct____VEC__U__256">__VEC_U_256</link> <link linkend="vec__int512__ppc_8h_1ab5b80fd9694cea8bf502b26e55af37f7">vec_mul128x128</link> (
<link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> m1, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> m2)<para><emphasis>Vector 128x128bit Unsigned Integer Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="struct____VEC__U__512">__VEC_U_512</link> <link linkend="vec__int512__ppc_8h_1a131bdfc55718991610c886b2c77f6ae7">vec_mul256x256</link> (
<link linkend="struct____VEC__U__256">__VEC_U_256</link> m1, <link linkend="struct____VEC__U__256">__VEC_U_256</link> m2)<para><emphasis>Vector 256x256-bit Unsigned Integer Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="struct____VEC__U__640">__VEC_U_640</link> <link linkend="vec__int512__ppc_8h_1a0cfdc3e00f5e2c3a9a959969f684203e">vec_mul512x128</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> m1, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> m2)<para><emphasis>Vector 512x128-bit Unsigned Integer Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="struct____VEC__U__640">__VEC_U_640</link> <link linkend="vec__int512__ppc_8h_1acf5c808a77a8486a82a9ee87ff414fd2">vec_madd512x128a512</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> m1, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> m2, <link linkend="struct____VEC__U__512">__VEC_U_512</link> a2)<para><emphasis>Vector 512x128-bit Multiply-Add Unsigned Integer.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="struct____VEC__U__1024">__VEC_U_1024</link> <link linkend="vec__int512__ppc_8h_1a56a5da10870d9878e2ab888d3c4d2e7b">vec_mul512x512</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> m1, <link linkend="struct____VEC__U__512">__VEC_U_512</link> m2)<para><emphasis>Vector 512x512-bit Unsigned Integer Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="vec__int512__ppc_8h_1ad4ade47617ecf223a2f7b0325e1fc877">vec_mul1024x1024</link> (
<link linkend="struct____VEC__U__2048">__VEC_U_2048</link> * p2048, <link linkend="struct____VEC__U__1024">__VEC_U_1024</link> * m1, <link linkend="struct____VEC__U__1024">__VEC_U_1024</link> * m2)<para><emphasis>Vector 1024x1024-bit Unsigned Integer Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="vec__int512__ppc_8h_1a8287aa4483acb25ac3188a97cc23b89a">vec_mul2048x2048</link> (
<link linkend="struct____VEC__U__4096">__VEC_U_4096</link> * p4096, <link linkend="struct____VEC__U__2048">__VEC_U_2048</link> * m1, <link linkend="struct____VEC__U__2048">__VEC_U_2048</link> * m2)<para><emphasis>Vector 2048x2048-bit Unsigned Integer Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="vec__int512__ppc_8h_1a1a6652dfd5b6e5966acf4b75f0b89682">vec_mul128_byMN</link> (
<link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> * p, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> * m1, <link linkend="vec__common__ppc_8h_1aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</link> * m2, unsigned long M, unsigned long N)<para><emphasis>Vector Unsigned Integer Quadword MxN Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="vec__int512__ppc_8h_1a46ee75bf2ea0b7095d60f1448cf2f097">vec_mul512_byMN</link> (
<link linkend="struct____VEC__U__512">__VEC_U_512</link> * p, <link linkend="struct____VEC__U__512">__VEC_U_512</link> * m1, <link linkend="struct____VEC__U__512">__VEC_U_512</link> * m2, unsigned long M, unsigned long N)<para><emphasis>Vector Unsigned Integer Quadword 4xMxN Multiply.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    <simplesect>
        <title>Detailed Description</title>

<para>Header package containing a collection of multiple precision quadword integer computation functions implemented with 128-bit PowerISA VMX and VSX instructions. </para>

<para>PVECLIB <link linkend="vec__int128__ppc_8h">vec_int128_ppc.h</link> provides the 128x128-bit multiply and 128-bit add with carry/extend operations. This is most of what we need to implement multiple precision integer computation. This header builds on those operations to build 256x256, 512x128, 512x512, 1024x1024 and 2048x2048 multiplies. We also provide 512-bit add with carry/extend operations as a general aid to construct multiple quadword precision arithmetic.</para>

<para>We provide static inline implementations for up to 512x512 multiplies and 512x512 add with carry/extend. These in-line operations are provided as building blocks for coding implementations of larger multiply and sum operations. Otherwise the in-line code expansion is getting too large for normal coding. So we also provide callable (static and dynamic) library implementations as well (<link linkend="vec__int512__ppc_8h_1i512_libary_issues_0_0">Building libraries for vec_int512_ppc</link>).</para>
<section xml:id="vec__int512__ppc_8h_1i512_security_issues_0_0">
<title>Security related implications</title>

<para>The challenge is delivering a 2048x2048 bit multiply, producing a 4096-bit product, while minimizing cache and timing side-channel exploits. The goal is to minimize the memory visibility of intermediate products and sums and internal conditional logic (like early exit optimizations). The working theory is to use vector registers and operations and avoid storing intermediate results. This implies:<itemizedlist>
<listitem>
<para>While the final 4096-bit product is so large (32 quadwords), it requires a memory buffer for the result, we should not use any part of this buffer to hold intermediate partial sums.</para>
</listitem><listitem>
<para>The 2048-bit multiplicands are also large (2 x 16 quadwords) and will be passed in memory buffers that are effectively constant.</para>
</listitem><listitem>
<para>All intermediate partial products and sums should be held in vector registers (VSRs) until quadwords of the final product are computed and ready to store into the result buffer.</para>
</listitem><listitem>
<para>Avoid conditional logic that effects function timing based on values of the inputs or results.</para>
</listitem><listitem>
<para>Internally the code can be organized as straight line code or loops, in-line functions or calls to carefully crafted leaf functions, as long as the above goals are met.</para>
</listitem></itemizedlist>
</para>

<para>Achieving these goals requires some knowledge of the Application Binary Interface (ABI) and foibles of the Instruction Set Architecture (PowerISA) and how they impact what the compiler can generate. The compiler itself has internal strategies (and foibles) that need to be managed as well.</para>
<section xml:id="vec__int512__ppc_8h_1i512_security_issues_0_0_0">
<title>Implications of the ABI</title>

<para>The computation requires a number of internal temporary vectors in addition to the inputs and outputs. The Power Architecture, 64-Bit ELF V2 ABI Specification (AKA the ABI) places some generous but important restrictions on how the compiler generates code (and how compliant assembler code is written).<itemizedlist>
<listitem>
<para>Up to 20 volatile vector registers v0-v19 (VSRs vs32-vs51) of which 12 can be used for function arguments/return values.<itemizedlist>
<listitem>
<para>Up to 12 vector arguments are passed in vector registers v2-v13 (VSRs vs34-vs45).</para>
</listitem><listitem>
<para>Longer vector argument lists are forced into the callers parameter save area (Stack pointer +32).</para>
</listitem><listitem>
<para>Functions can return a 128-bit vector value or a homogeneous aggregate of up to 8 vector values in vector registers v2-v9 (VSRs 34-41).</para>
</listitem><listitem>
<para>Wider (8 x vectors) function return values are returned in memory via a reference pointer passed as a hidden parameter in GPR 3.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>Up to 12 additional non-volatile vector registers v20-v31 (vs51-vs63). Any non-volatile registers must be saved before use and restored before function return.</para>
</listitem><listitem>
<para>The lower half for the VSRs (vs0-vs31) are prioritized for scalar floating-point operations. If a function is using vectors and but not scalar floating-point then the lower VSRs are available for vector logical and integer operations and temporary spill from vector registers.<itemizedlist>
<listitem>
<para>Up to 14 volatile float double (f0-f13) or vector registers (vs0-vs13).</para>
</listitem><listitem>
<para>Up to 18 non-volatile float double (f14-f31) or vector registers (vs14-vs31).</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>All volatile registers are a considered “clobbered” after a function call.<itemizedlist>
<listitem>
<para>So the calling function must hold any local vector variables in memory or non-volatile registers if the live range extends across the function call.</para>
</listitem><listitem>
<para>In-lining the called function allows the compiler to manage register allocation across the whole sequence. This can reduce register pressure when the called function does not actually use/modify all the volatile registers.</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<section xml:id="vec__int512__ppc_8h_1i512_security_issues_0_0_0_0">
<title>Implications for parameter passing and Product size</title>

<para>Care is required in selecting the width (256, 512-bit etc) of parameter and return values. Parameters totaling more then 12 vector quadwords or return values totaling more then 8 vector quadwords will be spilled to the callers parameter save area. This may expose intermediate partial products to cache side-channel attacks. A 512x128-bit multiply returning a 640-bit product and a 512x512-bit multiply returning a 1024-bit product meets this criteria (both the parameters and return values fit within the ABI limits). But a 1024x128-bit multiply returning 1152-bits is not OK because the 1152-bit return value requires 9 vector registers, which will be returned in memory.</para>

<para>Also if any of these sub-functions are used without in-lining, the generated code must be inspected to insure it is not spilling any local variables. In my experiments with GCC 8.1 the 128x128, 256x256, and 512x128 multiplies all avoid spilling. However the stand-alone 512x512 implementation does require saving 3 non-volatile registers. This can be eliminated by in-lining the 512x512 multiply into the 2048x2048 multiply function.</para>

<para><formalpara><title>Note: </title>

<para>GCC compilers before version 8 have an incomplete design for homogeneous aggregates of vectors and may generate sub-optimal code for these parameters.</para>
</formalpara>
</para>
</section>
</section>
<section xml:id="vec__int512__ppc_8h_1i512_security_issues_0_0_1">
<title>Implications of the PowerISA</title>

<para>The Power Instruction Set Architecture (PowerISA) also imposes some restriction on the registers vector instructions can access.<itemizedlist>
<listitem>
<para>The original VMX (AKA Altivec) facility has 32 vector registers and instruction encoding to access those 32 registers.<itemizedlist>
<listitem>
<para>This original instruction set was incorporated unchanged into the later versions of the PowerISA.</para>
</listitem><listitem>
<para>When Vector Scalar Extended facility was added, the original VMX instructions where restricted to the upper 32 VSRs (original vector registers).</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>VSX was originally focused on vector and scalar floating-point operations. With a handful of vector logical/permute/splat operations added for completeness. These instructions where encoded to access all 64 VSRs.<itemizedlist>
<listitem>
<para>All vector integer arithmetic operations remained restricted to the upper 32 VSRs (the original VRs).</para>
</listitem><listitem>
<para>Later versions of the PowerISA (POWER8/9) added new vector integer arithmetic operations. This includes word/doubleword multiply and doubleword/quadword add/subtract. But these are also encoded to access only 32 vector registers.</para>
</listitem><listitem>
<para>The lower VSRs can still be used hold temporaries and local variables for vector integer operations.</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="vec__int512__ppc_8h_1i512_security_issues_0_0_2">
<title>Implications for the compiler</title>

<para>The compiler has to find a path though the ABI and ISA restriction above while it performs:<itemizedlist>
<listitem>
<para>function in-lining</para>
</listitem><listitem>
<para>instruction selection</para>
</listitem><listitem>
<para>instruction scheduling</para>
</listitem><listitem>
<para>register allocation</para>
</listitem></itemizedlist>
</para>

<para>For operations defined in PVECLIB, most operations are defined in terms of AltiVec/VSX Built-in Functions. So the compiler does not get much choice for instruction selection. The PVECLIB coding style does leverage C language vector extensions to load constants and manage temporary variables. Using compiler Altivec/VSX built-ins and vector extensions allows the compiler visibility to and control of these optimizations.</para>

<para>Internal function calls effectively <emphasis>clobber</emphasis> all (34 VSRs) volatile registers. As the compiler marshals parameters into ABI prescribed VRs it needs to preserve previous live content for later computation. Similarly for volatile registers not used for parameter passing as they are assumed to be clobbered by the called function. The compiler preserves local live variables before the call by copying their contents to non-volatile registers or spilling to memory. This may put more <emphasis>register pressure</emphasis> on the available non-volatile registers. Small to medium sized functions often require only a fraction of the available volatile registers. In this case, in-lining the function avoids the disruptive volatile register clobber and allows better overall register allocation. So there is a strong incentive to in-line local/static functions.</para>

<para>These compiler optimizations are not independent processes. For example specific VSX instruction can access all 64 VSRs, others are restricted to the 32 VRs (like vector integer instructions). So the compiler prioritizes VRs (the higher 32 VSRs) for allocation to vector integer computation. While the lower 32 VSRs can be used for logical/permute operations and as a <emphasis>level 1</emphasis> spill area for VRs. These restrictions combined with code size/complexity can increase <emphasis>register pressure</emphasis> to the point the compiler is forced to spill active (or live) vector registers to secondary storage. This secondary storage can be:<itemizedlist>
<listitem>
<para>other architected registers that are available for direct transfer but not usable in the computation.</para>
</listitem><listitem>
<para>Local variables allocated on the stack</para>
</listitem><listitem>
<para>Compiler temporaries allocated on the stack.</para>
</listitem></itemizedlist>
</para>

<para>Instruction scheduling can increase register pressure by moving (reordering) instructions. This is more prevalent when there are large differences in instruction latency in the code stream. For example moving independent / long latency instructions earlier and dependent / short latency instructions later. This tends to increase the distance between the instruction that sets a register result and the next instruction the uses that result in its computation. The distance between a registers set and use is called the <emphasis>live range</emphasis>. This also tends to increase the number of concurrently active and overlapping live ranges.</para>

<para>For this specific (multi-precision integer multiply) example, integer multiple and add/carry/extend instructions predominate. For POWER9, vector integer multiply instructions run 7 cycles, while integer add/carry/extend quadword instruction run 3 cycles. The compiler will want to move the independent multiply instructions earlier while the dependent add/carry instructions are moved later until the latency of the (multiply) instruction (on which it depends) is satisfied. Moving dependent instructions apart and moving independent instructions into the scheduling gap increases register pressure.</para>

<para>In extreme cases, this can get out of hand. At high optimization levels, the compiler can push instruction scheduling to the point that it runs out of registers. This forces the compiler to spill live register values, splitting the live range into two smaller live ranges. Any spilled values have to be reloaded later so they can used in computation. This causes the compiler to generate more instructions that need additional register allocation and scheduling.</para>

<para><formalpara><title>Note: </title>

<para>A 2048x2048-bit multiply is definitely an extreme case. The implementation requires 256 128x128-bit multiplies, where each 128x128-bit multiply requires 18-30 instructions. The POWER9 implementation requires 1024 vector doublewword multiplies plus 2400+ vector add/carry/extend quadword instructions. When implemented as straight line code and expanded in-line (<emphasis>attribute (flatten)</emphasis>) the total runs over 6000 instructions.</para>
</formalpara>
Compiler spill code usually needs registers in addition (perhaps of a different class) to the registers being spilled. This can be as simple as moving to a register of the same size but different class. For example, register moves to/from VRs and the lower 32 VSRs. But it gets more complex when spilling vector registers to memory. For example, vector register spill code needs GPRs to compute stack addresses for vector load/store instructions. Normally this OK, unless the the spill code consumes so many GPRs that it needs to spill GPRs. In that case we can see serious performance bottlenecks.</para>

<para>But remember that a primary goal (<link linkend="vec__int512__ppc_8h_1i512_security_issues_0_0">Security related implications</link>) was to avoid spilling intermediate results to memory. Spilling between high and low VSRs is acceptable (no cache side-channel), but spilling to memory must be avoided. The compiler should have heuristics to back off in-lining and scheduling-driven code motions just enough to avoid negative performance impacts. But this is difficult to model and may not handle all cases with equal grace. Also this may not prevent spilling VRs to memory if the compiler scheduler&apos;s cost computation indicates that is an acceptable trade-off.</para>

<para>So we will have to directly override compiler settings and heuristics to guarantee the result we want/need. The PVECLIB implementation already marks most operations as <emphasis role="bold">static inline</emphasis>. But as we use these inline operations as building blocks to implement larger operations we can push the resulting code size over the compiler&apos;s default inline limits (<emphasis role="bold">-finline-limit</emphasis>). Then compiler will stop in-lining for the duration of compiling the current function.</para>

<para>This may require stronger options/attributes to the compiler like (<emphasis>attribute (always_inline)</emphasis>), (<emphasis>attribute (gnu_inline)</emphasis>), or (<emphasis>attribute (flatten)</emphasis>). The first two are not any help unless you are compiling at lower optimization level (<emphasis role="bold">-O0</emphasis> or <emphasis role="bold">-O1</emphasis>). <emphasis role="bold">-O2</emphasis> defaults to <emphasis role="bold">-finline-small-functions</emphasis> and <emphasis role="bold">-O3</emphasis> defaults to the stronger <emphasis role="bold">-finline-functions</emphasis>. However <emphasis>attribute (flatten)</emphasis> seems do exactly what we want. Every call inside this function is in-lined unless explicitly told not to (<emphasis>attribute (noinline)</emphasis>). It seems that <emphasis>attribute (flatten)</emphasis> ignores the <emphasis role="bold">-finline-limit</emphasis>.</para>

<para><formalpara><title>Note: </title>

<para>You should be compiling PVECLIB applications at <emphasis role="bold">-O3</emphasis> anyway.</para>
</formalpara>
Now we have a large block of code for the compiler&apos;s instruction scheduler to work on. In this case the code is very repetitive (multiply, add the column, generate carries, repeat). The instruction will have lots of opportunity for scheduling long vs short latency instructions and create new and longer live ranges.</para>

<para>/note In fact after applying <emphasis>attribute (flatten)</emphasis> to vec_mul2048x2048_PWR9 we see a lot of spill code. This expands the code to over 9300 instructions with ~3300 instructions associated with spill code.</para>

<para>We need a mechanism to limit (set boundaries) on code motion while preserving optimization over smaller blocks of code. This is normally called a <emphasis>compiler fence</emphasis> but there are multiple definitions so we need to be careful what we use.</para>

<para>We want something that will prevent the compiler from moving instructions (in either direction) across specified <emphasis>lines in the code</emphasis>.</para>

<para>We don&apos;t need an atomic memory fence (like <emphasis role="bold"> __atomic_thread_fence</emphasis> or <emphasis role="bold">__sync_synchronize</emphasis>) that forces the processor to order loads and stores relative to a specific synchronization point.</para>

<para>We don&apos;t need a compiler memory fence (like <emphasis role="bold">asm (&quot;&quot; ::: &quot;memory&quot;)</emphasis>). The &quot;memory&quot; clobber forces GCC to assume that any memory may be arbitrarily read or written by the asm block. So any registers holding live local variables will be forced to memory before and need to be reloaded after. This prevents the compiler from reordering loads, stores, and arithmetic operations across it, but does not prevent the processor from reordering them.</para>

<para><formalpara><title>Note: </title>

<para>POWER process have an aggressively <emphasis>Speculative Superscalar</emphasis> design with out-of-order issue and execution.</para>
</formalpara>
Neither of the above are what we want for this case. We specifically want to avoid memory side effects in this computation. We only need the minimal compiler fence (like <emphasis role="bold">asm (&quot;;&quot; :::)</emphasis>) that prevents the compiler from reordering any code across it but does not prevent the processor from reordering them.</para>

<para>By placing this compiler fence between multiply/sum stages of <link linkend="vec__int512__ppc_8h_1ad10d62fe43f329c396b6486402f4f7af">vec_mul512x128_inline()</link>, <link linkend="vec__int512__ppc_8h_1a6f917597902625a8218ba41fc6dca426">vec_mul512x512_inline()</link> and <link linkend="vec__int512__ppc_8h_1a8287aa4483acb25ac3188a97cc23b89a">vec_mul2048x2048()</link> we limit instruction scheduling and code motion to smaller code blocks. This in turn reduces register pressure to the point where all 64 VSRs are in use, but no spilling to stack memory is required.</para>
</section>
<section xml:id="vec__int512__ppc_8h_1i512_security_issues_0_0_3">
<title>So what does this all mean?</title>

<para>The 2048x2048 multiplicands and the resulting product are so large (8192-bits, 64 quadwords total) that at the outer most function the inputs and the result must be in memory and passed by reference. The implementation of a 2048x2048-bit multiply requires 256 128x128-bit multiplies. Otherwise the code can be organized into sub-functions generating intermediate partial products and sums.</para>

<para>Coding 256 128x128 products and generating column sums would be tedious. One approach builds up products into larger and larger blocks in stages. For example code a <link linkend="vec__int512__ppc_8h_1ad10d62fe43f329c396b6486402f4f7af">vec_mul512x128_inline()</link> operation then use that in the implementation of <link linkend="vec__int512__ppc_8h_1a6f917597902625a8218ba41fc6dca426">vec_mul512x512_inline()</link>. We also provide 512-bit add/carry/extend operations to simplify generating sums of 512-bit partial products. Then load blocks of 512-bits (4 quadwords, 64-bytes) using <link linkend="vec__int512__ppc_8h_1a6f917597902625a8218ba41fc6dca426">vec_mul512x512_inline()</link> to produce a 1024-bit partial product (<link linkend="vec__int512__ppc_8h_1i512_security_issues_0_0_0_0">Implications for parameter passing and Product size</link>).</para>

<para>Then multiply the 512-bit blocks across one 2048-bit (4 x 512-bit) multiplicand. The completion of a 2048x512-bit partial product (of 2560-bits) includes the low order 512-bits ready to store to the output operand. Repeat for each 512-bit block of the other 2048-bit multiplicand summing across the 512-bit columns. The final sum, after the final 2048x512 partial product, produces the high order 2048-bits of the 2048x2048 product ready to store to the output operand.</para>

<para><formalpara><title>Note: </title>

<para>Security aware implementations could use masking countermeasures associated with these load/store operations. The base PVECLIB implementation does not do this. The source is available in ./src/vec_int512_runtime.c.</para>
</formalpara>
It is best if the sub-functions code can be fully in-lined into the 2048x2048-bit multiply or the sub-functions are carefully written. In this case these sub-functions should be leaf-functions (does not call other functions) and can execute without spilling register state or requiring stored (by reference) parameters.</para>

<para>All levels of implementation should avoid conditional logic based on values of inputs or partial products (For example early exits for leading or trailing zero quadwords). Doing so may expose the multiply function to timing side-channel attacks. So the best case would be one large function implemented as straight-line code.</para>

<para>We will need all 64 VSX registers for operations and local variables. So the outer function will need to allocate a stack-frame and save all of the non-volatile floating point registers (allowing the use of vs14-vs31 for local vector variables) and vector registers (v20-v31 AKA vs51-vs63) on entry. This frees up (18+12=) 30 additional quadword registers for local vector variables within the outer multiply function.</para>

<para>These saved registers reflect the state of the calling (or higher) function and may not have any crypto sensitive content. These register save areas will not be updated with internal state from the 2048x2048-bit multiply operation itself.</para>

<para>The 128x128-bit vector multiply is implemented with Vector Multiply-Sum Unsigned Doubleword Modulo for Power9 and Vector Multiply Even/Odd Unsigned Word for Power8. The timing for vector integer multiply operations are fixed at 7 cycles latency for Power8/9. The sums of partial products are implemented with Vector Add Unsigned Quadword Modulo/write-Carry/Extended. The timing of integer add quadword operations are fixed at 4 cycles for Power8 and 3 cycles for Power9. The rest of the 128x128-bit multiply operation is a combination of Vector Doubleword Permute Immediate, Vector Shift Left Double by Octet Immediate, Vector Splats, and Vector Logical Or (used as a vector register move spanning the 64 VSRs). All of these have fixed timings of 2 or 3 cycles.</para>

<para>So the overall timing of the 2048x2048-bit multiply should be consistent independent of input values. The only measurable variations would be as the processor changes Simultaneous Multithreading (SMT) modes (controlled by the virtual machine and kernel). The SMT mode (1,2,4,8) controls each hardware thread&apos;s priority to issue instructions to the core and if the instruction stream is dual or single issue (from that thread&apos;s perspective).</para>

<para>But the better news is that with some extra function attributes (always_inline and flatten) the entire 2048x2048 multiply function can be flattened into a single function of straight line code (no internal function calls or conditional branches) running ~6.3K instructions. And no spill code was generated for local variables (no register spill within the function body).</para>
</section>
</section>
<section xml:id="vec__int512__ppc_8h_1i512_Endian_issues_0_0">
<title>Endian for Multi-quadword precision operations</title>

<para>As described in <link linkend="index_1mainpage_endian_issues_1_1">General Endian Issues</link> and <link linkend="vec__int128__ppc_8h_1i128_endian_issues_0_0">Endian problems with quadword implementations</link> supporting both big and little endian in a single implementation has its challenges. But I think we can leave the details of quadword operations to the <link linkend="vec__int128__ppc_8h">vec_int128_ppc.h</link> implementation. The decision needed for these implementations is how the quadwords of a multi-quadword integer are ordered in storage. For example given an array or structure of 16 quadwords representing a single 2048-bit binary number which quadword contains the low order bits and which the high order bits.</para>

<para>This is largely arbitrary and independent from the system endian. But we should be consistent within the API defined by this header and PVECLIB as a whole. Placing the low order bits in the first (lowest address in memory) quadword and the high order bits in last (highest address in memory) quadword would be consistent with little endian. While placing the high order bits in the first (lowest address in memory) quadword and the low order bits in last (highest address in memory) quadfword would be consistent with big endian. Either is valid internal to the implementation where the key issue is accessing the quadwords of the multiplicands is a convenient order to generate the partial products in an order that support efficient generation of column sums and carries.</para>

<para>It is best for the API if the order of quadwords in multi-quadword integers match the endian of the platform. This should be helpful where we want the use the PVECLIB implementations under existing APIs using arrays of smaller integer types.</para>

<para>So on powerpc64le systems the low order quadword is the first quadword. While on older powwerpc64 systems the high order quadword is the first quadword. For example we can represent a 512-bit integer with the following structure. <literallayout><computeroutput>&#32;typedef&#32;struct
{
#if&#32;__BYTE_ORDER__&#32;==&#32;__ORDER_LITTLE_ENDIAN__
&#32;&#32;vui128_t&#32;vx0;
&#32;&#32;vui128_t&#32;vx1;
&#32;&#32;vui128_t&#32;vx2;
&#32;&#32;vui128_t&#32;vx3;
#else
&#32;&#32;vui128_t&#32;vx3;
&#32;&#32;vui128_t&#32;vx2;
&#32;&#32;vui128_t&#32;vx1;
&#32;&#32;vui128_t&#32;vx0;
#endif
}&#32;__VEC_U_512;
</computeroutput></literallayout> In this example the field <emphasis>vx0</emphasis> is always the low order quadword and <emphasis>vx3</emphasis> is always the high order quadword, independent of endian. We repeat this pattern for the range of multi-quadword integer sizes (from <link linkend="struct____VEC__U__256">__VEC_U_256</link> to <link linkend="struct____VEC__U__4096">__VEC_U_4096</link>) supported by this header. In each case the field name <emphasis>vx0</emphasis> is consistently the low order quadword. The field name suffix numbering continues from low to high with the highest numbered field name being the high order quadword.</para>
<section xml:id="vec__int512__ppc_8h_1i512_Endian_issues_0_0_1">
<title>Multi-quadword Integer Constants</title>

<para>As we have seen, initializing larger multiple precision constants an be challenging (<link linkend="vec__int128__ppc_8h_1int128_const_0_0_1">Quadword Integer Constants</link>). The good news we can continue to to use aggregate initializers for structures and arrays of vector quadwords. For example:</para>

<para><literallayout><computeroutput>const&#32;__VEC_U_512&#32;vec512_one&#32;=
&#32;&#32;&#32;&#32;{
&#32;&#32;&#32;&#32;&#32;&#32;(vui128_t)&#32;((unsigned&#32;__int128)&#32;0x00000000),
&#32;&#32;&#32;&#32;&#32;&#32;(vui128_t)&#32;((unsigned&#32;__int128)&#32;0x00000000),
&#32;&#32;&#32;&#32;&#32;&#32;(vui128_t)&#32;((unsigned&#32;__int128)&#32;0x00000000),
&#32;&#32;&#32;&#32;&#32;&#32;(vui128_t)&#32;((unsigned&#32;__int128)&#32;0x00000001)
&#32;&#32;&#32;&#32;};
</computeroutput></literallayout> This example is in the expected high to low order for the 512-bit constant 1. Unfortunately endian raises it ugly head again and this would a different value on little endian platform.</para>

<para>So PVECLIB provides another helper macro (<link linkend="vec__int512__ppc_8h_1aac9d31829610c29b0f5558bfb1f18e4a">CONST_VINT512_Q()</link>) to provide a consistent numbericial order for multiple quadword constants. For example: <literallayout><computeroutput>const&#32;__VEC_U_512&#32;vec512_one&#32;=&#32;CONST_VINT512_Q
&#32;&#32;&#32;&#32;(
&#32;&#32;&#32;&#32;&#32;&#32;(vui128_t)&#32;((unsigned&#32;__int128)&#32;0x00000000),
&#32;&#32;&#32;&#32;&#32;&#32;(vui128_t)&#32;((unsigned&#32;__int128)&#32;0x00000000),
&#32;&#32;&#32;&#32;&#32;&#32;(vui128_t)&#32;((unsigned&#32;__int128)&#32;0x00000000),
&#32;&#32;&#32;&#32;&#32;&#32;(vui128_t)&#32;((unsigned&#32;__int128)&#32;0x00000001)
&#32;&#32;&#32;&#32;);
</computeroutput></literallayout> and <literallayout><computeroutput>//&#32;const&#32;for&#32;10**128
const&#32;__VEC_U_512&#32;&#32;vec512_ten128th&#32;=&#32;CONST_VINT512_Q
&#32;&#32;&#32;&#32;(
&#32;&#32;&#32;&#32;&#32;&#32;CONST_VUINT128_QxW&#32;(0x00000000,&#32;0x00000000,&#32;0x0000024e,&#32;0xe91f2603),
&#32;&#32;&#32;&#32;&#32;&#32;CONST_VUINT128_QxW&#32;(0xa6337f19,&#32;0xbccdb0da,&#32;0xc404dc08,&#32;0xd3cff5ec),
&#32;&#32;&#32;&#32;&#32;&#32;CONST_VUINT128_QxW&#32;(0x2374e42f,&#32;0x0f1538fd,&#32;0x03df9909,&#32;0x2e953e01),
&#32;&#32;&#32;&#32;&#32;&#32;CONST_VUINT128_QxW&#32;(0x00000000,&#32;0x00000000,&#32;0x00000000,&#32;0x00000000)
&#32;&#32;&#32;&#32;);
</computeroutput></literallayout> Unfortunately the compiler can not help with multi-quadword decimal constants. So we must resort to external tools like <emphasis role="bold">bc</emphasis> to compute large constant values and convert them to hexadecimal which are easier to break into words and doubleword. These can then be used a constants in program source to represent arbitrarily large binary values.</para>
</section>
</section>
<section xml:id="vec__int512__ppc_8h_1i512_libary_issues_0_0">
<title>Building libraries for vec_int512_ppc</title>

<para><formalpara><title>See also: </title>

<para><link linkend="index_1main_libary_issues_0_0">Putting the Library into PVECLIB</link></para>
</formalpara>
Many of the implementations associated with 512-bit integer operations are uncomfortably large to expand as in-line code (Examples include <link linkend="vec__int512__ppc_8h_1a56a5da10870d9878e2ab888d3c4d2e7b">vec_mul512x512()</link>, <link linkend="vec__int512__ppc_8h_1ad4ade47617ecf223a2f7b0325e1fc877">vec_mul1024x1024()</link>, and <link linkend="vec__int512__ppc_8h_1a8287aa4483acb25ac3188a97cc23b89a">vec_mul2048x2048()</link>). It is better to collect these large implementations in separately compiled run-time libraries. Another consideration is that most of these operations are multiple quadword multiplies and the optimum quadword multiply is processor (and PowerISA version) dependent. This is especially true for Vector integer multiplies across POWER7-POWER9.</para>

<para>This places requirements on the structure of runtime implementation codes and the library build process.<itemizedlist>
<listitem>
<para>Building a set of source implementations for multiple compile (-mcpu=) targets.</para>
</listitem><listitem>
<para>Providing unique function names based on the operation and the compile target.</para>
</listitem><listitem>
<para>Providing static (archive) and dynamic (DSO) libraries, while adjusting the the compile options appropriately for each.<itemizedlist>
<listitem>
<para>Objects compiled for inclusion in dynamic libraries should be position independent code (i.e. compiled with -fpic or -fPIC).</para>
</listitem><listitem>
<para>DSOs supporting operations optimized for multiple compile (-mcpu=) targets need to export matching <link xlink:href="https://sourceware.org/glibc/wiki/GNU_IFUNC">IFUNC</link> symbols and resolver stubs.</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>

<para>For the first requirement we can collect the runtime implementations for vec_int512_ppc in to a single source file (vec_int512_runtime.c). The build system can then collect this and other runtime source files to compile for different targets. This can be as simple as: <literallayout><computeroutput>//&#32;&#32;\file&#32;&#32;vec_runtime_PWR9.c
#include&#32;&quot;vec_int512_runtime.c&quot;
...
</computeroutput></literallayout> and similarly for vec_runtime_PWR7.c and vec_runtime_PWR8.c.</para>

<para>As the implementation of vec_int512_ppc.c is already leveraging _ARCH_PWR7/8/9 tuned static inline operations from <link linkend="vec__int512__ppc_8h">vec_int512_ppc.h</link>, <link linkend="vec__int128__ppc_8h">vec_int128_ppc.h</link>, etc, all we need to do is apply the appropriate -mcpu=power7/8/9 compile option to each (target qualified) runtime source file.</para>

<para>The second requirement is addressed by applying a target qualifying suffix to each runtime function implementation. Here we use the <link linkend="vec__int512__ppc_8h_1a77eca5d7bebe0f30894fe9669c01b7a7">__VEC_PWR_IMP()</link> as function name wrapper macro. <literallayout><computeroutput>#ifdef&#32;_ARCH_PWR9
#define&#32;__VEC_PWR_IMP(FNAME)&#32;FNAME&#32;##&#32;_PWR9
#else
#ifdef&#32;_ARCH_PWR8
#define&#32;__VEC_PWR_IMP(FNAME)&#32;FNAME&#32;##&#32;_PWR8
#else
#define&#32;__VEC_PWR_IMP(FNAME)&#32;FNAME&#32;##&#32;_PWR7
#endif
#endif
</computeroutput></literallayout> We need to apply the name wrapper to both the functions extern (in <link linkend="vec__int512__ppc_8h">vec_int512_ppc.h</link>) and the function implementation (in vec_int512_runtime.c). For example: <literallayout><computeroutput>//&#32;&#32;\file&#32;&#32;vec_int512_ppc.h
&#32;...
extern&#32;__VEC_U_256
__VEC_PWR_IMP&#32;(vec_mul128x128)&#32;(vui128_t&#32;m1l,&#32;vui128_t&#32;m2l);
&#32;...
</computeroutput></literallayout> <formalpara><title>Note: </title>

<para>Doxygen does not tolerate attributes or macros in function prototypes. So these externs are guarded by a @cond INTERNAL ... @endcond&quot; block. The \brief and @param descriptions are provided for the unqualified dynamic function symbol and apply to the corresponding qualified function symbols.</para>
</formalpara>
<literallayout><computeroutput>//&#32;&#32;\file&#32;&#32;vec_int512_runtime.c
#include&#32;&lt;altivec.h&gt;
#include&#32;&lt;pveclib/vec_int128_ppc.h&gt;
#include&#32;&lt;pveclib/vec_int512_ppc.h&gt;
&#32;...
//&#32;vec_mul128x128_inline&#32;is&#32;defined&#32;in&#32;vec_int512_ppc.h
__VEC_U_256
__VEC_PWR_IMP&#32;(vec_mul128x128)&#32;(vui128_t&#32;m1l,&#32;vui128_t&#32;m2l)
{
&#32;&#32;return&#32;vec_mul128x128_inline&#32;(m1l,&#32;m2l);
}
</computeroutput></literallayout> This ensures that target specific runtime implementations have unique function symbols. This is important to avoid linker errors (due to duplicate symbol names).</para>

<para><formalpara><title>Note: </title>

<para>Each runtime operation will have 2 or 3 target qualified implementations. This is times 2 with separate builds for static archives and dynamic (DSO) libraries. The big endian powerpc64 platform supports 3 VSX enabled targets -mcpu=[power7|power8|power9]. The little endian powerpc64le platform currently supports 2 VSX enabled targets -mcpu=[power8|power9]. POWER7 is not supported for powerpc64le and the vec_runtime_PWR7.c source files are conditionally nulled out for powerpc64le targets. As new POWER processors are released, additional targets will be added.</para>
</formalpara>
</para>
<section xml:id="vec__int512__ppc_8h_1i512_libary_issues_0_0_1_1">
<title>Static linkage to platform specific functions</title>

<para>For static linkage the application is compiled for a specific platform target (via -mcpu=). So function calls should be bound to the matching platform specific implementations. The application may select the platform specific function directly by defining a <emphasis>extern</emphasis> and invoking the platform qualified function.</para>

<para>For applications binding to PVECLIB via static archives it is convenient to apply the <link linkend="vec__int512__ppc_8h_1a77eca5d7bebe0f30894fe9669c01b7a7">__VEC_PWR_IMP()</link> wrapper to the function call: <literallayout><computeroutput>k&#32;=&#32;__VEC_PWR_IMP&#32;(vec_mul128x128)(i,&#32;j);
</computeroutput></literallayout> The function call symbol picks up the target suffix based on the compile target (-mcpu=) for the application (see <link linkend="index_1main_libary_issues_0_0_1_1">Static linkage to platform specific functions</link>). The linker will extract the matching implementations from the PVECLIB archive and (statically) bind them with the application. This simplifies binding the application to the matching target specific implementations.</para>
</section>
<section xml:id="vec__int512__ppc_8h_1i512_libary_issues_0_0_1_2">
<title>Dynamic linkage to platform specific functions</title>

<para>For applications binding to dynamic libraries, the target qualified naming strategy also simplifies the implementation of IFUNC resolvers for the DSO library (see <link linkend="index_1main_libary_issues_0_0_2">Building dynamic runtime libraries</link>). Here the target qualified names of the PIC implementations are known to the corresponding resolver function but are not exported from the DSO. Allowing the application to bind to the target qualified names would defeat the automatic selection of target optimized implementations.</para>

<para>Applications using dynamic linkage will call the unqualified function symbol. For example: <literallayout><computeroutput>//&#32;&#32;\file&#32;&#32;vec_int512_ppc.h
&#32;...
extern&#32;__VEC_U_256
vec_mul128x128&#32;(vui128_t,&#32;vui128_t);
</computeroutput></literallayout></para>

<para>This symbol&apos;s implementation has a special <emphasis role="bold">STT_GNU_IFUNC</emphasis> attribute recognized by the dynamic linker. This attribute associates this symbol with the corresponding runtime resolver function. So in addition to any platform specific implementations we need to provide the resolver function referenced by the <emphasis>IFUNC</emphasis> symbol. For example: <literallayout><computeroutput>//&#32;&#32;\file&#32;&#32;vec_runtime_DYN.c
&#32;...
extern&#32;__VEC_U_256
vec_mul128x128_PWR7&#32;(vui128_t,&#32;vui128_t);

extern&#32;__VEC_U_256
vec_mul128x128_PWR8&#32;(vui128_t,&#32;vui128_t);

extern&#32;__VEC_U_256
vec_mul128x128_PWR9&#32;(vui128_t,&#32;vui128_t);

static&#32;__VEC_U_256
(*resolve_vec_mul128x128&#32;(void))(vui128_t,&#32;vui128_t)
{
#ifdef&#32;&#32;__BUILTIN_CPU_SUPPORTS__
&#32;&#32;if&#32;(__builtin_cpu_is&#32;(&quot;power9&quot;))
&#32;&#32;&#32;&#32;return&#32;vec_mul128x128_PWR9;
&#32;&#32;else
&#32;&#32;&#32;&#32;{
&#32;&#32;&#32;&#32;&#32;&#32;if&#32;(__builtin_cpu_is&#32;(&quot;power8&quot;))
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;vec_mul128x128_PWR8;
&#32;&#32;&#32;&#32;&#32;&#32;else
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;vec_mul128x128_PWR7;
&#32;&#32;&#32;&#32;}
#else&#32;//&#32;!&#32;__BUILTIN_CPU_SUPPORTS__
&#32;&#32;&#32;&#32;return&#32;vec_mul128x128_PWR7;
#endif
}

__VEC_U_256
vec_mul128x128&#32;(vui128_t,&#32;vui128_t)
__attribute__&#32;((ifunc&#32;(&quot;resolve_vec_mul128x128&quot;)));
</computeroutput></literallayout></para>

<para>On the program&apos;s first call to a <emphasis>IFUNC</emphasis> symbol, the dynamic linker calls the resolver function associated with that symbol. The resolver function performs a runtime check to determine the platform, selects the (closest) matching platform specific function, then returns that functions address to the dynamic linker.</para>

<para>The dynamic linker stores this function address in the callers Procedure Linkage Tables (PLT) before forwarding the call to the resolved implementation. Any subsequent calls to this function symbol branch (via the PLT) directly to appropriate platform specific implementation.</para>

<para><formalpara><title>Note: </title>

<para>The operation <link linkend="vec__int512__ppc_8h_1ab5b80fd9694cea8bf502b26e55af37f7">vec_mul128x128()</link> has multiple implementations and names. It has a static inline implementation <link linkend="vec__int512__ppc_8h_1a958e029fc824ec3a73ad9550bf7ea506">vec_mul128x128_inline()</link>. This uses the static inline <link linkend="vec__int128__ppc_8h_1aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq()</link> from _vec_int128_ppc.h but returns the 256-bit result as a single struct <link linkend="struct____VEC__U__256">__VEC_U_256</link>. It has a number (currently 2 or 3) of target qualified extern declarations and static implementations for static linkage. And it has a unqualified extern declaration and IFUNC attributed symbol associated with its resolver for dynamic linkage.</para>
</formalpara>
<para><link linkend="todo_1_todo000002">Todo</link> 
<para>Currently the dynamic resolvers and <emphasis>IFUNC</emphasis> symbols for vec_int512_runtime.c are contained within vec_runtime_DYN.c. As the list of runtime operations expands to other element sizes/types, vec_runtime_DYN.c should be refactored into multiple files.</para>
</para></para>
</section>
</section>
    <para>Definition in file /home/sjmunroe/work/pveclib_PDF/src/pveclib/vec_int512_ppc.h</para>
    </simplesect>
</section>
