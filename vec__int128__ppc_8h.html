<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>POWER Vector Library Manual: src/vec_int128_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_int128_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX and VSX instructions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__common__ppc_8h_source.html">vec_common_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__int64__ppc_8h_source.html">vec_int64_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__int128__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abf1707d712cc191915a8f558eaaa1fe7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#abf1707d712cc191915a8f558eaaa1fe7">vec_absduq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:abf1707d712cc191915a8f558eaaa1fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Absolute Difference Unsigned Quadword.  <a href="#abf1707d712cc191915a8f558eaaa1fe7">More...</a><br /></td></tr>
<tr class="separator:abf1707d712cc191915a8f558eaaa1fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655de600915e449a8681572961939422"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a655de600915e449a8681572961939422">vec_avguq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a655de600915e449a8681572961939422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Average Unsigned Quadword.  <a href="#a655de600915e449a8681572961939422">More...</a><br /></td></tr>
<tr class="separator:a655de600915e449a8681572961939422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aaadba249ce46c4c94f78df1020da3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> b)</td></tr>
<tr class="memdesc:ad7aaadba249ce46c4c94f78df1020da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Add &amp; write Carry Unsigned Quadword.  <a href="#ad7aaadba249ce46c4c94f78df1020da3">More...</a><br /></td></tr>
<tr class="separator:ad7aaadba249ce46c4c94f78df1020da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18b98d2d73f1afbc439e1407c78f305"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#af18b98d2d73f1afbc439e1407c78f305">vec_addecuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> ci)</td></tr>
<tr class="memdesc:af18b98d2d73f1afbc439e1407c78f305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Add Extended &amp; write Carry Unsigned Quadword.  <a href="#af18b98d2d73f1afbc439e1407c78f305">More...</a><br /></td></tr>
<tr class="separator:af18b98d2d73f1afbc439e1407c78f305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e63f70b182d60fe03b43a80647451a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a44e63f70b182d60fe03b43a80647451a">vec_addeuqm</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> ci)</td></tr>
<tr class="memdesc:a44e63f70b182d60fe03b43a80647451a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Add Extended Unsigned Quadword Modulo.  <a href="#a44e63f70b182d60fe03b43a80647451a">More...</a><br /></td></tr>
<tr class="separator:a44e63f70b182d60fe03b43a80647451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539de2a4426a84102471306acc571ce8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> b)</td></tr>
<tr class="memdesc:a539de2a4426a84102471306acc571ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Add Unsigned Quadword Modulo.  <a href="#a539de2a4426a84102471306acc571ce8">More...</a><br /></td></tr>
<tr class="separator:a539de2a4426a84102471306acc571ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363fa7103ccd730c47bb34cb9f05e80b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a363fa7103ccd730c47bb34cb9f05e80b">vec_addcq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *cout, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> b)</td></tr>
<tr class="memdesc:a363fa7103ccd730c47bb34cb9f05e80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Add with carry Unsigned Quadword.  <a href="#a363fa7103ccd730c47bb34cb9f05e80b">More...</a><br /></td></tr>
<tr class="separator:a363fa7103ccd730c47bb34cb9f05e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e27910c148d525e17d099688aec9ba1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a9e27910c148d525e17d099688aec9ba1">vec_addeq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *cout, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> ci)</td></tr>
<tr class="memdesc:a9e27910c148d525e17d099688aec9ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Add Extend with carry Unsigned Quadword.  <a href="#a9e27910c148d525e17d099688aec9ba1">More...</a><br /></td></tr>
<tr class="separator:a9e27910c148d525e17d099688aec9ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066cc120c198773a2f8dfd17480b7a49"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a066cc120c198773a2f8dfd17480b7a49">vec_clzq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra)</td></tr>
<tr class="memdesc:a066cc120c198773a2f8dfd17480b7a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Count Leading Zeros Quadword.  <a href="#a066cc120c198773a2f8dfd17480b7a49">More...</a><br /></td></tr>
<tr class="separator:a066cc120c198773a2f8dfd17480b7a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf308aff6d9e25ae55b2c9d998c5de68"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#adf308aff6d9e25ae55b2c9d998c5de68">vec_cmpeqsq</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:adf308aff6d9e25ae55b2c9d998c5de68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal Signed Quadword.  <a href="#adf308aff6d9e25ae55b2c9d998c5de68">More...</a><br /></td></tr>
<tr class="separator:adf308aff6d9e25ae55b2c9d998c5de68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7197cd5c6e946211f2718b5e8464cdc0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0">vec_cmpequq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a7197cd5c6e946211f2718b5e8464cdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal Unsigned Quadword.  <a href="#a7197cd5c6e946211f2718b5e8464cdc0">More...</a><br /></td></tr>
<tr class="separator:a7197cd5c6e946211f2718b5e8464cdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e92209124903c3e8c535263246ff37"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ac7e92209124903c3e8c535263246ff37">vec_cmpgesq</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:ac7e92209124903c3e8c535263246ff37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than or Equal Signed Quadword.  <a href="#ac7e92209124903c3e8c535263246ff37">More...</a><br /></td></tr>
<tr class="separator:ac7e92209124903c3e8c535263246ff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd88782f327214c07d42519b7d4c69ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#abd88782f327214c07d42519b7d4c69ce">vec_cmpgeuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:abd88782f327214c07d42519b7d4c69ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than or Equal Unsigned Quadword.  <a href="#abd88782f327214c07d42519b7d4c69ce">More...</a><br /></td></tr>
<tr class="separator:abd88782f327214c07d42519b7d4c69ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ce55b0cba15cddb6764a900922d768"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a45ce55b0cba15cddb6764a900922d768">vec_cmpgtsq</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:a45ce55b0cba15cddb6764a900922d768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than Signed Quadword.  <a href="#a45ce55b0cba15cddb6764a900922d768">More...</a><br /></td></tr>
<tr class="separator:a45ce55b0cba15cddb6764a900922d768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ce43dcbc14fb34623d5ece8073b86e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ad4ce43dcbc14fb34623d5ece8073b86e">vec_cmpgtuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:ad4ce43dcbc14fb34623d5ece8073b86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than Unsigned Quadword.  <a href="#ad4ce43dcbc14fb34623d5ece8073b86e">More...</a><br /></td></tr>
<tr class="separator:ad4ce43dcbc14fb34623d5ece8073b86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3642b1e0d48117c91189f69dd0e955ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a3642b1e0d48117c91189f69dd0e955ad">vec_cmplesq</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:a3642b1e0d48117c91189f69dd0e955ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than or Equal Signed Quadword.  <a href="#a3642b1e0d48117c91189f69dd0e955ad">More...</a><br /></td></tr>
<tr class="separator:a3642b1e0d48117c91189f69dd0e955ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b25e7f46986d00997fedaeeb7871c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a69b25e7f46986d00997fedaeeb7871c2">vec_cmpleuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a69b25e7f46986d00997fedaeeb7871c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than or Equal Unsigned Quadword.  <a href="#a69b25e7f46986d00997fedaeeb7871c2">More...</a><br /></td></tr>
<tr class="separator:a69b25e7f46986d00997fedaeeb7871c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d83d78ff2330205a8d74741b34a1be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a82d83d78ff2330205a8d74741b34a1be">vec_cmpltsq</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:a82d83d78ff2330205a8d74741b34a1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than Signed Quadword.  <a href="#a82d83d78ff2330205a8d74741b34a1be">More...</a><br /></td></tr>
<tr class="separator:a82d83d78ff2330205a8d74741b34a1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9ebc5ad32b151a3e08136d51aad4dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a7f9ebc5ad32b151a3e08136d51aad4dc">vec_cmpltuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a7f9ebc5ad32b151a3e08136d51aad4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than Unsigned Quadword.  <a href="#a7f9ebc5ad32b151a3e08136d51aad4dc">More...</a><br /></td></tr>
<tr class="separator:a7f9ebc5ad32b151a3e08136d51aad4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cdf052bf633951201589454e50f52e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ae2cdf052bf633951201589454e50f52e">vec_cmpnesq</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:ae2cdf052bf633951201589454e50f52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal Signed Quadword.  <a href="#ae2cdf052bf633951201589454e50f52e">More...</a><br /></td></tr>
<tr class="separator:ae2cdf052bf633951201589454e50f52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186d0b94bbc652e700ab4e1733b9524c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a186d0b94bbc652e700ab4e1733b9524c">vec_cmpneuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a186d0b94bbc652e700ab4e1733b9524c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Not Equal Unsigned Quadword.  <a href="#a186d0b94bbc652e700ab4e1733b9524c">More...</a><br /></td></tr>
<tr class="separator:a186d0b94bbc652e700ab4e1733b9524c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391cc9e4b1221618840767c7487d3032"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a391cc9e4b1221618840767c7487d3032">vec_cmpsq_all_eq</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:a391cc9e4b1221618840767c7487d3032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Equal Signed Quadword.  <a href="#a391cc9e4b1221618840767c7487d3032">More...</a><br /></td></tr>
<tr class="separator:a391cc9e4b1221618840767c7487d3032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269401b65405524bb2d971bef595cb0d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a269401b65405524bb2d971bef595cb0d">vec_cmpsq_all_ge</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:a269401b65405524bb2d971bef595cb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Greater Than or Equal Signed Quadword.  <a href="#a269401b65405524bb2d971bef595cb0d">More...</a><br /></td></tr>
<tr class="separator:a269401b65405524bb2d971bef595cb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a38e9016e2d94a56f935ddded3830b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a62a38e9016e2d94a56f935ddded3830b">vec_cmpsq_all_gt</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:a62a38e9016e2d94a56f935ddded3830b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Greater Than Signed Quadword.  <a href="#a62a38e9016e2d94a56f935ddded3830b">More...</a><br /></td></tr>
<tr class="separator:a62a38e9016e2d94a56f935ddded3830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88209b466e628a6a77c6ddab7a15b4c8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a88209b466e628a6a77c6ddab7a15b4c8">vec_cmpsq_all_le</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:a88209b466e628a6a77c6ddab7a15b4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Less Than or Equal Signed Quadword.  <a href="#a88209b466e628a6a77c6ddab7a15b4c8">More...</a><br /></td></tr>
<tr class="separator:a88209b466e628a6a77c6ddab7a15b4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395dad1916a94a6cdb2b601565d7ffce"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a395dad1916a94a6cdb2b601565d7ffce">vec_cmpsq_all_lt</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:a395dad1916a94a6cdb2b601565d7ffce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Less Than Signed Quadword.  <a href="#a395dad1916a94a6cdb2b601565d7ffce">More...</a><br /></td></tr>
<tr class="separator:a395dad1916a94a6cdb2b601565d7ffce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7587275a406a1e2437ef86c23e2875a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#af7587275a406a1e2437ef86c23e2875a">vec_cmpsq_all_ne</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:af7587275a406a1e2437ef86c23e2875a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Not Equal Signed Quadword.  <a href="#af7587275a406a1e2437ef86c23e2875a">More...</a><br /></td></tr>
<tr class="separator:af7587275a406a1e2437ef86c23e2875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2c01f3aa165fedba47600f87067768"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a2c2c01f3aa165fedba47600f87067768">vec_cmpuq_all_eq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a2c2c01f3aa165fedba47600f87067768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Equal Unsigned Quadword.  <a href="#a2c2c01f3aa165fedba47600f87067768">More...</a><br /></td></tr>
<tr class="separator:a2c2c01f3aa165fedba47600f87067768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f06b2c3d612a7cfdeb3bb883c59e19"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#af8f06b2c3d612a7cfdeb3bb883c59e19">vec_cmpuq_all_ge</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:af8f06b2c3d612a7cfdeb3bb883c59e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Greater Than or Equal Unsigned Quadword.  <a href="#af8f06b2c3d612a7cfdeb3bb883c59e19">More...</a><br /></td></tr>
<tr class="separator:af8f06b2c3d612a7cfdeb3bb883c59e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93dc5ed8bb3501470cf70c5cb5796a9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ac93dc5ed8bb3501470cf70c5cb5796a9">vec_cmpuq_all_gt</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:ac93dc5ed8bb3501470cf70c5cb5796a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Greater Than Unsigned Quadword.  <a href="#ac93dc5ed8bb3501470cf70c5cb5796a9">More...</a><br /></td></tr>
<tr class="separator:ac93dc5ed8bb3501470cf70c5cb5796a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7f505ebca731aa6fdc7433f82c0c6d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a2b7f505ebca731aa6fdc7433f82c0c6d">vec_cmpuq_all_le</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a2b7f505ebca731aa6fdc7433f82c0c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Less Than or Equal Unsigned Quadword.  <a href="#a2b7f505ebca731aa6fdc7433f82c0c6d">More...</a><br /></td></tr>
<tr class="separator:a2b7f505ebca731aa6fdc7433f82c0c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ddb6149475e80f4a1d38277317d980"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a31ddb6149475e80f4a1d38277317d980">vec_cmpuq_all_lt</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a31ddb6149475e80f4a1d38277317d980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Less Than Unsigned Quadword.  <a href="#a31ddb6149475e80f4a1d38277317d980">More...</a><br /></td></tr>
<tr class="separator:a31ddb6149475e80f4a1d38277317d980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1799f860ba79e698c66b171392afde01"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a1799f860ba79e698c66b171392afde01">vec_cmpuq_all_ne</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a1799f860ba79e698c66b171392afde01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Not Equal Unsigned Quadword.  <a href="#a1799f860ba79e698c66b171392afde01">More...</a><br /></td></tr>
<tr class="separator:a1799f860ba79e698c66b171392afde01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f250dfab2a4aee0fd247a1d0217237b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a5f250dfab2a4aee0fd247a1d0217237b">vec_cmul10ecuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *cout, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> cin)</td></tr>
<tr class="memdesc:a5f250dfab2a4aee0fd247a1d0217237b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector combined Multiply by 10 Extended &amp; write Carry Unsigned Quadword.  <a href="#a5f250dfab2a4aee0fd247a1d0217237b">More...</a><br /></td></tr>
<tr class="separator:a5f250dfab2a4aee0fd247a1d0217237b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9449c746cad42f0cd9e2fe4560364e18"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a9449c746cad42f0cd9e2fe4560364e18">vec_cmul10cuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *cout, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a)</td></tr>
<tr class="memdesc:a9449c746cad42f0cd9e2fe4560364e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector combined Multiply by 10 &amp; write Carry Unsigned Quadword.  <a href="#a9449c746cad42f0cd9e2fe4560364e18">More...</a><br /></td></tr>
<tr class="separator:a9449c746cad42f0cd9e2fe4560364e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320909aca43d55b8be1069f38544ee8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ae320909aca43d55b8be1069f38544ee8">vec_divsq_10e31</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra)</td></tr>
<tr class="memdesc:ae320909aca43d55b8be1069f38544ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Divide by const 10e31 Signed Quadword.  <a href="#ae320909aca43d55b8be1069f38544ee8">More...</a><br /></td></tr>
<tr class="separator:ae320909aca43d55b8be1069f38544ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2db6d665f837f96c746d88027e9e19"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#afa2db6d665f837f96c746d88027e9e19">vec_divudq_10e31</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *qh, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:afa2db6d665f837f96c746d88027e9e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Divide Unsigned Double Quadword by const 10e31.  <a href="#afa2db6d665f837f96c746d88027e9e19">More...</a><br /></td></tr>
<tr class="separator:afa2db6d665f837f96c746d88027e9e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917acd42e775f4bb323ba2104c52d7cb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a917acd42e775f4bb323ba2104c52d7cb">vec_divudq_10e32</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *qh, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a917acd42e775f4bb323ba2104c52d7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Divide Unsigned Double Quadword by const 10e32.  <a href="#a917acd42e775f4bb323ba2104c52d7cb">More...</a><br /></td></tr>
<tr class="separator:a917acd42e775f4bb323ba2104c52d7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6a39212f8a8b9ebf20e0117e1e1e88"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a9a6a39212f8a8b9ebf20e0117e1e1e88">vec_divuq_10e31</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra)</td></tr>
<tr class="memdesc:a9a6a39212f8a8b9ebf20e0117e1e1e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Divide by const 10e31 Unsigned Quadword.  <a href="#a9a6a39212f8a8b9ebf20e0117e1e1e88">More...</a><br /></td></tr>
<tr class="separator:a9a6a39212f8a8b9ebf20e0117e1e1e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b45341cc9cc918198bb69da0552098"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ae2b45341cc9cc918198bb69da0552098">vec_divuq_10e32</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra)</td></tr>
<tr class="memdesc:ae2b45341cc9cc918198bb69da0552098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Divide by const 10e32 Unsigned Quadword.  <a href="#ae2b45341cc9cc918198bb69da0552098">More...</a><br /></td></tr>
<tr class="separator:ae2b45341cc9cc918198bb69da0552098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef64f9ffe8af5a8f08b6bdd0a9e218f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#acef64f9ffe8af5a8f08b6bdd0a9e218f">vec_maxsq</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:acef64f9ffe8af5a8f08b6bdd0a9e218f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Maximum Signed Quadword.  <a href="#acef64f9ffe8af5a8f08b6bdd0a9e218f">More...</a><br /></td></tr>
<tr class="separator:acef64f9ffe8af5a8f08b6bdd0a9e218f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb02d0572ecc17eca0de6d4f0d9aa302"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#adb02d0572ecc17eca0de6d4f0d9aa302">vec_maxuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:adb02d0572ecc17eca0de6d4f0d9aa302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Maximum Unsigned Quadword.  <a href="#adb02d0572ecc17eca0de6d4f0d9aa302">More...</a><br /></td></tr>
<tr class="separator:adb02d0572ecc17eca0de6d4f0d9aa302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab435fd182688a615fb88b6578321839d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ab435fd182688a615fb88b6578321839d">vec_minsq</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vrb)</td></tr>
<tr class="memdesc:ab435fd182688a615fb88b6578321839d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Minimum Signed Quadword.  <a href="#ab435fd182688a615fb88b6578321839d">More...</a><br /></td></tr>
<tr class="separator:ab435fd182688a615fb88b6578321839d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fa6a9987d3bd9593d1780b1c28c390"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ad0fa6a9987d3bd9593d1780b1c28c390">vec_minuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:ad0fa6a9987d3bd9593d1780b1c28c390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Minimum Unsigned Quadword.  <a href="#ad0fa6a9987d3bd9593d1780b1c28c390">More...</a><br /></td></tr>
<tr class="separator:ad0fa6a9987d3bd9593d1780b1c28c390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5db88e4608d4a7408df9042adce86c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#aab5db88e4608d4a7408df9042adce86c">vec_modsq_10e31</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> q)</td></tr>
<tr class="memdesc:aab5db88e4608d4a7408df9042adce86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Modulo by const 10e31 Signed Quadword.  <a href="#aab5db88e4608d4a7408df9042adce86c">More...</a><br /></td></tr>
<tr class="separator:aab5db88e4608d4a7408df9042adce86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a893a75e42f5f6c4dfe793678fea59"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a31a893a75e42f5f6c4dfe793678fea59">vec_modudq_10e31</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *ql)</td></tr>
<tr class="memdesc:a31a893a75e42f5f6c4dfe793678fea59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Modulo Unsigned Double Quadword by const 10e31.  <a href="#a31a893a75e42f5f6c4dfe793678fea59">More...</a><br /></td></tr>
<tr class="separator:a31a893a75e42f5f6c4dfe793678fea59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccbd77900956c01a51b88e672e593c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a2ccbd77900956c01a51b88e672e593c6">vec_modudq_10e32</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *ql)</td></tr>
<tr class="memdesc:a2ccbd77900956c01a51b88e672e593c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Modulo Unsigned Double Quadword by const 10e32.  <a href="#a2ccbd77900956c01a51b88e672e593c6">More...</a><br /></td></tr>
<tr class="separator:a2ccbd77900956c01a51b88e672e593c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b3b91f7e80522d8a8c0c171e077b99"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#af4b3b91f7e80522d8a8c0c171e077b99">vec_moduq_10e31</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> q)</td></tr>
<tr class="memdesc:af4b3b91f7e80522d8a8c0c171e077b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Modulo by const 10e31 Unsigned Quadword.  <a href="#af4b3b91f7e80522d8a8c0c171e077b99">More...</a><br /></td></tr>
<tr class="separator:af4b3b91f7e80522d8a8c0c171e077b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4f1d8a707289d2271eafad4aeb1e82"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#aff4f1d8a707289d2271eafad4aeb1e82">vec_moduq_10e32</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> q)</td></tr>
<tr class="memdesc:aff4f1d8a707289d2271eafad4aeb1e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Modulo by const 10e32 Unsigned Quadword.  <a href="#aff4f1d8a707289d2271eafad4aeb1e82">More...</a><br /></td></tr>
<tr class="separator:aff4f1d8a707289d2271eafad4aeb1e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c641b0107fc3e1621ef729c04efd583"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a8c641b0107fc3e1621ef729c04efd583">vec_mul10cuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a)</td></tr>
<tr class="memdesc:a8c641b0107fc3e1621ef729c04efd583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply by 10 &amp; write Carry Unsigned Quadword.  <a href="#a8c641b0107fc3e1621ef729c04efd583">More...</a><br /></td></tr>
<tr class="separator:a8c641b0107fc3e1621ef729c04efd583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca2a6427ecb9458858b5caaac8c4dca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a7ca2a6427ecb9458858b5caaac8c4dca">vec_mul10ecuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> cin)</td></tr>
<tr class="memdesc:a7ca2a6427ecb9458858b5caaac8c4dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply by 10 Extended &amp; write Carry Unsigned Quadword.  <a href="#a7ca2a6427ecb9458858b5caaac8c4dca">More...</a><br /></td></tr>
<tr class="separator:a7ca2a6427ecb9458858b5caaac8c4dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2245626e7b90621b33ba79b763a4215e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a2245626e7b90621b33ba79b763a4215e">vec_mul10euq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> cin)</td></tr>
<tr class="memdesc:a2245626e7b90621b33ba79b763a4215e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply by 10 Extended Unsigned Quadword.  <a href="#a2245626e7b90621b33ba79b763a4215e">More...</a><br /></td></tr>
<tr class="separator:a2245626e7b90621b33ba79b763a4215e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3675fa1a2334eff913df447904be78ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a3675fa1a2334eff913df447904be78ad">vec_mul10uq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a)</td></tr>
<tr class="memdesc:a3675fa1a2334eff913df447904be78ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply by 10 Unsigned Quadword.  <a href="#a3675fa1a2334eff913df447904be78ad">More...</a><br /></td></tr>
<tr class="separator:a3675fa1a2334eff913df447904be78ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc23a0cd3f522c017ec95d5ce93a2f0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a8bc23a0cd3f522c017ec95d5ce93a2f0">vec_cmul100cuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *cout, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a)</td></tr>
<tr class="memdesc:a8bc23a0cd3f522c017ec95d5ce93a2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector combined Multiply by 100 &amp; write Carry Unsigned Quadword.  <a href="#a8bc23a0cd3f522c017ec95d5ce93a2f0">More...</a><br /></td></tr>
<tr class="separator:a8bc23a0cd3f522c017ec95d5ce93a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f85b6577e5ab0de2b3f68ca45dd33b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ac3f85b6577e5ab0de2b3f68ca45dd33b">vec_cmul100ecuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *cout, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> cin)</td></tr>
<tr class="memdesc:ac3f85b6577e5ab0de2b3f68ca45dd33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector combined Multiply by 100 Extended &amp; write Carry Unsigned Quadword.  <a href="#ac3f85b6577e5ab0de2b3f68ca45dd33b">More...</a><br /></td></tr>
<tr class="separator:ac3f85b6577e5ab0de2b3f68ca45dd33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d183ebd232e5826be109cdaa421aeed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed">vec_msumudm</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> c)</td></tr>
<tr class="memdesc:a1d183ebd232e5826be109cdaa421aeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Sum Unsigned Doubleword Modulo.  <a href="#a1d183ebd232e5826be109cdaa421aeed">More...</a><br /></td></tr>
<tr class="separator:a1d183ebd232e5826be109cdaa421aeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f95e02f7b0551e3f2bb7e4b4da040d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a26f95e02f7b0551e3f2bb7e4b4da040d">vec_muleud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a26f95e02f7b0551e3f2bb7e4b4da040d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Even Unsigned Doublewords.  <a href="#a26f95e02f7b0551e3f2bb7e4b4da040d">More...</a><br /></td></tr>
<tr class="separator:a26f95e02f7b0551e3f2bb7e4b4da040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10780cd8a88f18ec564ee6254c179a06"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06">vec_mulhud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a10780cd8a88f18ec564ee6254c179a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Unsigned Doubleword.  <a href="#a10780cd8a88f18ec564ee6254c179a06">More...</a><br /></td></tr>
<tr class="separator:a10780cd8a88f18ec564ee6254c179a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa989582cbfaa7984f78a937225e92f4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#aa989582cbfaa7984f78a937225e92f4a">vec_muloud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:aa989582cbfaa7984f78a937225e92f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Odd Unsigned Doublewords.  <a href="#aa989582cbfaa7984f78a937225e92f4a">More...</a><br /></td></tr>
<tr class="separator:aa989582cbfaa7984f78a937225e92f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f19a53d6d28ac9b2aab5b8e1c5b2cbb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb">vec_muludm</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a2f19a53d6d28ac9b2aab5b8e1c5b2cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Unsigned Doubleword Modulo.  <a href="#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb">More...</a><br /></td></tr>
<tr class="separator:a2f19a53d6d28ac9b2aab5b8e1c5b2cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6be9c8f02e43c39a659d6bbc9c3a2d2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2">vec_mulhuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> b)</td></tr>
<tr class="memdesc:ad6be9c8f02e43c39a659d6bbc9c3a2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Unsigned Quadword.  <a href="#ad6be9c8f02e43c39a659d6bbc9c3a2d2">More...</a><br /></td></tr>
<tr class="separator:ad6be9c8f02e43c39a659d6bbc9c3a2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaaf0e4c2705be1e0e8e925b09c52de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a9aaaf0e4c2705be1e0e8e925b09c52de">vec_mulluq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> b)</td></tr>
<tr class="memdesc:a9aaaf0e4c2705be1e0e8e925b09c52de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Low Unsigned Quadword.  <a href="#a9aaaf0e4c2705be1e0e8e925b09c52de">More...</a><br /></td></tr>
<tr class="separator:a9aaaf0e4c2705be1e0e8e925b09c52de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5c5b2998ef105b4c6f39739748ffa8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *mulu, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> b)</td></tr>
<tr class="memdesc:aee5c5b2998ef105b4c6f39739748ffa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Unsigned Double Quadword.  <a href="#aee5c5b2998ef105b4c6f39739748ffa8">More...</a><br /></td></tr>
<tr class="separator:aee5c5b2998ef105b4c6f39739748ffa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05185c980535dd28aec3a2a9431cb69"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ae05185c980535dd28aec3a2a9431cb69">vec_popcntq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra)</td></tr>
<tr class="memdesc:ae05185c980535dd28aec3a2a9431cb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Population Count Quadword.  <a href="#ae05185c980535dd28aec3a2a9431cb69">More...</a><br /></td></tr>
<tr class="separator:ae05185c980535dd28aec3a2a9431cb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40644aaa8146d00f84fce58dd4fd24e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#aa40644aaa8146d00f84fce58dd4fd24e">vec_revbq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra)</td></tr>
<tr class="memdesc:aa40644aaa8146d00f84fce58dd4fd24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Byte Reverse Quadword.  <a href="#aa40644aaa8146d00f84fce58dd4fd24e">More...</a><br /></td></tr>
<tr class="separator:aa40644aaa8146d00f84fce58dd4fd24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b3bfcc5b277628cd80ecd90440f8a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a52b3bfcc5b277628cd80ecd90440f8a5">vec_rlq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a52b3bfcc5b277628cd80ecd90440f8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Rotate Left Quadword.  <a href="#a52b3bfcc5b277628cd80ecd90440f8a5">More...</a><br /></td></tr>
<tr class="separator:a52b3bfcc5b277628cd80ecd90440f8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4777f3b762c3313df0a13aa352c2f189"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a4777f3b762c3313df0a13aa352c2f189">vec_rlqi</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a4777f3b762c3313df0a13aa352c2f189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Rotate Left Quadword Immediate.  <a href="#a4777f3b762c3313df0a13aa352c2f189">More...</a><br /></td></tr>
<tr class="separator:a4777f3b762c3313df0a13aa352c2f189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74036e39e72e0f3c29706d30fbb96d1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#af74036e39e72e0f3c29706d30fbb96d1">vec_setb_cyq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vcy)</td></tr>
<tr class="memdesc:af74036e39e72e0f3c29706d30fbb96d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Set Bool from Quadword Carry.  <a href="#af74036e39e72e0f3c29706d30fbb96d1">More...</a><br /></td></tr>
<tr class="separator:af74036e39e72e0f3c29706d30fbb96d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921647d5b67f0de5006ee32fb3d9c4f1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a921647d5b67f0de5006ee32fb3d9c4f1">vec_setb_ncq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vcy)</td></tr>
<tr class="memdesc:a921647d5b67f0de5006ee32fb3d9c4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Set Bool from Quadword not Carry.  <a href="#a921647d5b67f0de5006ee32fb3d9c4f1">More...</a><br /></td></tr>
<tr class="separator:a921647d5b67f0de5006ee32fb3d9c4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21d01bb19f0ea8605d8c37035837802"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#af21d01bb19f0ea8605d8c37035837802">vec_setb_sq</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra)</td></tr>
<tr class="memdesc:af21d01bb19f0ea8605d8c37035837802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Set Bool from Signed Quadword.  <a href="#af21d01bb19f0ea8605d8c37035837802">More...</a><br /></td></tr>
<tr class="separator:af21d01bb19f0ea8605d8c37035837802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba40be93339359793ef776e1d5d7577"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a8ba40be93339359793ef776e1d5d7577">vec_sldq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrw, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrx, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a8ba40be93339359793ef776e1d5d7577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Left Double Quadword.  <a href="#a8ba40be93339359793ef776e1d5d7577">More...</a><br /></td></tr>
<tr class="separator:a8ba40be93339359793ef776e1d5d7577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa33904ec4de42f54cceab34adb303c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrw, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrx, const unsigned int shb)</td></tr>
<tr class="memdesc:aaa33904ec4de42f54cceab34adb303c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Left Double Quadword Immediate.  <a href="#aaa33904ec4de42f54cceab34adb303c5">More...</a><br /></td></tr>
<tr class="separator:aaa33904ec4de42f54cceab34adb303c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fe2c36fca9911ab99a1f8abb53f0ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a49fe2c36fca9911ab99a1f8abb53f0ff">vec_slq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a49fe2c36fca9911ab99a1f8abb53f0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Left Quadword.  <a href="#a49fe2c36fca9911ab99a1f8abb53f0ff">More...</a><br /></td></tr>
<tr class="separator:a49fe2c36fca9911ab99a1f8abb53f0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070fe972995f3954362835f5b72e5ff6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a070fe972995f3954362835f5b72e5ff6">vec_slqi</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a070fe972995f3954362835f5b72e5ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Left Quadword Immediate.  <a href="#a070fe972995f3954362835f5b72e5ff6">More...</a><br /></td></tr>
<tr class="separator:a070fe972995f3954362835f5b72e5ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99c4af0aae31b02e1f17f12500198f0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ab99c4af0aae31b02e1f17f12500198f0">vec_sraq</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:ab99c4af0aae31b02e1f17f12500198f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Algebraic Quadword.  <a href="#ab99c4af0aae31b02e1f17f12500198f0">More...</a><br /></td></tr>
<tr class="separator:ab99c4af0aae31b02e1f17f12500198f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50546b5b39e0c21cffe678f225ff59b7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a50546b5b39e0c21cffe678f225ff59b7">vec_sraqi</a> (<a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a50546b5b39e0c21cffe678f225ff59b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Algebraic Quadword Immediate.  <a href="#a50546b5b39e0c21cffe678f225ff59b7">More...</a><br /></td></tr>
<tr class="separator:a50546b5b39e0c21cffe678f225ff59b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edd172a5656b842d6586c5078284942"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a0edd172a5656b842d6586c5078284942">vec_srq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a0edd172a5656b842d6586c5078284942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Quadword.  <a href="#a0edd172a5656b842d6586c5078284942">More...</a><br /></td></tr>
<tr class="separator:a0edd172a5656b842d6586c5078284942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05c640c6a42770cb95466ff4a2d903c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:ac05c640c6a42770cb95466ff4a2d903c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Quadword Immediate.  <a href="#ac05c640c6a42770cb95466ff4a2d903c">More...</a><br /></td></tr>
<tr class="separator:ac05c640c6a42770cb95466ff4a2d903c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6dca233bb7e4edc2adb751d478572e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a4f6dca233bb7e4edc2adb751d478572e">vec_slq4</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra)</td></tr>
<tr class="separator:a4f6dca233bb7e4edc2adb751d478572e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9964ce224b90a0986122f79f6455cba5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a9964ce224b90a0986122f79f6455cba5">vec_slq5</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra)</td></tr>
<tr class="separator:a9964ce224b90a0986122f79f6455cba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d355191fabd04a434723265ccafa20"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a49d355191fabd04a434723265ccafa20">vec_srq4</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra)</td></tr>
<tr class="separator:a49d355191fabd04a434723265ccafa20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257bcf71eefa1d08482587637dc400da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a257bcf71eefa1d08482587637dc400da">vec_srq5</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra)</td></tr>
<tr class="separator:a257bcf71eefa1d08482587637dc400da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d3546b2fd6840b46b031c15b4f60d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a95d3546b2fd6840b46b031c15b4f60d3">vec_subcuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a95d3546b2fd6840b46b031c15b4f60d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Subtract and Write Carry Unsigned Quadword.  <a href="#a95d3546b2fd6840b46b031c15b4f60d3">More...</a><br /></td></tr>
<tr class="separator:a95d3546b2fd6840b46b031c15b4f60d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f6df21399a4e6228eca254611b23c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a04f6df21399a4e6228eca254611b23c5">vec_subecuq</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrc)</td></tr>
<tr class="memdesc:a04f6df21399a4e6228eca254611b23c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Subtract Extended and Write Carry Unsigned Quadword.  <a href="#a04f6df21399a4e6228eca254611b23c5">More...</a><br /></td></tr>
<tr class="separator:a04f6df21399a4e6228eca254611b23c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e40f9bf5df59b725cbfb6738c765202"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a2e40f9bf5df59b725cbfb6738c765202">vec_subeuqm</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrc)</td></tr>
<tr class="memdesc:a2e40f9bf5df59b725cbfb6738c765202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Subtract Extended Unsigned Quadword Modulo.  <a href="#a2e40f9bf5df59b725cbfb6738c765202">More...</a><br /></td></tr>
<tr class="separator:a2e40f9bf5df59b725cbfb6738c765202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bafb410404d4f1e10a99263b57d1df0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> (<a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a6bafb410404d4f1e10a99263b57d1df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Subtract Unsigned Quadword Modulo.  <a href="#a6bafb410404d4f1e10a99263b57d1df0">More...</a><br /></td></tr>
<tr class="separator:a6bafb410404d4f1e10a99263b57d1df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e6361054b52ac4564bcef25b718151"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a84e6361054b52ac4564bcef25b718151">vec_vmuleud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a84e6361054b52ac4564bcef25b718151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Even Unsigned Doublewords.  <a href="#a84e6361054b52ac4564bcef25b718151">More...</a><br /></td></tr>
<tr class="separator:a84e6361054b52ac4564bcef25b718151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208744996e7482604ad274b44999d6ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int128__ppc_8h.html#a208744996e7482604ad274b44999d6ce">vec_vmuloud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a208744996e7482604ad274b44999d6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Odd Unsigned Doublewords.  <a href="#a208744996e7482604ad274b44999d6ce">More...</a><br /></td></tr>
<tr class="separator:a208744996e7482604ad274b44999d6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX and VSX instructions. </p>
<p>Some of these operations are implemented in a single instruction on newer (POWER8/POWER9) processors. This header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides a in-line assembler implementation for older compilers that do not provide the build-ins. Other operations do not exist as instructions on any current processor but are useful and should be provided. This header serves to provide these operations as inline functions using existing vector built-ins or other pveclib operations.</p>
<p>The original VMX (AKA Altivec) only defined a few instructions that operated on the 128-bit vector as a whole. This included the vector shift left/right (bit), vector shift left/right by octet (byte), vector shift left double by octet (select a contiguous 16-bytes from 2 concatenated vectors) 256-bit), and generalized vector permute (select any 16-bytes from 2 concatenated vectors). Use of these instructions can be complicated when;</p><ul>
<li>the shift amount is more than 8 bits,</li>
<li>the shift amount is not a multiple of 8-bits (octet),</li>
<li>the shift amount is a constant and needs to be generated/loaded before use.</li>
</ul>
<p>These instructions can used in combination to provide generalized vector __int128 shift/rotate operations. Pveclib uses these operations to provide vector __int128 shift / rotate left, shift right and shift algebraic right operations. These operations require pre-conditions to avoid multiple instructions or require a combination of (bit and octet shift) instructions to get the quadword result. The compiler &lt;altivec.h&gt; built-ins only supports individual instructions. So using these operations quickly inspires a need for a header (like this) to contain implementations of the common operations.</p>
<p>The VSX facility (introduced with POWER7) did not add any integer doubleword (64-bit) or quadword (128-bit) operations. However it did add a useful doubleword permute immediate and word wise; merge, shift, and splat immediate operations. Otherwise vector __int128 (128-bit elements) operations have to be implemented using VMX word and halfword element integer operations for POWER7.</p>
<p>POWER8 added multiply word operations that produce the full doubleword product and full quadword add / subtract (with carry extend). The add quadword is useful to sum the partial products for a full 128 x 128-bit multiply. The add quadword write carry and extend forms, simplify extending arithmetic to 256-bits and beyond.</p>
<p>While POWER8 provided quadword integer add and subtract operations, it did not provide quadword Signed/Unsigned integer compare operations. It is possible to implement quadword compare operations using existing word / doubleword compares and the the new quadword subtract write-carry operation. The trick it so convert the carry into a vector bool __int128 via the vec_setb_ncq () operation. This header provides easy to use quadword compare operations.</p>
<p>POWER9 (PowerISA 3.0B) adds the <b>Vector Multiply-Sum unsigned Doubleword Modulo</b> instruction. Aspects of this instruction mean it needs to be used carefully as part of larger quadword multiply. It performs only two of the four required doubleword multiplies. The final quadword modulo sum will discard any overflow/carry from the potential 130-bit result. With careful pre-conditioning of doubleword inputs the results are can not overflow from 128-bits. Then separate add quadword add/write carry operations can be used to complete the sum of partial products. These techniques are used in the POWER9 specific implementations of vec_muleud, vec_muloud, vec_mulluq, and vec_muludq.</p>
<p>PowerISA 3.0B also defined additional: Binary Coded Decimal (BCD) and Zoned character format conversions. String processing operations. Vector Parity operations. Integer Extend Sign Operations. Integer Absolute Difference Operations. All of these seem to useful additions to pveclib for older (POWER7/8) processors and across element sizes (including quadword elements).</p>
<p>Most of these intrinsic (compiler built-in) operations are defined in &lt;altivec.h&gt; and described in the compiler documentation. However it took several compiler releases for all the new POWER8 64-bit and 128-bit integer vector intrinsics to be added to <b>altivec.h</b>. This support started with the GCC 4.9 but was not complete across function/type and bug free until GCC 6.0.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example, if you compile with <b>-mcpu=power7</b>, vec_vadduqm and vec_vsubudm will not be defined. But <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a> and <a class="el" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500" title="Vector Subtract Unsigned Doubleword Modulo. ">vec_subudm()</a> and always be defined in this header, will generate the minimum code, appropriate for the target, and produce correct results.</dd></dl>
<p>Most of these operations are implemented in a single instruction on newer (POWER8/POWER9) processors. So this header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides a in-line assembler implementation for older compilers that do not provide the build-ins.</p>
<p>This header covers operations that are either:</p>
<ul>
<li>Operations implemented in hardware instructions for later processors and useful to programmers, on slightly older processors, even if the equivalent function requires more instructions. Examples include quadword byte reverse, add and subtract.</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.n&gt; provided by available compilers in common use. Examples include quadword byte reverse, add and subtract.</li>
<li>Are commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious. Examples include quadword; Signed and Unsigned compare, shift immediate, multiply, multiply by 10 immediate, count leading zeros and population count.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The Multiply sum/even/odd doubleword operations are currently implemented here (in &lt;<a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>&gt;) which resolves a dependency on Add Quadword. These functions (vec_msumudm, vec_muleud, vec_muloud) all produce a quadword results and may use the vec_adduqm implementation to sum partial products.</dd></dl>
<p>See <a class="el" href="index.html#mainpage_sub_1_3">Returning extended quadword results.</a> for more background on extended quadword computation.</p>
<h1><a class="anchor" id="i128_endian_issues_0_0"></a>
Endian problems with quadword implementations</h1>
<p>Technically operations on quadword elements should not require any endian specific transformation. There is only one element so there can be no confusion about element numbering or order. However some of the more complex quadword operations are constructed from operations on smaller elements. And those operations as provided by &lt;altivec.h&gt; are required by the OpenPOWER ABI to be endian sensitive. See <a class="el" href="vec__int64__ppc_8h.html#i64_endian_issues_0_0">Endian problems with doubleword operations</a> for a more detailed discussion.</p>
<p>In any case the arithmetic (high to low) order of bits in a quadword are defined in the PowerISA (See <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a> and <a class="el" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0" title="Vector Subtract Unsigned Quadword Modulo. ">vec_subuqm()</a>). So pveclib implementations will need to either:</p><ul>
<li>Nullify little endian transforms of &lt;altivec.h&gt; operations. The &lt;altivec.h&gt; built-ins <a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8" title="Vector multiply even unsigned words. ">vec_muleuw()</a>, <a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d" title="Vector multiply odd unsigned words. ">vec_mulouw()</a>, vec_mergel(), and vec_mergeh() are endian sensitive and often require nullification that restores the original operation.</li>
<li>Use new operations that are specifically defined to be stable across BE/LE implementations. The pveclib operations; <a class="el" href="vec__int128__ppc_8h.html#a84e6361054b52ac4564bcef25b718151" title="Vector Multiply Even Unsigned Doublewords. ">vec_vmuleud()</a> <a class="el" href="vec__int128__ppc_8h.html#a208744996e7482604ad274b44999d6ce" title="Vector Multiply Odd Unsigned Doublewords. ">vec_vmuloud()</a>, <a class="el" href="vec__int64__ppc_8h.html#acd5bafec6c1c15b0336551e82d1169d4" title="Vector Merge Algebraic High Doublewords. ">vec_mrgahd()</a>, <a class="el" href="vec__int64__ppc_8h.html#a5242d6311cd5ab50377cfeb2cf2ac8bf" title="Vector Merge Algebraic Low Doublewords. ">vec_mrgald()</a>. and <a class="el" href="vec__int64__ppc_8h.html#a8238ba590103ac80fb146a6a2b1aed1c" title="Vector Permute Doubleword Immediate. Combine a doubleword selected from the 1st (vra) vector with a d...">vec_permdi()</a> are defined to be endian stable.</li>
</ul>
<h1><a class="anchor" id="int128_examples_0_1"></a>
Vector Quadword Examples</h1>
<p>The PowerISA Vector facilities provide logical and integer arithmetic quadword (128-bit) operations. Some operations as direct PowerISA instructions and other operations composed of short instruction sequences. The Power Vector Library provides a higher level and comprehensive API of quadword integer integer arithmetic and support for extended arithmetic to multiple quadwords.</p>
<h2><a class="anchor" id="int128_examples_0_1_1"></a>
Printing Vector __int128 values</h2>
<p>The GCC compiler supports the (vector) __int128 type but the runtime does not support <b>printf()</b> formating for __int128 types. However if we can use divide/modulo operations to split vector __int128 values into modulo 10^16 long int (doubleword) chunks, we can use printf() to convert and concatenate the decimal values into a complete number.</p>
<p>For example, from the __int128 value (39 decimal digits):</p><ul>
<li>Detect the sign and set a char to "+' or '-'</li>
<li>Then from the absolute value, divide/modulo by 10000000000000000. Producing:<ul>
<li>The highest 7 digits (t_high)</li>
<li>The middle 16 digits (t_mid)</li>
<li>The lowest 16 digits (t_low)</li>
</ul>
</li>
</ul>
<p>We can use signed compare to detect the sign and set a char value to print a ' ' or '+' prefix. If the value is negative we want the absolute value before we do the divide/modulo steps. For example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a269401b65405524bb2d971bef595cb0d">vec_cmpsq_all_ge</a> (value, zero128))</div><div class="line">  {</div><div class="line">    sign = <span class="charliteral">&#39; &#39;</span>;</div><div class="line">    val128 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) value;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    sign = <span class="charliteral">&#39;-&#39;</span>;</div><div class="line">    val128 = <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> ((<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) zero128, (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) value);</div><div class="line">  }</div></div><!-- fragment --><p> Here we use the <b>pveclib</b> operation <a class="el" href="vec__int128__ppc_8h.html#a269401b65405524bb2d971bef595cb0d" title="Vector Compare any Greater Than or Equal Signed Quadword. ">vec_cmpsq_all_ge()</a> because the ABI and compilers do not define compare built-ins operations for the vector __int128 type. For the negative case we use the <b>pveclib</b> operation <a class="el" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0" title="Vector Subtract Unsigned Quadword Modulo. ">vec_subuqm()</a> instead of vec_abs. Again the ABI and compilers do not define vec_abs built-ins for the vector __int128 type. Using <b>pveclib</b> operations have the additional benefit of supporting older compilers and platform specific implementations for POWER7 and POWER8.</p>
<p>Now we have the absolute value in val128 we can factor it into (3) chunks of 16 digits each. Normally scalar codes would use integer divide/modulo by 10000000000000000. And we are reminded that the PowerISA vector unit does not support integer divide operations and definitely not for quadword integers.</p>
<p>Instead we can use the multiplicative inverse which is a scaled fixed point fraction calculated from the original divisor. This works nicely if the fixed radix point is just before the 128-bit fraction and we have a multiply high (<a class="el" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2" title="Vector Multiply High Unsigned Quadword. ">vec_mulhuq()</a>) operation. Multiplying a 128-bit unsigned integer by a 128-bit unsigned fraction generates a 256-bit product with 128-bits above (integer) and below (fraction) the radix point. The high 128-bits of the product is the integer quotient and we can discard the low order 128-bits.</p>
<p>It turns out that generating the multiplicative inverse can be tricky. To produce correct results over the full range requires, possible pre-scaling and post-shifting, and sometimes a corrective addition is necessary. Fortunately the mathematics are well understood and are commonly used in optimizing compilers. Even better, Henry Warren's book has a whole chapter on this topic. </p><dl class="section see"><dt>See also</dt><dd>"Hacker's Delight, 2nd Edition," Henry S. Warren, Jr, Addison Wesley, 2013. Chapter 10, Integer Division by Constants.</dd></dl>
<p>In the chapter above; </p><blockquote class="doxtable">
<p>Figure 10-2 Computing the magic number for unsigned division.</p>
</blockquote>
<p>provides a sample C function for generating the magic number (actually a struct containing; the magic multiplicative inverse, "add" indicator, and the shift amount.). For quadword and the divisor 10000000000000000,this is { 76624777043294442917917351357515459181, 0 , 51 }:</p><ul>
<li>the multiplier is 76624777043294442917917351357515459181.</li>
<li>no corrective add is required.</li>
<li>the final shift is 51-bits right.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> mul_ten16 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) <a class="code" href="vec__common__ppc_8h.html#a9ed8c282b57705c960542ed869de3325">CONST_VINT128_DW</a>(</div><div class="line">    0UL, 10000000000000000UL);</div><div class="line"><span class="comment">// Magic numbers for multiplicative inverse to divide by 10**16</span></div><div class="line"><span class="comment">// are 76624777043294442917917351357515459181, no corrective add,</span></div><div class="line"><span class="comment">// and shift right 51 bits.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> mul_invs_ten16 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) <a class="code" href="vec__common__ppc_8h.html#a9ed8c282b57705c960542ed869de3325">CONST_VINT128_DW</a>(</div><div class="line">    0x39a5652fb1137856UL, 0xd30baf9a1e626a6dUL);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> shift_ten16 = 51;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// first divide/modulo the 39 digits __int128 by 10**16.</span></div><div class="line"><span class="comment">// This separates the high/middle 23 digits (tmpq) and low 16 digits.</span></div><div class="line">tmpq = <a class="code" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2">vec_mulhuq</a> (val128, mul_invs_ten16);</div><div class="line">tmpq = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (tmpq, shift_ten16);</div><div class="line"><span class="comment">// Compute remainder of val128 / 10**16</span></div><div class="line"><span class="comment">// t_low = val128 - (tmpq * 10**16)</span></div><div class="line"><span class="comment">// Here we know tmpq and mul_ten16 are less then 64-bits</span></div><div class="line"><span class="comment">// so can use vec_vmuloud instead of vec_mulluq</span></div><div class="line">tmp = <a class="code" href="vec__int128__ppc_8h.html#a208744996e7482604ad274b44999d6ce">vec_vmuloud</a> ((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) tmpq, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) mul_ten16);</div><div class="line">t_low = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> (val128, tmp);</div><div class="line"></div><div class="line"><span class="comment">// Next divide/modulo the high/middle digits by 10**16.</span></div><div class="line"><span class="comment">// This separates the high 7 and middle 16 digits.</span></div><div class="line">val128 = tmpq;</div><div class="line">tmpq = <a class="code" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2">vec_mulhuq</a> (tmpq, mul_invs_ten16);</div><div class="line">t_high = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (tmpq, shift_ten16);</div><div class="line">tmp = <a class="code" href="vec__int128__ppc_8h.html#a208744996e7482604ad274b44999d6ce">vec_vmuloud</a> (t_high, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) mul_ten16);</div><div class="line">t_mid = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> (val128, tmp);</div></div><!-- fragment --><p> All the operations used above are defined and implemented by <b>pveclib</b>. Most of these operations is not defined as single instructions in the PowerISA or as built-ins the ABI or require alternative implementations for older processors.</p>
<p>Now we have three vector unsigned __int128 values (t_low, t_mid, t_high) in the range 0-9999999999999999. Fixed point values in that range fit into the low order doubleword of each quadword. We can access these doublewords with array notation ([VEC_DW_L]) and the compiler will transfer them to fixed point (long int) GPRs. Then use normal char and long int printf() formating. For example: </p><div class="fragment"><div class="line">printf (<span class="stringliteral">&quot;%c%07lld%016lld%016lld&quot;</span>, sign,</div><div class="line">        t_high[VEC_DW_L], t_mid[VEC_DW_L], t_low[VEC_DW_L]);</div></div><!-- fragment --><p>Here is the complete vector __int128 printf example: </p><div class="fragment"><div class="line"> <span class="keywordtype">void</span></div><div class="line">example_print_vint128 (<a class="code" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> value)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> max_neg = (<a class="code" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>) <a class="code" href="vec__common__ppc_8h.html#a9ed8c282b57705c960542ed869de3325">CONST_VINT128_DW</a>(</div><div class="line">      0x8000000000000000L, 0UL);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> zero128 = (<a class="code" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>) <a class="code" href="vec__common__ppc_8h.html#a9ed8c282b57705c960542ed869de3325">CONST_VINT128_DW</a>(</div><div class="line">      0x0L, 0UL);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> mul_ten16 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) <a class="code" href="vec__common__ppc_8h.html#a9ed8c282b57705c960542ed869de3325">CONST_VINT128_DW</a>(</div><div class="line">      0UL, 10000000000000000UL);</div><div class="line">  <span class="comment">// Magic numbers for multiplicative inverse to divide by 10**16</span></div><div class="line">  <span class="comment">// are 76624777043294442917917351357515459181, no corrective add,</span></div><div class="line">  <span class="comment">// and shift right 51 bits.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> mul_invs_ten16 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) <a class="code" href="vec__common__ppc_8h.html#a9ed8c282b57705c960542ed869de3325">CONST_VINT128_DW</a>(</div><div class="line">      0x39a5652fb1137856UL, 0xd30baf9a1e626a6dUL);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> shift_ten16 = 51;</div><div class="line"></div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> tmpq, tmp;</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> t_low, t_mid, t_high;</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> val128;</div><div class="line">  <span class="keywordtype">char</span> sign;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a269401b65405524bb2d971bef595cb0d">vec_cmpsq_all_ge</a> (value, zero128))</div><div class="line">    {</div><div class="line">      sign = <span class="charliteral">&#39; &#39;</span>;</div><div class="line">      val128 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) value;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      sign = <span class="charliteral">&#39;-&#39;</span>;</div><div class="line">      val128 = <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> ((<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) zero128, (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) value);</div><div class="line">    }</div><div class="line">  <span class="comment">// Convert the absolute (unsigned) value to Decimal and</span></div><div class="line">  <span class="comment">// prefix the sign.</span></div><div class="line"></div><div class="line">  <span class="comment">// first divide/modulo the 39 digits __int128 by 10**16.</span></div><div class="line">  <span class="comment">// This separates the high/middle 23 digits (tmpq) and low 16 digits.</span></div><div class="line">  tmpq = <a class="code" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2">vec_mulhuq</a> (val128, mul_invs_ten16);</div><div class="line">  tmpq = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (tmpq, shift_ten16);</div><div class="line">  <span class="comment">// Compute remainder of val128 / 10**16</span></div><div class="line">  <span class="comment">// t_low = val128 - (tmpq * 10**16)</span></div><div class="line">  <span class="comment">// Here we know tmpq and mul_ten16 are less then 64-bits</span></div><div class="line">  <span class="comment">// so can use vec_vmuloud instead of vec_mulluq</span></div><div class="line">  tmp = <a class="code" href="vec__int128__ppc_8h.html#a208744996e7482604ad274b44999d6ce">vec_vmuloud</a> ((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) tmpq, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) mul_ten16);</div><div class="line">  t_low = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> (val128, tmp);</div><div class="line"></div><div class="line">  <span class="comment">// Next divide/modulo the high/middle digits by 10**16.</span></div><div class="line">  <span class="comment">// This separates the high 7 and middle 16 digits.</span></div><div class="line">  val128 = tmpq;</div><div class="line">  tmpq = <a class="code" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2">vec_mulhuq</a> (tmpq, mul_invs_ten16);</div><div class="line">  t_high = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (tmpq, shift_ten16);</div><div class="line">  tmp = <a class="code" href="vec__int128__ppc_8h.html#a208744996e7482604ad274b44999d6ce">vec_vmuloud</a> (t_high, (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) mul_ten16);</div><div class="line">  t_mid = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> (val128, tmp);</div><div class="line"></div><div class="line">  printf (<span class="stringliteral">&quot;%c%07lld%016lld%016lld&quot;</span>, sign, t_high[VEC_DW_L],</div><div class="line">          t_mid[VEC_DW_L], t_low[VEC_DW_L]);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="int128_examples_0_1_2"></a>
Converting Vector __int128 values to BCD</h2>
<p>POWER8 and POWER9 added a number of Binary Code Decimal (BCD) and Zoned Decimal operations that should be helpful for radix conversion and even faster large integer formatting for print. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="vec__bcd__ppc_8h.html" title="Header package containing a collection of Binary Coded Decimal (BCD) computation and Zoned Character ...">vec_bcd_ppc.h</a></dd></dl>
<p>The issue remains that __int128 values can represent up to 39 decimal digits while Signed BCD supports only 31 digits. POWER9 provides a <b>Decimal Convert From Signed Quadword</b> instruction with the following restriction:</p>
<dl class="section note"><dt>Note</dt><dd>If the signed value of vrb is less then -(10**31-1) or greater than 10**31-1 the result is too large for the BCD format and the result is undefined.</dd></dl>
<p>It would be useful to check for this and if required, factor the __int128 value into to the high order 8 digits and the low order 31 digits. This allows for the safe and correct use of the <a class="el" href="vec__bcd__ppc_8h.html#a5a1aec05a6dadcf5a1a8e028223745df" title="Vector Decimal Convert From Signed Quadword returning up to 31 BCD digits. ">vec_bcdcfsq()</a> and with some decimal shifts/truncates <a class="el" href="vec__bcd__ppc_8h.html#a832d31ded0b33a2b46f6491bcb71ea51" title="Vector Decimal Convert To Zoned. ">vec_bcdctz()</a>. This also enables conversion to multiple precision Vector BCD to represent 39 digits and more for radix conversions.</p>
<p>We first address the factoring by providing <b>Vector Divide by const 10e31 Unsigned Quadword</b> and <b>Vector Modulo by const 10e31 Unsigned Quadword</b> operation. This requires the multiplicative inverse using the <a class="el" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2" title="Vector Multiply High Unsigned Quadword. ">vec_mulhuq()</a> operation.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a></div><div class="line"><a class="code" href="vec__int128__ppc_8h.html#a9a6a39212f8a8b9ebf20e0117e1e1e88">vec_divuq_10e31</a> (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra)</div><div class="line">  <span class="comment">// ten32  = +100000000000000000000000000000000UQ</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> ten31 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>)</div><div class="line">          { (__int128) 1000000000000000UL * (__int128) 10000000000000000UL };</div><div class="line">  <span class="comment">// Magic numbers for multiplicative inverse to divide by 10**31</span></div><div class="line">  <span class="comment">// are 4804950418589725908363185682083061167, corrective add,</span></div><div class="line">  <span class="comment">// and shift right 107 bits.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> mul_invs_ten31 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) <a class="code" href="vec__common__ppc_8h.html#a9ed8c282b57705c960542ed869de3325">CONST_VINT128_DW</a>(</div><div class="line">      0x039d66589687f9e9UL, 0x01d59f290ee19dafUL);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> shift_ten31 = 103;</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> result, t, q;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#af8f06b2c3d612a7cfdeb3bb883c59e19">vec_cmpuq_all_ge</a> (vra, ten31))</div><div class="line">    {</div><div class="line">      q = <a class="code" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2">vec_mulhuq</a> (vra, mul_invs_ten31);</div><div class="line">      <span class="comment">// Need corrective add but want to avoid carry &amp; double quad shift</span></div><div class="line">      <span class="comment">// The following avoids the carry and less instructions</span></div><div class="line">      t = <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> (vra, q);</div><div class="line">      t = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (t, 1);</div><div class="line">      t = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (t, q);</div><div class="line">      result = <a class="code" href="vec__int128__ppc_8h.html#ac05c640c6a42770cb95466ff4a2d903c">vec_srqi</a> (t, (shift_ten31 - 1));</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    result = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) { (__int128) 0 };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p> As the <a class="el" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2" title="Vector Multiply High Unsigned Quadword. ">vec_mulhuq()</a> operation is relatively expensive and we expect most __int128 values to 31-digits or less, using a compare to bypass the multiplication and return the 0 quotient, seems a prudent optimization.</p>
<p>So far we only have the quotient (the high order 8 digits) and still need to extract the remainder (the low order 31 digits). This is simply the quotient from above multiplied by 10e31 and subtracted from the original input. To avoid the multiple return value issue we define a modulo operation to take the original value and the quotient from <a class="el" href="vec__int128__ppc_8h.html#a9a6a39212f8a8b9ebf20e0117e1e1e88" title="Vector Divide by const 10e31 Unsigned Quadword. ">vec_divuq_10e31()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a></div><div class="line"><a class="code" href="vec__int128__ppc_8h.html#af4b3b91f7e80522d8a8c0c171e077b99">vec_moduq_10e31</a> (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> q)</div><div class="line">{</div><div class="line">  <span class="comment">// ten32  = +100000000000000000000000000000000UQ</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> ten31 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>)</div><div class="line">          { (__int128) 1000000000000000UL * (__int128) 10000000000000000UL };</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> result, t;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#af8f06b2c3d612a7cfdeb3bb883c59e19">vec_cmpuq_all_ge</a> (vra, ten31))</div><div class="line">    {</div><div class="line">      t = <a class="code" href="vec__int128__ppc_8h.html#a9aaaf0e4c2705be1e0e8e925b09c52de">vec_mulluq</a> (q, ten31);</div><div class="line">      result = <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> (vra, t);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    result = vra;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p> Again as the <a class="el" href="vec__int128__ppc_8h.html#a9aaaf0e4c2705be1e0e8e925b09c52de" title="Vector Multiply Low Unsigned Quadword. ">vec_mulluq()</a> operation is relatively expensive and we expect most __int128 values to 31-digits or less, using a compare to bypass the multiplication and return the input value as the remainder, seems a prudent optimization.</p>
<p>We expect these operations to be used together as in this example. </p><div class="fragment"><div class="line">q = <a class="code" href="vec__int128__ppc_8h.html#a9a6a39212f8a8b9ebf20e0117e1e1e88">vec_divuq_10e31</a> (a);</div><div class="line">r = <a class="code" href="vec__int128__ppc_8h.html#af4b3b91f7e80522d8a8c0c171e077b99">vec_moduq_10e31</a> (a, q);</div></div><!-- fragment --><p> We also expect the compiler to common the various constant loads across the two operations as the code is in-lined. This header also provides variants for factoring by 10e32 (to use with the Zone conversion) and signed variants of the 10e31 operation for direct conversion to extend precision signed BCD. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="vec__int128__ppc_8h.html#ae2b45341cc9cc918198bb69da0552098" title="Vector Divide by const 10e32 Unsigned Quadword. ">vec_divuq_10e32()</a>, <a class="el" href="vec__int128__ppc_8h.html#aff4f1d8a707289d2271eafad4aeb1e82" title="Vector Modulo by const 10e32 Unsigned Quadword. ">vec_moduq_10e32()</a>, <a class="el" href="vec__int128__ppc_8h.html#ae320909aca43d55b8be1069f38544ee8" title="Vector Divide by const 10e31 Signed Quadword. ">vec_divsq_10e31</a>, <a class="el" href="vec__int128__ppc_8h.html#aab5db88e4608d4a7408df9042adce86c" title="Vector Modulo by const 10e31 Signed Quadword. ">vec_modsq_10e31</a>.</dd></dl>
<h2><a class="anchor" id="int128_examples_0_1_3"></a>
Extending integer operations beyond Quadword</h2>
<p>Some algorithms require even high integer precision than __int128 provides. this includes:</p><ul>
<li>POSIX compliant conversion between __float128 and _Decimal128 types</li>
<li>POSIX compliant conversion from double and __float128 to decimal for print.</li>
<li>Cryptographic operations for Public-key cryptography and Elliptic Curves</li>
</ul>
<p>The POWER8 provides instructions for extending add and subtract to 128-bit integer and beyond with carry/extend operations (see <a class="el" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3" title="Vector Add &amp; write Carry Unsigned Quadword. ">vec_addcuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#af18b98d2d73f1afbc439e1407c78f305" title="Vector Add Extended &amp; write Carry Unsigned Quadword. ">vec_addecuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a44e63f70b182d60fe03b43a80647451a" title="Vector Add Extended Unsigned Quadword Modulo. ">vec_addeuqm()</a>, <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>, (see <a class="el" href="vec__int128__ppc_8h.html#a95d3546b2fd6840b46b031c15b4f60d3" title="Vector Subtract and Write Carry Unsigned Quadword. ">vec_subcuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a04f6df21399a4e6228eca254611b23c5" title="Vector Subtract Extended and Write Carry Unsigned Quadword. ">vec_subecuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a2e40f9bf5df59b725cbfb6738c765202" title="Vector Subtract Extended Unsigned Quadword Modulo. ">vec_subeuqm()</a>, <a class="el" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0" title="Vector Subtract Unsigned Quadword Modulo. ">vec_subuqm()</a>). POWER9 adds instructions to improve decimal / binary conversion to/from 128-bit integer and beyond with carry/extend operations. And while the PowerISA does not yet provide full 128 x 128 bit integer multiply instructions, it has provided wider integer multiply instructions, beginning in POWER8 (see <a class="el" href="vec__int32__ppc_8h.html#add7b91bf6138d029d9d8cc57b0905f1f" title="Vector multiply even signed words. ">vec_mulesw()</a>, <a class="el" href="vec__int32__ppc_8h.html#a415942bd7b8183634e44e56b6a40101b" title="Vector multiply odd signed words. ">vec_mulosw()</a>, <a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8" title="Vector multiply even unsigned words. ">vec_muleuw()</a>, <a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d" title="Vector multiply odd unsigned words. ">vec_mulouw()</a>) and again in POWER9 (see <a class="el" href="vec__int128__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a>).</p>
<p>This all allows the <b>pveclib</b> to improve (reduce the latency of) the implementation of multiply quadword operations. This includes operations that generate the full 256-bit multiply product (see <a class="el" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8" title="Vector Multiply Unsigned Double Quadword. ">vec_muludq()</a>, <a class="el" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2" title="Vector Multiply High Unsigned Quadword. ">vec_mulhuq()</a>. <a class="el" href="vec__int128__ppc_8h.html#a9aaaf0e4c2705be1e0e8e925b09c52de" title="Vector Multiply Low Unsigned Quadword. ">vec_mulluq()</a>). And this in combination with add/subtract with carry extend quadword allows the coding of even wider (multiple quadword) multiply operations.</p>
<h3><a class="anchor" id="int128_examples_0_1_3_0"></a>
Extended Quadword multiply</h3>
<p>The following example performs a 256x256 bit unsigned integer multiply generating a 512-bit product: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">test_mul4uq (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *__restrict__ mulu, <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> m1h, <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> m1l,</div><div class="line">             <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> m2h, <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> m2l)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> mc, mp, mq;</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> mphh, mphl, mplh, mpll;</div><div class="line">  mpll = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;mplh, m1l, m2l);</div><div class="line">  mp = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;mphl, m1h, m2l);</div><div class="line">  mplh = <a class="code" href="vec__int128__ppc_8h.html#a363fa7103ccd730c47bb34cb9f05e80b">vec_addcq</a> (&amp;mc, mplh, mp);</div><div class="line">  mphl = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (mphl, mc);</div><div class="line">  mp = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;mc, m2h, m1l);</div><div class="line">  mplh = <a class="code" href="vec__int128__ppc_8h.html#a363fa7103ccd730c47bb34cb9f05e80b">vec_addcq</a> (&amp;mq, mplh, mp);</div><div class="line">  mphl = <a class="code" href="vec__int128__ppc_8h.html#a363fa7103ccd730c47bb34cb9f05e80b">vec_addcq</a> (&amp;mc, mphl, mq);</div><div class="line">  mp = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;mphh, m2h, m1h);</div><div class="line">  mplh = <a class="code" href="vec__int128__ppc_8h.html#a363fa7103ccd730c47bb34cb9f05e80b">vec_addcq</a> (&amp;mc, mplh, mp);</div><div class="line">  mphl = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (mphh, mc);</div><div class="line"></div><div class="line">  mulu[0] = mpll;</div><div class="line">  mulu[1] = mplh;</div><div class="line">  mulu[2] = mphl;</div><div class="line">  mulu[3] = mphh;</div><div class="line">}</div></div><!-- fragment --><p> This example generates some additional questions:</p><ul>
<li>Why use <a class="el" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8" title="Vector Multiply Unsigned Double Quadword. ">vec_muludq()</a> instead of pairing <a class="el" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2" title="Vector Multiply High Unsigned Quadword. ">vec_mulhuq()</a> and <a class="el" href="vec__int128__ppc_8h.html#a9aaaf0e4c2705be1e0e8e925b09c52de" title="Vector Multiply Low Unsigned Quadword. ">vec_mulluq()</a>?</li>
<li>Why use <a class="el" href="vec__int128__ppc_8h.html#a363fa7103ccd730c47bb34cb9f05e80b" title="Vector Add with carry Unsigned Quadword. ">vec_addcq()</a> instead of pairing <a class="el" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3" title="Vector Add &amp; write Carry Unsigned Quadword. ">vec_addcuq()</a> and <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>?</li>
<li>Why return the 512-bit product via a pointer instead of returning a struct or array of 4 x vui128_t (<em>homogeneous aggregates</em>)?</li>
</ul>
<p>The detailed rationale for this is documented in section <a class="el" href="index.html#mainpage_sub_1_3">Returning extended quadword results.</a> In this specific case (quadword integer operations that generate two vector values) <b>pveclib</b> provides both alternatives:</p><ul>
<li>separate operations each returning a single (high or low order) vector.</li>
<li>combined operations providing:<ul>
<li>the lower order vector as the function return value.</li>
<li>the high order (carry or high product) vector via a pointer reference parameter.</li>
</ul>
</li>
</ul>
<p>Either method should provide the same results. For example: </p><div class="fragment"><div class="line">mplh = <a class="code" href="vec__int128__ppc_8h.html#a363fa7103ccd730c47bb34cb9f05e80b">vec_addcq</a> (&amp;mc, mplh, mp);</div></div><!-- fragment --><p> is equivalent to </p><div class="fragment"><div class="line">mc   = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (mplh, mp);</div><div class="line">mplh = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (mplh, mp);</div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line">mpll = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;mplh, m1l, m2l);</div></div><!-- fragment --><p> is equivalent to </p><div class="fragment"><div class="line">mpll = <a class="code" href="vec__int128__ppc_8h.html#a9aaaf0e4c2705be1e0e8e925b09c52de">vec_mulluq</a> (m1l, m2l);</div><div class="line">mplh = <a class="code" href="vec__int128__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06">vec_mulhud</a> (m1l, m2l);</div></div><!-- fragment --><p> So is there any advantage to separate versus combined operations?</p>
<p>Functionally it is useful to have separate operations for the cases where only one quadword part is needed. For example if you know that a add/subtract operation can not overflow, why generate the carry? Alternatively the quadword greater/less-than compares are based solely on the carry from the subtract quadword, why generate lower 128-bit (modulo) difference? For multiplication the modulo (multiply low) operation is the expected semantic or is known to be sufficient. Alternatively the multiplicative inverse only uses the high order (multiply high) quadword of the product.</p>
<p>From the performance (instruction latency and throughput) perspective, if the algorithm requires the extended result or full product, the combined operation is usually the better choice. Otherwise use the specific single return operation needed. At best, the separate operations may generate the same instruction sequence as the combined operation, But this depends on the target platform and specific optimizations implemented by the compiler.</p>
<dl class="section note"><dt>Note</dt><dd>For inlined operations the pointer reference in the combined form, is usually optimized to a simple register assignment, by the compiler. </dd>
<dd>
For platform targets where the separate operations each generate a single instruction, we expect the compiler to generate the same instructions as the combined operation. But this is only likely for add/sub quadword on the POWER8 and multiply by 10 quadword on POWER9.</dd></dl>
<h3><a class="anchor" id="int128_examples_0_1_3_1"></a>
Quadword Long Division</h3>
<p>In the section <a class="el" href="vec__int128__ppc_8h.html#int128_examples_0_1_2">Converting Vector __int128 values to BCD</a> above we used multiplicative inverse to factor a binary quadword value in two (high quotient and low remainder) parts. Here we divide by a large power of 10 (10<sup>31</sup> or 10<sup>32</sup>) of a size where the quotient and remainder allow direct conversion to BCD (see <a class="el" href="vec__bcd__ppc_8h.html#a5a1aec05a6dadcf5a1a8e028223745df" title="Vector Decimal Convert From Signed Quadword returning up to 31 BCD digits. ">vec_bcdcfsq()</a>, <a class="el" href="vec__bcd__ppc_8h.html#a7b8b5371d537cd878ffb37337e93ba14" title="Vector Decimal Convert From Unsigned Quadword returning up to 32 BCD digits. ">vec_bcdcfuq()</a>). After conversion, the BCD parts can be concatenated to form the larger (39 digit) decimal radix value equivalent of the 128-bit binary value.</p>
<p>We can extend this technique to larger (multiple quadword) binary values but this requires long division. This is the version of the long division you learned in grade school, where a multi-digit value is divided in stages by a single digit. But the digits we are using are really big (10<sup>31</sup>-1 or 10<sup>32</sup>-1).</p>
<p>The first step is relatively easy. Start by dividing the left-most <em>digit</em> of the dividend by the divisor, generating the integer quotient and remainder. We already have operations to implement that. </p><div class="fragment"><div class="line"><span class="comment">// initial step for the top digits</span></div><div class="line">dn = d[0];</div><div class="line">qh = <a class="code" href="vec__int128__ppc_8h.html#a9a6a39212f8a8b9ebf20e0117e1e1e88">vec_divuq_10e31</a> (dn);</div><div class="line">rh = <a class="code" href="vec__int128__ppc_8h.html#af4b3b91f7e80522d8a8c0c171e077b99">vec_moduq_10e31</a> (dn, qh);</div><div class="line">q[0] = qh;</div></div><!-- fragment --><p> The array <em>d</em> contains the quadwords of the extended precision integer dividend. The array <em>q</em> will contain the quadwords of the extended precision integer quotient. Here we have generated the first <em>quadword q[0]</em> digit of the quotient. The remainder <em>rh</em> will be used in the next step of the long division.</p>
<p>The process repeats except after the first step we have an intermediate dividend formed from:</p><ul>
<li>The remainder from the previous step</li>
<li>Concatenated with the next <em>digit</em> of the extended precision quadword dividend.</li>
</ul>
<p>So for each additional step we need to divide two quadwords (256-bits) by the quadword divisor. Actually this dividend should be less than a full 256-bits because we know the remainder is less than the divisor. So the intermediate dividend is less than ((divisor - 1) * 2<sup>128</sup>). So we know the quotient can not exceed (2<sup>128</sup>-1) or one quadword.</p>
<p>Now we need an operation that will divide this double quadword value and provide quotient and remainder that are correct (or close enough). Remember your grade school long division where you would:</p><ul>
<li>estimate the quotient</li>
<li>multiply the quotient by the divisor</li>
<li>subtract this product from the current 2 digit dividend</li>
<li>check that the remainder is less than the divisor.<ul>
<li>if the remainder is greater than the divisor; the estimated quotient is too small</li>
<li>if the remainder is negative (the product was greater than the dividend); the estimated quotient is too large.</li>
</ul>
</li>
<li>correct the quotient and remainder if needed before doing the next step.</li>
</ul>
<p>So we don't need to be perfect, but close enough. As long as we can detect any problems and (if needed) correct the results, we can implement long division to any size.</p>
<p>We already have an operation for dividing a quadword by 10<sup>31</sup> using the magic numbers for multiplicative inverse. This can easily be extended to multiply double quadword high. For example: </p><div class="fragment"><div class="line"><span class="comment">// Multiply high [vra||vrb] * mul_invs_ten31</span></div><div class="line">q = <a class="code" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2">vec_mulhuq</a> (vrb, mul_invs_ten31);</div><div class="line">q1 = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;t, vra, mul_invs_ten31);</div><div class="line">c = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (q1, q);</div><div class="line">q = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (q1, q);</div><div class="line">q1 = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (t, c);</div><div class="line"><span class="comment">// corrective add [q2||q1||q] = [q1||q] + [vra||vrb]</span></div><div class="line">c = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (vrb, q);</div><div class="line">q = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (vrb, q);</div><div class="line"><span class="comment">// q2 is the carry-out from the corrective add</span></div><div class="line">q2 = <a class="code" href="vec__int128__ppc_8h.html#af18b98d2d73f1afbc439e1407c78f305">vec_addecuq</a> (q1, vra, c);</div><div class="line">q1 = <a class="code" href="vec__int128__ppc_8h.html#a44e63f70b182d60fe03b43a80647451a">vec_addeuqm</a> (q1, vra, c);</div><div class="line"><span class="comment">// shift 384-bits (including the carry) right 107 bits</span></div><div class="line"><span class="comment">// Using shift left double quadword shift by (128-107)-bits</span></div><div class="line">r2 = <a class="code" href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a> (q2, q1, (128 - shift_ten31));</div><div class="line">result = <a class="code" href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a> (q1, q, (128 - shift_ten31));</div></div><!-- fragment --><p> Here we generate a 256-bit multiply high using the <a class="el" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2" title="Vector Multiply High Unsigned Quadword. ">vec_mulhuq()</a> for the low dividend (vrb) and <a class="el" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8" title="Vector Multiply Unsigned Double Quadword. ">vec_muludq()</a> for high dividend (vra). Then sum the partial products ([t||q1] + [0||q]) to get initial 256-bit product [q1||q]. Then apply the corrective add ([q1||q] + [vra||vrb]). This may generate a carry which needs to be included in the final shift.</p>
<p>Technically we only expect a 128-bit quotient after the shift, but we have 3 quadwords (2 quadwords and a carry) going into the shift right. Also our (estimated) quotient may be <em>off by 1</em> and generate a 129-bit result. This is due to using a the magic numbers for 128-bit multiplicative inverse and not regenerating magic numbers for 256-bits. We can't do anything about that now and so return a 256-bit double quadword quotient.</p>
<dl class="section note"><dt>Note</dt><dd>This is where only needing to be "close enough", works in our favor. We will check and correct the quotient in the modulo operation.</dd></dl>
<p>The 256-bits we want are spanning multiple quadwords so we replace a simple quadword shift right with two <b>Shift Left Double Quadword Immediate</b> operations and complement the shift count (128 - shift_ten31). This gives a 256-bit quotient which we expect to have zero in the high quadword.</p>
<p>As this operation will be used in a loop for long division operations and the extended multiplies are fairly expensive, we should check for an short-circuit special conditions. The most important special condition is when the dividend is less that the divisor and the quotient is zero. This also helps when the long division dividend may have leading quadword zeros that need to be skipped over. For the full implementation looks like: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a></div><div class="line"><a class="code" href="vec__int128__ppc_8h.html#afa2db6d665f837f96c746d88027e9e19">vec_divudq_10e31</a> (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *qh, <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> ten31 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>)</div><div class="line">          { (__int128) 1000000000000000UL * (__int128) 10000000000000000UL };</div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> zero = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) { (__int128) 0UL };</div><div class="line">  <span class="comment">// Magic numbers for multiplicative inverse to divide by 10**31</span></div><div class="line">  <span class="comment">// are 4804950418589725908363185682083061167, corrective add,</span></div><div class="line">  <span class="comment">// and shift right 103 bits.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> mul_invs_ten31 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) <a class="code" href="vec__common__ppc_8h.html#a9ed8c282b57705c960542ed869de3325">CONST_VINT128_DW</a>(</div><div class="line">      0x039d66589687f9e9UL, 0x01d59f290ee19dafUL);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> shift_ten31 = 103;</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> result, r2, t, q, q1, q2, c;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a1799f860ba79e698c66b171392afde01">vec_cmpuq_all_ne</a> (vra, zero) || <a class="code" href="vec__int128__ppc_8h.html#af8f06b2c3d612a7cfdeb3bb883c59e19">vec_cmpuq_all_ge</a> (vrb, ten31))</div><div class="line">    {</div><div class="line">      <span class="comment">// Multiply high [vra||vrb] * mul_invs_ten31</span></div><div class="line">      q = <a class="code" href="vec__int128__ppc_8h.html#ad6be9c8f02e43c39a659d6bbc9c3a2d2">vec_mulhuq</a> (vrb, mul_invs_ten31);</div><div class="line">      q1 = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;t, vra, mul_invs_ten31);</div><div class="line">      c = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (q1, q);</div><div class="line">      q = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (q1, q);</div><div class="line">      q1 = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (t, c);</div><div class="line">      <span class="comment">// corrective add [q2||q1||q] = [q1||q] + [vra||vrb]</span></div><div class="line">      c = <a class="code" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3">vec_addcuq</a> (vrb, q);</div><div class="line">      q = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (vrb, q);</div><div class="line">      <span class="comment">// q2 is the carry-out from the corrective add</span></div><div class="line">      q2 = <a class="code" href="vec__int128__ppc_8h.html#af18b98d2d73f1afbc439e1407c78f305">vec_addecuq</a> (q1, vra, c);</div><div class="line">      q1 = <a class="code" href="vec__int128__ppc_8h.html#a44e63f70b182d60fe03b43a80647451a">vec_addeuqm</a> (q1, vra, c);</div><div class="line">      <span class="comment">// shift 384-bits (including the carry) right 103 bits</span></div><div class="line">      <span class="comment">// Using shift left double quadword shift by (128-103)-bits</span></div><div class="line">      r2 = <a class="code" href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a> (q2, q1, (128 - shift_ten31));</div><div class="line">      result = <a class="code" href="vec__int128__ppc_8h.html#aaa33904ec4de42f54cceab34adb303c5">vec_sldqi</a> (q1, q, (128 - shift_ten31));</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="comment">// Dividend is less than divisor then return zero quotient</span></div><div class="line">      r2 = zero;</div><div class="line">      result = zero;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// return 256-bit quotient</span></div><div class="line">  *qh = r2;</div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p>To complete the long division operation we need to perform double quadword modulo operations. Here the dividend is two quadwords and the low quadword of the quotient from the divide double quadword operation above. We use multiply double quadword to compute the remainder ([vra||vrb] - (q * 10<sup>31</sup>). Generating the 256-bit product and difference ensure we can detect the case where the quotient is off-by-1 on the high side.</p>
<div class="fragment"><div class="line">t = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;th, *ql, ten31);</div><div class="line">c = <a class="code" href="vec__int128__ppc_8h.html#a95d3546b2fd6840b46b031c15b4f60d3">vec_subcuq</a> (vrb, t);</div><div class="line">t = <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> (vrb, t);</div><div class="line">th = <a class="code" href="vec__int128__ppc_8h.html#a2e40f9bf5df59b725cbfb6738c765202">vec_subeuqm</a> (vra, th, c);</div><div class="line"><span class="comment">// The remainder should be less than the divisor</span></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a1799f860ba79e698c66b171392afde01">vec_cmpuq_all_ne</a> (th, zero) &amp;&amp; <a class="code" href="vec__int128__ppc_8h.html#af8f06b2c3d612a7cfdeb3bb883c59e19">vec_cmpuq_all_ge</a> (t, ten31))</div><div class="line">  {</div><div class="line">    <span class="comment">// Otherwise the estimated quotient is off by 1</span></div><div class="line">     *ql = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (*ql, minus_one);</div><div class="line">    <span class="comment">// And the remainder is negative, so add the divisor</span></div><div class="line">    t = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (t, ten31);</div><div class="line">  }</div><div class="line">result = t;</div></div><!-- fragment --><p> In this case we need to correct both remainder and the (estimated) quotient. This is a bit tricky as the quotient is normally passed by value, but for this operation we need to pass by reference, which allows the corrected quotient to be passed on to the next step.</p>
<p>Again as this operation will be used in a loop for long division operations and the extended multiplies are fairly expensive, we should check for and short-circuit special conditions. The most important special condition is when the dividend is less that the divisor and the remainder is simply the dividend.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a></div><div class="line"><a class="code" href="vec__int128__ppc_8h.html#a31a893a75e42f5f6c4dfe793678fea59">vec_modudq_10e31</a> (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vrb, <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *ql)</div><div class="line">{</div><div class="line">  <span class="comment">// ten31  = +100000000000000000000000000000000UQ</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> ten31 = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>)</div><div class="line">          { (__int128) 1000000000000000UL * (__int128) 10000000000000000UL };</div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> zero = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) { (__int128) 0UL };</div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> minus_one = (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>) { (__int128) -1L };</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> result, t, th, c;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a1799f860ba79e698c66b171392afde01">vec_cmpuq_all_ne</a> (vra, zero) || <a class="code" href="vec__int128__ppc_8h.html#af8f06b2c3d612a7cfdeb3bb883c59e19">vec_cmpuq_all_ge</a> (vrb, ten31))</div><div class="line">    {</div><div class="line">      t = <a class="code" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8">vec_muludq</a> (&amp;th, *ql, ten31);</div><div class="line">      c = <a class="code" href="vec__int128__ppc_8h.html#a95d3546b2fd6840b46b031c15b4f60d3">vec_subcuq</a> (vrb, t);</div><div class="line">      t = <a class="code" href="vec__int128__ppc_8h.html#a6bafb410404d4f1e10a99263b57d1df0">vec_subuqm</a> (vrb, t);</div><div class="line">      th = <a class="code" href="vec__int128__ppc_8h.html#a2e40f9bf5df59b725cbfb6738c765202">vec_subeuqm</a> (vra, th, c);</div><div class="line">      <span class="comment">// The remainder should be less than the divisor</span></div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__int128__ppc_8h.html#a1799f860ba79e698c66b171392afde01">vec_cmpuq_all_ne</a> (th, zero) &amp;&amp; <a class="code" href="vec__int128__ppc_8h.html#af8f06b2c3d612a7cfdeb3bb883c59e19">vec_cmpuq_all_ge</a> (t, ten31))</div><div class="line">        {</div><div class="line">          <span class="comment">// If not the estimated quotient is off by 1</span></div><div class="line">           *ql = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (*ql, minus_one);</div><div class="line">          <span class="comment">// And the remainder is negative, so add the divisor</span></div><div class="line">          t = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (t, ten31);</div><div class="line">        }</div><div class="line">      result = t;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    result = vrb;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p>Now we have all the operations needed to complete the implementation of long division by the decimal constant (10<sup>31</sup>).</p>
<div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a></div><div class="line">example_longdiv_10e31 (<a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *q, <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *d, <span class="keywordtype">long</span> <span class="keywordtype">int</span> _N)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> dn, qh, ql, rh;</div><div class="line">  <span class="keywordtype">long</span> <span class="keywordtype">int</span> i;</div><div class="line"></div><div class="line">  <span class="comment">// initial step for the top digits</span></div><div class="line">  dn = d[0];</div><div class="line">  qh = <a class="code" href="vec__int128__ppc_8h.html#a9a6a39212f8a8b9ebf20e0117e1e1e88">vec_divuq_10e31</a> (dn);</div><div class="line">  rh = <a class="code" href="vec__int128__ppc_8h.html#af4b3b91f7e80522d8a8c0c171e077b99">vec_moduq_10e31</a> (dn, qh);</div><div class="line">  q[0] = qh;</div><div class="line"></div><div class="line">  <span class="comment">// now we know the remainder is less than the divisor.</span></div><div class="line">  <span class="keywordflow">for</span> (i=1; i&lt;_N; i++)</div><div class="line">    {</div><div class="line">      dn = d[i];</div><div class="line">      ql = <a class="code" href="vec__int128__ppc_8h.html#afa2db6d665f837f96c746d88027e9e19">vec_divudq_10e31</a> (&amp;qh, rh, dn);</div><div class="line">      rh = <a class="code" href="vec__int128__ppc_8h.html#a31a893a75e42f5f6c4dfe793678fea59">vec_modudq_10e31</a> (rh, dn, &amp;ql);</div><div class="line">      q[i] = ql;</div><div class="line">    }</div><div class="line">  <span class="comment">// return the final remainder</span></div><div class="line">  <span class="keywordflow">return</span> rh;</div><div class="line">}</div></div><!-- fragment --><p> The result of each call to example_longdiv_10e31() is the output array <em>q</em> of quadwords containing the extended quotient, and the remainder as the return value. The input array <em>d</em> and output array <em>q</em> should not overlap in storage. The remainder is in the range 0-9999999999999999999999999999999 and is suitable for conversion to BCD or decimal characters. (see <a class="el" href="vec__bcd__ppc_8h.html#a5a1aec05a6dadcf5a1a8e028223745df" title="Vector Decimal Convert From Signed Quadword returning up to 31 BCD digits. ">vec_bcdcfsq()</a>). Repeated calls passing the quotient from the previous call as the dividend, reduces the quotient by 31 digits and returns another 31 digits in the remainder for conversion. This continues until the quotient is less than 10<sup>31</sup> which provides the highest order digits of the decimal result.</p>
<dl class="section note"><dt>Note</dt><dd>Similarly for long division in support of unsigned 32-digit BCD conversion using operations; <a class="el" href="vec__int128__ppc_8h.html#ae2b45341cc9cc918198bb69da0552098" title="Vector Divide by const 10e32 Unsigned Quadword. ">vec_divuq_10e32()</a>, <a class="el" href="vec__int128__ppc_8h.html#aff4f1d8a707289d2271eafad4aeb1e82" title="Vector Modulo by const 10e32 Unsigned Quadword. ">vec_moduq_10e32()</a>, <a class="el" href="vec__int128__ppc_8h.html#a917acd42e775f4bb323ba2104c52d7cb" title="Vector Divide Unsigned Double Quadword by const 10e32. ">vec_divudq_10e32()</a>, and <a class="el" href="vec__int128__ppc_8h.html#a2ccbd77900956c01a51b88e672e593c6" title="Vector Modulo Unsigned Double Quadword by const 10e32. ">vec_modudq_10e32()</a>. Long division for other constant divisors or multiple quadword divisors is an exercise for the student.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>The implementation above gives correct results for all the cases tested for divide by constants 10<sup>31</sup> and 10<sup>32</sup>). This is not a mathematical proof of correctness, just an observation. Anyone who finds a counter example or offers a mathematical proof should submit a bug report.</dd></dl>
<h1><a class="anchor" id="int128_perf_0_0"></a>
Performance data.</h1>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="abf1707d712cc191915a8f558eaaa1fe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_absduq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Absolute Difference Unsigned Quadword. </p>
<p>Compute the absolute difference of the quadwords. For each unsigned quadword, subtract VRB from VRA and return the absolute value of the difference.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">14 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">11 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>vector of unsigned __int128 </td></tr>
    <tr><td class="paramname">vrb</td><td>vector of unsigned __int128 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the absolute difference. </dd></dl>

</div>
</div>
<a class="anchor" id="a363fa7103ccd730c47bb34cb9f05e80b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_addcq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *&#160;</td>
          <td class="paramname"><em>cout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Add with carry Unsigned Quadword. </p>
<p>Add two vector __int128 values and return sum and the carry out.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8 </td><td align="left">1/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*cout</td><td>carry out from the sum of a and b. </td></tr>
    <tr><td class="paramname">a</td><td>128-bit vector treated a __int128. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated a __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 (lower 128-bits) sum of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7aaadba249ce46c4c94f78df1020da3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_addcuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Add &amp; write Carry Unsigned Quadword. </p>
<p>Add two vector __int128 values and return the carry out.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated a __int128. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated a __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 carry of the sum of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="af18b98d2d73f1afbc439e1407c78f305"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_addecuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>ci</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Add Extended &amp; write Carry Unsigned Quadword. </p>
<p>Add two vector __int128 values plus a carry-in (0|1) and return the carry out bit.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated a __int128. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated a __int128. </td></tr>
    <tr><td class="paramname">ci</td><td>Carry-in from vector bit[127]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>carry-out in bit[127] of the sum of a + b + c. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e27910c148d525e17d099688aec9ba1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_addeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *&#160;</td>
          <td class="paramname"><em>cout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>ci</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Add Extend with carry Unsigned Quadword. </p>
<p>Add two vector __int128 values plus a carry-in (0|1) and return sum and the carry out.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8 </td><td align="left">1/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*cout</td><td>carry out from the sum of a and b. </td></tr>
    <tr><td class="paramname">a</td><td>128-bit vector treated a __int128. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated a __int128. </td></tr>
    <tr><td class="paramname">ci</td><td>Carry-in from vector bit[127]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 (lower 128-bits) sum of a + b + c. </dd></dl>

</div>
</div>
<a class="anchor" id="a44e63f70b182d60fe03b43a80647451a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_addeuqm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>ci</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Add Extended Unsigned Quadword Modulo. </p>
<p>Add two vector __int128 values plus a carry (0|1) and return the modulo 128-bit result.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated a __int128. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated a __int128. </td></tr>
    <tr><td class="paramname">ci</td><td>Carry-in from vector bit[127]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 sum of a + b + c, modulo 128-bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a539de2a4426a84102471306acc571ce8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_adduqm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Add Unsigned Quadword Modulo. </p>
<p>Add two vector __int128 values and return result modulo 128-bits.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as a __int128. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as a __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 sum of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="a655de600915e449a8681572961939422"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_avguq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Average Unsigned Quadword. </p>
<p>Compute the average of two unsigned quadwords as (VRA + VRB + 1) / 2.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">14 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">11 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>vector unsigned quadwords </td></tr>
    <tr><td class="paramname">vrb</td><td>vector unsigned quadwords </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the absolute differences. </dd></dl>

</div>
</div>
<a class="anchor" id="a066cc120c198773a2f8dfd17480b7a49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_clzq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Count Leading Zeros Quadword. </p>
<p>Count leading zeros for a vector __int128 and return the count in a vector suitable for use with vector shift (left|right) and vector shift (left|right) by octet instructions.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">19-28 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">25-36 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated a __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector with bits 121:127 containing the count of leading zeros. </dd></dl>

</div>
</div>
<a class="anchor" id="adf308aff6d9e25ae55b2c9d998c5de68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmpeqsq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal Signed Quadword. </p>
<p>Compare signed __int128 (128-bit) integers and return all '1's, if vra == vrb, otherwise all '0's. We use vec_cmpequq as it works for both signed and unsigned compares.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an signed __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an signed __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector signed __int128 compare equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a7197cd5c6e946211f2718b5e8464cdc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmpequq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal Unsigned Quadword. </p>
<p>Compare unsigned __int128 (128-bit) integers and return all '1's, if vra == vrb, otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later, use the Vector Compare Equal Unsigned DoubleWord (<b>vcmpequd</b>) instruction. To get the correct quadword result, the doubleword element equal truth values are swapped, then <em>anded</em> with the original compare results. Otherwise use vector word compare and additional boolean logic to insure all word elements are equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an unsigned __int128s. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector unsigned __int128 compare equal. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7e92209124903c3e8c535263246ff37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmpgesq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than or Equal Signed Quadword. </p>
<p>Compare signed __int128 (128-bit) integers and return all '1's, if vra &gt;= vrb, otherwise all '0's.</p>
<p>Flip the operand sign bits and use vec_cmpgeuq for signed compare.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-16 </td><td align="left">1/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8-14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an signed __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an signed __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector signed __int128 compare greater than. </dd></dl>

</div>
</div>
<a class="anchor" id="abd88782f327214c07d42519b7d4c69ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmpgeuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than or Equal Unsigned Quadword. </p>
<p>Compare unsigned __int128 (128-bit) integers and return all '1's, if vra &gt;= vrb, otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later, use the Vector Subtract &amp; write Carry QuadWord (<b>vsubcuq</b>) instruction. This generates a carry for greater than or equal and NOT carry for less than. Then use vec_setb_cyq ro convert the carry into a vector bool. Here we use the pveclib implementations (<a class="el" href="vec__int128__ppc_8h.html#a95d3546b2fd6840b46b031c15b4f60d3" title="Vector Subtract and Write Carry Unsigned Quadword. ">vec_subcuq()</a> and <a class="el" href="vec__int128__ppc_8h.html#af74036e39e72e0f3c29706d30fbb96d1" title="Vector Set Bool from Quadword Carry. ">vec_setb_cyq()</a>), instead of &lt;altivec.h&gt; intrinsics, to address older compilers and POWER7.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8 </td><td align="left">2/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector unsigned __int128 compare greater than. </dd></dl>

</div>
</div>
<a class="anchor" id="a45ce55b0cba15cddb6764a900922d768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmpgtsq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than Signed Quadword. </p>
<p>Compare signed __int128 (128-bit) integers and return all '1's, if vra &gt; vrb, otherwise all '0's.</p>
<p>Flip the operand sign bits and use vec_cmpgtuq for signed compare.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-16 </td><td align="left">1/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8-14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an signed __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an signed __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector signed __int128 compare greater than. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4ce43dcbc14fb34623d5ece8073b86e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmpgtuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than Unsigned Quadword. </p>
<p>Compare unsigned __int128 (128-bit) integers and return all '1's, if vra &gt; vrb, otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later, use the Vector Subtract &amp; write Carry QuadWord (<b>vsubcuq</b>) instruction with the parameters reversed. This generates a carry for less than or equal and NOT carry for greater than. Then use vec_setb_ncq ro convert the carry into a vector bool. Here we use the pveclib implementations (<a class="el" href="vec__int128__ppc_8h.html#a95d3546b2fd6840b46b031c15b4f60d3" title="Vector Subtract and Write Carry Unsigned Quadword. ">vec_subcuq()</a> and <a class="el" href="vec__int128__ppc_8h.html#a921647d5b67f0de5006ee32fb3d9c4f1" title="Vector Set Bool from Quadword not Carry. ">vec_setb_ncq()</a>), instead of &lt;altivec.h&gt; intrinsics, to address older compilers and POWER7.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8 </td><td align="left">2/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector unsigned __int128 compare greater than. </dd></dl>

</div>
</div>
<a class="anchor" id="a3642b1e0d48117c91189f69dd0e955ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmplesq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than or Equal Signed Quadword. </p>
<p>Compare signed __int128 (128-bit) integers and return all '1's, if vra &lt;= vrb, otherwise all '0's.</p>
<p>Flip the operand sign bits and use vec_cmpleuq for signed compare.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-16 </td><td align="left">1/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8-14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an signed __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an signed __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector signed __int128 compare less than or equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a69b25e7f46986d00997fedaeeb7871c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmpleuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than or Equal Unsigned Quadword. </p>
<p>Compare unsigned __int128 (128-bit) integers and return all '1's, if vra &lt;= vrb, otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later, use the Vector Subtract &amp; write Carry QuadWord (<b>vsubcuq</b>) instruction. This generates a carry for greater than or equal and NOT carry for less than. Then use vec_setb_ncq ro convert the carry into a vector bool. Here we use the pveclib implementations (<a class="el" href="vec__int128__ppc_8h.html#a95d3546b2fd6840b46b031c15b4f60d3" title="Vector Subtract and Write Carry Unsigned Quadword. ">vec_subcuq()</a> and <a class="el" href="vec__int128__ppc_8h.html#af74036e39e72e0f3c29706d30fbb96d1" title="Vector Set Bool from Quadword Carry. ">vec_setb_cyq()</a>), instead of &lt;altivec.h&gt; intrinsics, to address older compilers and POWER7.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8 </td><td align="left">2/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector unsigned __int128 compare less than or equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a82d83d78ff2330205a8d74741b34a1be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmpltsq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than Signed Quadword. </p>
<p>Compare signed __int128 (128-bit) integers and return all '1's, if vra &lt; vrb, otherwise all '0's.</p>
<p>Flip the operand sign bits and use vec_cmpltuq for signed compare.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-16 </td><td align="left">1/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8-14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an signed __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an signed __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector unsigned __int128 compare less than. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f9ebc5ad32b151a3e08136d51aad4dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmpltuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than Unsigned Quadword. </p>
<p>Compare unsigned __int128 (128-bit) integers and return all '1's, if vra &lt; vrb, otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later, use the Vector Subtract &amp; write Carry QuadWord (<b>vsubcuq</b>) instruction. This generates a carry for greater than or equal and NOT carry for less than. Then use vec_setb_ncq ro convert the carry into a vector bool. Here we use the pveclib implementations (<a class="el" href="vec__int128__ppc_8h.html#a95d3546b2fd6840b46b031c15b4f60d3" title="Vector Subtract and Write Carry Unsigned Quadword. ">vec_subcuq()</a> and <a class="el" href="vec__int128__ppc_8h.html#a921647d5b67f0de5006ee32fb3d9c4f1" title="Vector Set Bool from Quadword not Carry. ">vec_setb_ncq()</a>), instead of &lt;altivec.h&gt; intrinsics, to address older compilers and POWER7.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8 </td><td align="left">2/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector unsigned __int128 compare less than. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2cdf052bf633951201589454e50f52e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmpnesq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal Signed Quadword. </p>
<p>Compare signed __int128 (128-bit) integers and return all '1's, if vra != vrb, otherwise all '0's. We use vec_cmpequq as it works for both signed and unsigned compares.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an signed __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an signed __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector signed __int128 compare not equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a186d0b94bbc652e700ab4e1733b9524c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_cmpneuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Not Equal Unsigned Quadword. </p>
<p>Compare unsigned __int128 (128-bit) integers and return all '1's, if vra != vrb, otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later, use the Vector Compare Equal Unsigned DoubleWord (<b>vcmpequd</b>) instruction. To get the correct quadword result, the doubleword element equal truth values are swapped, then <em>not anded</em> with the original compare results. Otherwise use vector word compare and additional boolean logic to insure all word elements are equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector boolean reflecting vector unsigned __int128 compare equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a391cc9e4b1221618840767c7487d3032"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsq_all_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Equal Signed Quadword. </p>
<p>Compare vector signed __int128 values and return true if vra and vrb are equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a269401b65405524bb2d971bef595cb0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsq_all_ge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Greater Than or Equal Signed Quadword. </p>
<p>Compare vector unsigned __int128 values and return true if vra &gt;= vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-15 </td><td align="left">1/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if Greater Than or Equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a62a38e9016e2d94a56f935ddded3830b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsq_all_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Greater Than Signed Quadword. </p>
<p>Compare vector signed __int128 values and return true if vra &gt; vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-15 </td><td align="left">1/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a88209b466e628a6a77c6ddab7a15b4c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsq_all_le </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Less Than or Equal Signed Quadword. </p>
<p>Compare vector signed __int128 values and return true if vra &lt;= vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-15 </td><td align="left">1/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if Less Than or Equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a395dad1916a94a6cdb2b601565d7ffce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsq_all_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Less Than Signed Quadword. </p>
<p>Compare vector signed __int128 values and return true if vra &lt; vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-15 </td><td align="left">1/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if Less Than, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af7587275a406a1e2437ef86c23e2875a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsq_all_ne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Not Equal Signed Quadword. </p>
<p>Compare vector signed __int128 values and return true if vra and vrb are not equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector signed __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean __int128 for all 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c2c01f3aa165fedba47600f87067768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpuq_all_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Equal Unsigned Quadword. </p>
<p>Compare vector unsigned __int128 values and return true if vra and vrb are equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af8f06b2c3d612a7cfdeb3bb883c59e19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpuq_all_ge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Greater Than or Equal Unsigned Quadword. </p>
<p>Compare vector unsigned __int128 values and return true if vra &gt;= vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-13 </td><td align="left">2/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if Greater Than or Equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac93dc5ed8bb3501470cf70c5cb5796a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpuq_all_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Greater Than Unsigned Quadword. </p>
<p>Compare vector unsigned __int128 values and return true if vra &gt; vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-13 </td><td align="left">2/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b7f505ebca731aa6fdc7433f82c0c6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpuq_all_le </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Less Than or Equal Unsigned Quadword. </p>
<p>Compare vector unsigned __int128 values and return true if vra &lt;= vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-13 </td><td align="left">2/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if Less Than or Equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a31ddb6149475e80f4a1d38277317d980"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpuq_all_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Less Than Unsigned Quadword. </p>
<p>Compare vector unsigned __int128 values and return true if vra &lt; vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-13 </td><td align="left">2/ 2cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if Less Than, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1799f860ba79e698c66b171392afde01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpuq_all_ne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Not Equal Unsigned Quadword. </p>
<p>Compare vector unsigned __int128 values and return true if vra and vrb are not equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as an vector unsigned __int128 (qword) element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean __int128 for all 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8bc23a0cd3f522c017ec95d5ce93a2f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_cmul100cuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *&#160;</td>
          <td class="paramname"><em>cout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector combined Multiply by 100 &amp; write Carry Unsigned Quadword. </p>
<p>compute the product of a 128 bit values a * 100. Only the low order 128 bits of the product are returned.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">13-15 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*cout</td><td>pointer to upper 128-bits of the product. </td></tr>
    <tr><td class="paramname">a</td><td>128-bit vector treated as unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector __int128 (lower 128-bits of the 256-bit product) a * 100. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3f85b6577e5ab0de2b3f68ca45dd33b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_cmul100ecuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *&#160;</td>
          <td class="paramname"><em>cout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>cin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector combined Multiply by 100 Extended &amp; write Carry Unsigned Quadword. </p>
<p>Compute the product of a 128 bit value a * 100 + digit(cin). The function return its low order 128 bits of the extended product. The first parameter (*cout) it the address of the vector to receive the generated carry out in the range 0-99.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">15-17 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*cout</td><td>pointer to upper 128-bits of the product. </td></tr>
    <tr><td class="paramname">a</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">cin</td><td>values 0-99 in bits 120:127 of a vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector __int128 (lower 128-bits of the 256-bit product) a * 100. </dd></dl>

</div>
</div>
<a class="anchor" id="a9449c746cad42f0cd9e2fe4560364e18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_cmul10cuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *&#160;</td>
          <td class="paramname"><em>cout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector combined Multiply by 10 &amp; write Carry Unsigned Quadword. </p>
<p>compute the product of a 128 bit values a * 10. Only the low order 128 bits of the product are returned.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">13-15 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">1/ 2cycles </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*cout</td><td>pointer to upper 128-bits of the product. </td></tr>
    <tr><td class="paramname">a</td><td>128-bit vector treated as a unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector __int128 (lower 128-bits of the 256-bit product) a * 10. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f250dfab2a4aee0fd247a1d0217237b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_cmul10ecuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *&#160;</td>
          <td class="paramname"><em>cout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>cin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector combined Multiply by 10 Extended &amp; write Carry Unsigned Quadword. </p>
<p>Compute the product of a 128 bit value a * 10 + digit(cin). Only the low order 128 bits of the extended product are returned.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">13-15 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">1/ 2cycles </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*cout</td><td>pointer to upper 128-bits of the product. </td></tr>
    <tr><td class="paramname">a</td><td>128-bit vector treated as a unsigned __int128. </td></tr>
    <tr><td class="paramname">cin</td><td>values 0-9 in bits 124:127 of a vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector __int128 (upper 128-bits of the 256-bit product) a * 10. </dd></dl>

</div>
</div>
<a class="anchor" id="ae320909aca43d55b8be1069f38544ee8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vec_divsq_10e31 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Divide by const 10e31 Signed Quadword. </p>
<p>Compute the quotient of a 128 bit values vra / 10e31.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="vec__int128__ppc_8h.html#ae320909aca43d55b8be1069f38544ee8" title="Vector Divide by const 10e31 Signed Quadword. ">vec_divsq_10e31()</a> and <a class="el" href="vec__int128__ppc_8h.html#aab5db88e4608d4a7408df9042adce86c" title="Vector Modulo by const 10e31 Signed Quadword. ">vec_modsq_10e31()</a> can be used to prepare for <b>Decimal Convert From Signed Quadword</b> (See <a class="el" href="vec__bcd__ppc_8h.html#a5a1aec05a6dadcf5a1a8e028223745df" title="Vector Decimal Convert From Signed Quadword returning up to 31 BCD digits. ">vec_bcdcfsq()</a>), This guarantees that the conversion to Vector BCD does not overflow and the 39-digit extended result is obtained.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">18-60 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">20-45 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>the dividend as a vector treated as a unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quotient as vector unsigned __int128. </dd></dl>

</div>
</div>
<a class="anchor" id="afa2db6d665f837f96c746d88027e9e19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_divudq_10e31 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *&#160;</td>
          <td class="paramname"><em>qh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Divide Unsigned Double Quadword by const 10e31. </p>
<p>Compute the quotient of 256 bit value vra||vrb / 10e31.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="vec__int128__ppc_8h.html#afa2db6d665f837f96c746d88027e9e19" title="Vector Divide Unsigned Double Quadword by const 10e31. ">vec_divudq_10e31()</a> and <a class="el" href="vec__int128__ppc_8h.html#a31a893a75e42f5f6c4dfe793678fea59" title="Vector Modulo Unsigned Double Quadword by const 10e31. ">vec_modudq_10e31()</a> can be used to perform long division of a multi-quaqword binary value by the constant 10e31. The final remainder can be passed to <b>Decimal Convert From Signed Quadword</b> (See <a class="el" href="vec__bcd__ppc_8h.html#a5a1aec05a6dadcf5a1a8e028223745df" title="Vector Decimal Convert From Signed Quadword returning up to 31 BCD digits. ">vec_bcdcfsq()</a>). Long division is repeated on the resulting multi-quadword quotient to extract 31-digits for each step. This continues until the multi-quadword quotient is less than 10e31 which provides the highest order 31-digits of the of the multiple precision binary to BCD conversion.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">12-192</td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-127 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*qh</td><td>the high quotient as a vector unsigned __int128. </td></tr>
    <tr><td class="paramname">vra</td><td>the high dividend as a vector unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>the low dividend as a vector unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the low quotient as vector unsigned __int128. </dd></dl>

</div>
</div>
<a class="anchor" id="a917acd42e775f4bb323ba2104c52d7cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_divudq_10e32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *&#160;</td>
          <td class="paramname"><em>qh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Divide Unsigned Double Quadword by const 10e32. </p>
<p>Compute the quotient of 256 bit value vra||vrb / 10e32.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="vec__int128__ppc_8h.html#a917acd42e775f4bb323ba2104c52d7cb" title="Vector Divide Unsigned Double Quadword by const 10e32. ">vec_divudq_10e32()</a> and <a class="el" href="vec__int128__ppc_8h.html#a2ccbd77900956c01a51b88e672e593c6" title="Vector Modulo Unsigned Double Quadword by const 10e32. ">vec_modudq_10e32()</a> can be used to perform long division of a multi-quaqword binary value by the constant 10e32. The final remainder can be passed to <b>Decimal Convert From Unsigned Quadword</b> (See <a class="el" href="vec__bcd__ppc_8h.html#a7b8b5371d537cd878ffb37337e93ba14" title="Vector Decimal Convert From Unsigned Quadword returning up to 32 BCD digits. ">vec_bcdcfuq()</a>). Long division it repeated on the resulting multi-quadword quotient to extract 32-digits for each step. This continues until the multi-quadword quotient result is less than 10e32 which provides the highest order 32-digits of the of the multiple precision binary to BCD conversion.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">12-192</td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-127 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*qh</td><td>the high quotient as a vector unsigned __int128. </td></tr>
    <tr><td class="paramname">vra</td><td>the high dividend as a vector unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>the low dividend as a vector unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the low quotient as vector unsigned __int128. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a6a39212f8a8b9ebf20e0117e1e1e88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_divuq_10e31 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Divide by const 10e31 Unsigned Quadword. </p>
<p>Compute the quotient of a 128 bit values vra / 10e31.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="vec__int128__ppc_8h.html#a9a6a39212f8a8b9ebf20e0117e1e1e88" title="Vector Divide by const 10e31 Unsigned Quadword. ">vec_divuq_10e31()</a> and <a class="el" href="vec__int128__ppc_8h.html#af4b3b91f7e80522d8a8c0c171e077b99" title="Vector Modulo by const 10e31 Unsigned Quadword. ">vec_moduq_10e31()</a> can be used to prepare for <b>Decimal Convert From Signed Quadword</b> (See <a class="el" href="vec__bcd__ppc_8h.html#a5a1aec05a6dadcf5a1a8e028223745df" title="Vector Decimal Convert From Signed Quadword returning up to 31 BCD digits. ">vec_bcdcfsq()</a>), This guarantees that the conversion to Vector BCD does not overflow and the 39-digit extended result is obtained.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-48 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-31 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>the dividend as a vector treated as a unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quotient as vector unsigned __int128. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2b45341cc9cc918198bb69da0552098"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_divuq_10e32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Divide by const 10e32 Unsigned Quadword. </p>
<p>Compute the quotient of a 128 bit values vra / 10e32.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="vec__int128__ppc_8h.html#ae2b45341cc9cc918198bb69da0552098" title="Vector Divide by const 10e32 Unsigned Quadword. ">vec_divuq_10e32()</a> and <a class="el" href="vec__int128__ppc_8h.html#aff4f1d8a707289d2271eafad4aeb1e82" title="Vector Modulo by const 10e32 Unsigned Quadword. ">vec_moduq_10e32()</a> can be used to prepare for <b>Decimal Convert From Unsigned Quadword</b> (See <a class="el" href="vec__bcd__ppc_8h.html#a7b8b5371d537cd878ffb37337e93ba14" title="Vector Decimal Convert From Unsigned Quadword returning up to 32 BCD digits. ">vec_bcdcfuq()</a>), This guarantees that the conversion to Vector BCD does not overflow and the 39-digit extended result is obtained.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-48 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-31 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>the dividend as a vector treated as a unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quotient as vector unsigned __int128. </dd></dl>

</div>
</div>
<a class="anchor" id="acef64f9ffe8af5a8f08b6bdd0a9e218f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vec_maxsq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Maximum Signed Quadword. </p>
<p>Compare Quadwords vra and vrb as signed integers and return the larger value in the result.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">12-18 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-18 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector __int128 maximum of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="adb02d0572ecc17eca0de6d4f0d9aa302"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_maxuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Maximum Unsigned Quadword. </p>
<p>Compare Quadwords vra and vrb as unsigned integers and return the larger value in the result.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned __int128 maximum of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="ab435fd182688a615fb88b6578321839d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vec_minsq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Minimum Signed Quadword. </p>
<p>Compare Quadwords vra and vrb as signed integers and return the smaller value in the result.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">12-18 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-18 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector __int128 minimum of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0fa6a9987d3bd9593d1780b1c28c390"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_minuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Minimum Unsigned Quadword. </p>
<p>Compare Quadwords vra and vrb as unsigned integers and return the smaller value in the result.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned __int128 int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned __int128 int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned __int128 minimum of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="aab5db88e4608d4a7408df9042adce86c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vec_modsq_10e31 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Modulo by const 10e31 Signed Quadword. </p>
<p>Compute the remainder of a 128 bit values vra % 10e31.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-52 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-23 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>the dividend as a vector treated as a signed __int128. </td></tr>
    <tr><td class="paramname">q</td><td>128-bit signed __int128 containing the quotient from <a class="el" href="vec__int128__ppc_8h.html#a9a6a39212f8a8b9ebf20e0117e1e1e88" title="Vector Divide by const 10e31 Unsigned Quadword. ">vec_divuq_10e31()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remainder as vector signed __int128. </dd></dl>

</div>
</div>
<a class="anchor" id="a31a893a75e42f5f6c4dfe793678fea59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_modudq_10e31 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *&#160;</td>
          <td class="paramname"><em>ql</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Modulo Unsigned Double Quadword by const 10e31. </p>
<p>Compute the remainder (vra||vrb) - (ql * 10e31).</p>
<dl class="section note"><dt>Note</dt><dd>As we are using 128-bit multiplicative inverse for 128-bit integer in a 256-bit divide, so the quotient may not be exact (one bit off). So we check here if the remainder is too high (greater than 10e31) and correct both the remainder and quotient if needed.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">12-124</td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">12-75 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>the high dividend as a vector unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>the low dividend as a vector unsigned __int128. </td></tr>
    <tr><td class="paramname">*ql</td><td>128-bit unsigned __int128 containing the quotient from <a class="el" href="vec__int128__ppc_8h.html#afa2db6d665f837f96c746d88027e9e19" title="Vector Divide Unsigned Double Quadword by const 10e31. ">vec_divudq_10e31()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remainder as vector unsigned __int128. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ccbd77900956c01a51b88e672e593c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_modudq_10e32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *&#160;</td>
          <td class="paramname"><em>ql</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Modulo Unsigned Double Quadword by const 10e32. </p>
<p>Compute the remainder (vra||vrb) - (ql * 10e32).</p>
<dl class="section note"><dt>Note</dt><dd>As we are using 128-bit multiplicative inverse for 128-bit integer in a 256-bit divide, so the quotient may not be exact (one bit off). So we check here if the remainder is too high (greater than 10e32) and correct both the remainder and quotient if needed.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">12-124</td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">12-75 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>the high dividend as a vector unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>the low dividend as a vector unsigned __int128. </td></tr>
    <tr><td class="paramname">*ql</td><td>128-bit unsigned __int128 containing the quotient from <a class="el" href="vec__int128__ppc_8h.html#afa2db6d665f837f96c746d88027e9e19" title="Vector Divide Unsigned Double Quadword by const 10e31. ">vec_divudq_10e31()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remainder as vector unsigned __int128. </dd></dl>

</div>
</div>
<a class="anchor" id="af4b3b91f7e80522d8a8c0c171e077b99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_moduq_10e31 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Modulo by const 10e31 Unsigned Quadword. </p>
<p>Compute the remainder of a 128 bit values vra % 10e31.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-52 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-23 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>the dividend as a vector treated as a unsigned __int128. </td></tr>
    <tr><td class="paramname">q</td><td>128-bit unsigned __int128 containing the quotient from <a class="el" href="vec__int128__ppc_8h.html#a9a6a39212f8a8b9ebf20e0117e1e1e88" title="Vector Divide by const 10e31 Unsigned Quadword. ">vec_divuq_10e31()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remainder as vector unsigned __int128. </dd></dl>

</div>
</div>
<a class="anchor" id="aff4f1d8a707289d2271eafad4aeb1e82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_moduq_10e32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Modulo by const 10e32 Unsigned Quadword. </p>
<p>Compute the remainder of a 128 bit values vra % 10e32.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-52 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-23 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>the dividend as a vector treated as a unsigned __int128. </td></tr>
    <tr><td class="paramname">q</td><td>128-bit unsigned __int128 containing the quotient from <a class="el" href="vec__int128__ppc_8h.html#ae2b45341cc9cc918198bb69da0552098" title="Vector Divide by const 10e32 Unsigned Quadword. ">vec_divuq_10e32()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remainder as vector unsigned __int128. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d183ebd232e5826be109cdaa421aeed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_msumudm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Sum Unsigned Doubleword Modulo. </p>
<p>compute the even and odd produ256 bit product of two 128 bit values a, b. Only the low order 128 bits of the product are returned.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">30-32 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as __vector unsigned long int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as __vector unsigned long int. </td></tr>
    <tr><td class="paramname">c</td><td>128-bit vector treated as __vector unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__vector unsigned Modulo Sum of the 128-bit even / odd products of operands a and b plus the unsigned __int128 operand c. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c641b0107fc3e1621ef729c04efd583"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_mul10cuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply by 10 &amp; write Carry Unsigned Quadword. </p>
<p>compute the product of a 128 bit value a * 10. Only the high order 128 bits of the product are returned. This will be binary coded decimal value 0-9 in bits 124-127, Bits 0-123 will be '0'.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">13-15 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as a unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 (upper 128-bits of the 256-bit product) a * 10 &gt;&gt; 128. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ca2a6427ecb9458858b5caaac8c4dca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_mul10ecuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>cin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply by 10 Extended &amp; write Carry Unsigned Quadword. </p>
<p>Compute the product of a 128 bit value a * 10 + digit(cin). Only the low order 128 bits of the extended product are returned.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">15-17 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">cin</td><td>values 0-9 in bits 124:127 of a vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 (upper 128-bits of the 256-bit product) a * 10 &gt;&gt; 128. </dd></dl>

</div>
</div>
<a class="anchor" id="a2245626e7b90621b33ba79b763a4215e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_mul10euq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>cin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply by 10 Extended Unsigned Quadword. </p>
<p>compute the product of a 128 bit value a * 10 + digit(cin). Only the low order 128 bits of the extended product are returned.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">13-15 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">cin</td><td>values 0-9 in bits 124:127 of a vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 (lower 128-bits) a * 10. </dd></dl>

</div>
</div>
<a class="anchor" id="a3675fa1a2334eff913df447904be78ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_mul10uq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply by 10 Unsigned Quadword. </p>
<p>compute the product of a 128 bit value a * 10. Only the low order 128 bits of the product are returned.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">13-15 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 (lower 128-bits) a * 10. </dd></dl>

</div>
</div>
<a class="anchor" id="a26f95e02f7b0551e3f2bb7e4b4da040d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_muleud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Even Unsigned Doublewords. </p>
<p>Multiple the even 64-bit doublewords of two vector unsigned long values and return the unsigned __int128 product of the even doublewords.</p>
<dl class="section note"><dt>Note</dt><dd>The element numbering changes between big and little-endian. So the compiler and this implementation adjusts the generated code to reflect this.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">21-23 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8-13 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned long int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned __int128 product of the even double words of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="a10780cd8a88f18ec564ee6254c179a06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mulhud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Unsigned Doubleword. </p>
<p>Multiple the corresponding doubleword elements of two vector unsigned long values and return the high order 64-bits, from each 128-bit product.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">28-32 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">11-16 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This operation can be used to effectively perform a divide by multiplying by the scaled multiplicative inverse (reciprocal).</dd></dl>
<p>Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 10, Integer Division by Constants.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned long int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long int of the high order 64-bits of the unsigned 128-bit product of the doubleword elements from vra and vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6be9c8f02e43c39a659d6bbc9c3a2d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_mulhuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Unsigned Quadword. </p>
<p>compute the 256 bit product of two 128 bit values a, b. The high order 128 bits of the product are returned.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">56-64 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">33-39 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned __int128 (upper 128-bits) of a * b. </dd></dl>

</div>
</div>
<a class="anchor" id="a9aaaf0e4c2705be1e0e8e925b09c52de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_mulluq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Low Unsigned Quadword. </p>
<p>compute the 256 bit product of two 128 bit values a, b. Only the low order 128 bits of the product are returned.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">42-48 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">16-20 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned __int128 (lower 128-bits) a * b. </dd></dl>

</div>
</div>
<a class="anchor" id="aa989582cbfaa7984f78a937225e92f4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_muloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Odd Unsigned Doublewords. </p>
<p>Multiple the odd 64-bit doublewords of two vector unsigned long values and return the unsigned __int128 product of the odd doublewords.</p>
<dl class="section note"><dt>Note</dt><dd>The element numbering changes between big and little-endian. So the compiler and this implementation adjusts the generated code to reflect this.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">21-23 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8-13 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned long int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned __int128 product of the odd double words of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f19a53d6d28ac9b2aab5b8e1c5b2cbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_muludm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Unsigned Doubleword Modulo. </p>
<p>Multiple the corresponding doubleword elements of two vector unsigned long values and return the low order 64-bits of the 128-bit product for each element.</p>
<dl class="section note"><dt>Note</dt><dd>vec_muludm can be used for unsigned or signed integers. It is the vector equivalent of Multiply Low Doubleword.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">19-28 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">11-16 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned long int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long int of the low order 64-bits of the unsigned 128-bit product of the doubleword elements from vra and vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="aee5c5b2998ef105b4c6f39739748ffa8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_muludq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> *&#160;</td>
          <td class="paramname"><em>mulu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Unsigned Double Quadword. </p>
<p>compute the 256 bit product of two 128 bit values a, b. The low order 128 bits of the product are returned, while the high order 128-bits are "stored" via the mulu pointer.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">56-64 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">33-39 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*mulu</td><td>pointer to vector unsigned __int128 to receive the upper 128-bits of the product. </td></tr>
    <tr><td class="paramname">a</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned __int128 (lower 128-bits) of a * b. </dd></dl>

</div>
</div>
<a class="anchor" id="ae05185c980535dd28aec3a2a9431cb69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_popcntq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Population Count Quadword. </p>
<p>Count the number of '1' bits within a vector __int128 and return the count (0-128) in a vector __int128.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">15 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">16 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector with bits 121:127 containing the population count. </dd></dl>

</div>
</div>
<a class="anchor" id="aa40644aaa8146d00f84fce58dd4fd24e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_revbq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Byte Reverse Quadword. </p>
<p>Return the bytes / octets of a 128-bit vector in reverse order.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2 cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector with the bytes in reserve order. </dd></dl>

</div>
</div>
<a class="anchor" id="a52b3bfcc5b277628cd80ecd90440f8a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_rlq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Rotate Left Quadword. </p>
<p>Vector Rotate Left Quadword 0-127 bits. The shift amount is from bits 121-127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10 </td><td align="left">1 cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>Shift amount in bits 121:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Left shifted vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a4777f3b762c3313df0a13aa352c2f189"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_rlqi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Rotate Left Quadword Immediate. </p>
<p>Vector Rotate Left Quadword 0-127 bits. The shift amount is from bits 121-127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10 </td><td align="left">1 cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">shb</td><td>Shift amount in the range 0-127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Left shifted vector. </dd></dl>

</div>
</div>
<a class="anchor" id="af74036e39e72e0f3c29706d30fbb96d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_setb_cyq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vcy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Set Bool from Quadword Carry. </p>
<p>If the vector quadword carry bit (vcy.bit[127]) is '1' then return a vector bool __int128 that is all '1's. Otherwise return all '0's.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 - 6 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 - 5 </td><td align="left">2/cycle </td></tr>
</table>
<p>Vector quadword carries are normally the result of a <em>write-Carry</em> operation. For example; <a class="el" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3" title="Vector Add &amp; write Carry Unsigned Quadword. ">vec_addcuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#af18b98d2d73f1afbc439e1407c78f305" title="Vector Add Extended &amp; write Carry Unsigned Quadword. ">vec_addecuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a95d3546b2fd6840b46b031c15b4f60d3" title="Vector Subtract and Write Carry Unsigned Quadword. ">vec_subcuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a04f6df21399a4e6228eca254611b23c5" title="Vector Subtract Extended and Write Carry Unsigned Quadword. ">vec_subecuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a363fa7103ccd730c47bb34cb9f05e80b" title="Vector Add with carry Unsigned Quadword. ">vec_addcq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a9e27910c148d525e17d099688aec9ba1" title="Vector Add Extend with carry Unsigned Quadword. ">vec_addeq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vcy</td><td>a 128-bit vector generated from a <em>write-Carry</em> operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector bool of all '1's if the carry bit is '1'. Otherwise all '0's. </dd></dl>

</div>
</div>
<a class="anchor" id="a921647d5b67f0de5006ee32fb3d9c4f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_setb_ncq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vcy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Set Bool from Quadword not Carry. </p>
<p>If the vector quadword carry bit (vcy.bit[127]) is '1' then return a vector bool __int128 that is all '0's. Otherwise return all '1's.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 - 6 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 - 5 </td><td align="left">2/cycle </td></tr>
</table>
<p>Vector quadword carries are normally the result of a <em>write-Carry</em> operation. For example; <a class="el" href="vec__int128__ppc_8h.html#ad7aaadba249ce46c4c94f78df1020da3" title="Vector Add &amp; write Carry Unsigned Quadword. ">vec_addcuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#af18b98d2d73f1afbc439e1407c78f305" title="Vector Add Extended &amp; write Carry Unsigned Quadword. ">vec_addecuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a95d3546b2fd6840b46b031c15b4f60d3" title="Vector Subtract and Write Carry Unsigned Quadword. ">vec_subcuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a04f6df21399a4e6228eca254611b23c5" title="Vector Subtract Extended and Write Carry Unsigned Quadword. ">vec_subecuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a363fa7103ccd730c47bb34cb9f05e80b" title="Vector Add with carry Unsigned Quadword. ">vec_addcq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a9e27910c148d525e17d099688aec9ba1" title="Vector Add Extend with carry Unsigned Quadword. ">vec_addeq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vcy</td><td>a 128-bit vector generated from a <em>write-Carry</em> operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector bool of all '1's if the carry bit is '0'. Otherwise all '0's. </dd></dl>

</div>
</div>
<a class="anchor" id="af21d01bb19f0ea8605d8c37035837802"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ab5d79f74c685d3a42b49c413d0144d65">vb128_t</a> vec_setb_sq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Set Bool from Signed Quadword. </p>
<p>If the quadword's sign bit is '1' then return a vector bool __int128 that is all '1's. Otherwise return all '0's.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 - 6 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5 - 8 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as signed __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector bool of all '1's if the sign bit is '1'. Otherwise all '0's. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ba40be93339359793ef776e1d5d7577"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_sldq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Left Double Quadword. </p>
<p>Vector Shift Left double Quadword 0-127 bits. Return a vector __int128 that is the left most 128-bits after shifting left 0-127-bits of the 256-bit double vector (vrw||vrx). The shift amount is from bits 121:127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10 </td><td align="left">1 cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vrw</td><td>upper 128-bits of the 256-bit double vector. </td></tr>
    <tr><td class="paramname">vrx</td><td>lower 128-bits of the 256-bit double vector. </td></tr>
    <tr><td class="paramname">vrb</td><td>Shift amount in bits 121:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>high 128-bits of left shifted double vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa33904ec4de42f54cceab34adb303c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_sldqi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Left Double Quadword Immediate. </p>
<p>Vector Shift Left double Quadword 0-127 bits. Return a vector __int128 that is the left most 128-bits after shifting left 0-127-bits of the 256-bit double vector (vrw||vrx). The shift amount is from bits 121:127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10 </td><td align="left">1 cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vrw</td><td>upper 128-bits of the 256-bit double vector. </td></tr>
    <tr><td class="paramname">vrx</td><td>lower 128-bits of the 256-bit double vector. </td></tr>
    <tr><td class="paramname">shb</td><td>Shift amount in the range 0-127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>high 128-bits of left shifted double vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a49fe2c36fca9911ab99a1f8abb53f0ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_slq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Left Quadword. </p>
<p>Vector Shift Left Quadword 0-127 bits. The shift amount is from bits 121-127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>Shift amount in bits 121:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Left shifted vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f6dca233bb7e4edc2adb751d478572e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_slq4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Vector Shift Left 4-bits Quadword. Replaced by vec_slqi with shb param = 4.</dd></dl>
<p>Vector Shift Left Quadword 0-127 bits. The shift amount is from bits 121-127 of vrb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated a __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Left shifted vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a9964ce224b90a0986122f79f6455cba5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_slq5 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Vector Shift Left 5-bits Quadword. Replaced by vec_slqi with shb param = 5.</dd></dl>
<p>Vector Shift Left Quadword 0-127 bits. The shift amount is from bits 121-127 of vrb. </p><pre class="fragment"> @param vra a 128-bit vector treated a __int128.
 @return Left shifted vector.</pre> 
</div>
</div>
<a class="anchor" id="a070fe972995f3954362835f5b72e5ff6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_slqi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Left Quadword Immediate. </p>
<p>Shift left Quadword 0-127 bits. The shift amount is a const unsigned int in the range 0-127. A shift count of 0 returns the original value of vra. Shift counts greater then 127 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2 cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-15 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">shb</td><td>Shift amount in the range 0-127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector shifted left shb bits. </dd></dl>

</div>
</div>
<a class="anchor" id="ab99c4af0aae31b02e1f17f12500198f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vec_sraq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Algebraic Quadword. </p>
<p>Vector Shift Right Algebraic Quadword 0-127 bits. The shift amount is from bits 121-127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10 </td><td align="left">1 cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as signed __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>Shift amount in bits 121:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Right algebraic shifted vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a50546b5b39e0c21cffe678f225ff59b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a> vec_sraqi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#ac1c414a60e2a13398427203b40e8dd3f">vi128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Algebraic Quadword Immediate. </p>
<p>Vector Shift Right Algebraic Quadword 0-127 bits. The shift amount is from bits 121-127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-15 </td><td align="left">1 cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-18 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>vec_sraqi optimizes for some special cases. For shift by octet (multiple of 8 bits) use vec_setb_sq () to extend sign then vector shift left double by octet immediate by (16 - (shb / 8)) to effect the right octet shift. For _ARCH_PWR8 and shifts less than 64 bits, use both vec_srqi () and vector shift right algebraic doubleword. Then use vec_pasted () to combine the high 64-bits from vec_sradi () and the low 64-bits from vec_srqi ().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as signed __int128. </td></tr>
    <tr><td class="paramname">shb</td><td>Shift amount in the range 0-127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Right algebraic shifted vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a0edd172a5656b842d6586c5078284942"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_srq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Quadword. </p>
<p>Vector Shift Right Quadword 0-127 bits. The shift amount is from bits 121-127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>Shift amount in bits 121:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Right shifted vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a49d355191fabd04a434723265ccafa20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_srq4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Vector Shift right 4-bits Quadword. Replaced by vec_srqi with shb param = 4.</dd></dl>
<p>Vector Shift Right Quadword 0-127 bits. The shift amount is from bits 121-127 of vrb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Right shifted vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a257bcf71eefa1d08482587637dc400da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_srq5 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Vector Shift right 5-bits Quadword. Replaced by vec_srqi with shb param = 5.</dd></dl>
<p>Vector Shift Right Quadword 0-127 bits. The shift amount is from bits 121-127 of vrb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated a __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Right shifted vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ac05c640c6a42770cb95466ff4a2d903c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_srqi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Quadword Immediate. </p>
<p>Shift right Quadword 0-127 bits. The shift amount is a const unsigned int in the range 0-127. A shift count of 0 returns the original value of vra. Shift counts greater then 127 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2 cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-15 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">shb</td><td>Shift amount in the range 0-127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector shifted right shb bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a95d3546b2fd6840b46b031c15b4f60d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_subcuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Subtract and Write Carry Unsigned Quadword. </p>
<p>Generate the carry-out of the sum (vra + NOT(vrb) + 1).</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 carry from the unsigned difference vra - vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="a04f6df21399a4e6228eca254611b23c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_subecuq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Subtract Extended and Write Carry Unsigned Quadword. </p>
<p>Generate the carry-out of the sum (vra + NOT(vrb) + vrc.bit[127]).</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">vrc</td><td>128-bit vector carry-in from bit 127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 carry from the extended __int128 difference. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e40f9bf5df59b725cbfb6738c765202"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_subeuqm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Subtract Extended Unsigned Quadword Modulo. </p>
<p>Subtract two vector __int128 values and return result modulo 128-bits.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">vrc</td><td>128-bit vector carry-in from bit 127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 unsigned difference of vra minus vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bafb410404d4f1e10a99263b57d1df0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_subuqm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Subtract Unsigned Quadword Modulo. </p>
<p>Subtract two vector __int128 values and return result modulo 128-bits.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector treated as unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>__int128 unsigned difference of vra minus vrb. </dd></dl>

</div>
</div>
<a class="anchor" id="a84e6361054b52ac4564bcef25b718151"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_vmuleud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Even Unsigned Doublewords. </p>
<p>Multiply the even 64-bit doublewords of two vector unsigned long values and return the unsigned __int128 product of the even doublewords.</p>
<dl class="section note"><dt>Note</dt><dd>This function implements the operation of a Vector Multiply Even Doubleword instruction, as if the PowerISA included such an instruction. This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">21-23 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8-13 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned long int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned __int128 product of the even double words of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="a208744996e7482604ad274b44999d6ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a66332b4bd68c0b5d93121f6dc0f0839b">vui128_t</a> vec_vmuloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Odd Unsigned Doublewords. </p>
<p>Multiply the odd 64-bit doublewords of two vector unsigned long values and return the unsigned __int128 product of the odd doublewords.</p>
<dl class="section note"><dt>Note</dt><dd>This function implements the operation of a Vector Multiply Odd Doubleword instruction, as if the PowerISA included such an instruction. This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">21-23 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8-13 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned long int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned __int128 product of the odd double words of a and b. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 17 2019 16:40:44 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
